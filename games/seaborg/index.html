<!DOCTYPE HTML>
<html>

<!-- Borksy 4.2 -->
<!-- Bitsy 6.4 -->

<!-- HEADER -->
<head>

<meta charset="UTF-8">

<title>Seaborg's Manor</title>

<script type="text/bitsyGameData" id="exportedGameData">
Seaborg's Manor

# BITSY VERSION 6.4

! ROOM_FORMAT 1

PAL 0
81,11,19
188,52,88
188,52,88

PAL 1
0,0,0
255,255,255
255,255,255

PAL 2
255,255,255
0,0,0
0,0,0

PAL 3
110,169,163
154,228,165
188,52,88

PAL 4
110,169,163
154,228,165
154,228,165

PAL 5
67,104,100
108,159,115
108,159,115

ROOM 0
0,0,0,0,0,0,0,0,0,t,u,x,0,x,0,w
0,0,1n,p,0,0,0,0,0,0,0,t,u,x,0,w
p,1o,1g,1f,1o,p,p,1n,0,0,0,0,0,t,u,v
2a,0,1d,1e,0,2a,0,p,0,0,0,0,0,0,1n,0
b,27,2r,2q,21,q,a,0,p,0,0,0,0,0,0,0
c,b,b,1q,b,c,q,a,0,p,0,0,0,1n,0,0
c,1s,c,c,l,c,c,q,a,0,p,0,1n,0,0,0
c,c,c,c,i,h,k,c,q,a,0,p,0,0,0,0
j,j,l,c,1h,g,c,1s,c,q,a,0,p,0,0,1n
i,h,k,b,b,b,b,b,b,1s,q,a,0,p,n,p
0,9e,j,16,17,c,c,16,17,c,c,r,a,0,m,0
1q,b,f,1q,1r,b,1q,1r,1q,b,1q,1r,f,f,b,b
f,f,e,0,0,c,f,e,0,c,f,e,f,e,f,c
e,f,0,0,0,f,e,0,0,f,e,0,e,0,e,f
0,e,0,0,0,e,0,0,0,e,0,0,0,0,0,e
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME Great Hall - West Cut
EXT 0,10 1 15,10 FX slide_l
EXT 2,3 3 7,12 FX tunnel
EXT 0,3 1 15,3 FX slide_l
EXT 15,10 f 0,10 FX slide_r
EXT 13,13 y 2,2
EXT 13,13 y 2,2
EXT 13,13 y 2,2
EXT 13,13 y 2,2
EXT 13,13 y 2,2
PAL 0

ROOM 1
0,w,x,0,w,0,0,p,0,0,0,0,0,0,1n,0
0,w,x,0,w,0,1n,0,0,0,0,p,p,0,0,0
0,w,x,0,w,0,0,p,p,p,1o,1g,1f,1o,p,p
0,w,t,u,v,0,0,p,o,2a,0,1d,1e,0,o,o
u,v,0,0,0,0,0,0,1c,k,27,2q,2r,21,b,b
0,0,0,0,0,0,0,1n,0,g,k,b,1q,b,1s,c
0,0,0,0,0,0,0,0,0,0,h,k,j,c,c,c
0,0,1n,0,0,0,0,0,0,1n,g,l,j,j,l,c
0,0,0,0,0,0,0,0,0,0,p,i,h,g,k,j
p,1m,p,1m,p,1m,p,1m,p,p,p,p,1n,p,i,g
1j,1l,1j,1l,1j,1l,1j,1l,1i,0,0,0,0,0,0,0
1r,b,b,f,b,b,f,b,b,1r,b,b,f,1q,b,f
e,0,f,e,f,0,e,f,c,e,f,f,e,0,f,e
0,0,e,0,e,0,0,e,f,0,e,f,0,0,e,0
0,0,0,0,0,0,0,0,e,0,0,e,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME Banquet Hall
EXT 15,10 0 0,10 FX slide_r
EXT 11,3 2 4,13 FX tunnel
EXT 15,3 0 0,3 FX slide_r
EXT 0,10 4 15,10 FX slide_l
PAL 0

ROOM 2
0,1o,1g,1f,1o,0,0,0,0,0,0,0,0,0,0,0
0,p,1d,1e,0,p,0,0,0,0,0,0,0,0,0,0
0,0,f,q,a,0,p,0,1n,0,0,0,0,0,0,0
0,0,g,j,q,a,0,p,0,0,0,1n,0,0,0,0
0,0,0,h,k,q,a,0,p,0,0,0,0,0,0,0
0,0,0,0,b,b,q,a,0,p,0,0,0,0,0,0
0,0,0,0,f,b,f,q,a,0,p,p,p,1y,0,0
0,0,0,0,e,f,e,b,q,a,o,o,1w,1z,p,0
0,1n,0,0,0,e,0,b,f,p,20,21,1v,1s,1r,0
0,0,0,0,0,0,0,f,1u,0,1t,1v,h,j,1u,0
0,0,0,0,1n,0,0,1u,0,1t,1v,b,0,i,0,0
0,0,0,0,p,p,p,0,1t,1v,f,f,0,0,0,0
0,0,0,1o,1g,1f,1p,1t,1v,f,e,f,0,0,0,0
1n,0,p,0,1d,1e,1t,1v,e,e,0,e,0,0,0,0
0,0,0,22,1s,1s,b,f,0,0,0,0,0,1n,0,0
0,0,0,0,1c,b,1h,i,0,0,0,0,0,0,0,0
NAME West Parapet Stairway
EXT 4,13 1 11,3 FX tunnel
EXT 2,1 9 1,11 FX tunnel
PAL 0

ROOM 3
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,2h,0,0,0,0,2h,0,0,0,0,0,0
0,25,0,0,0,0,2h,0,0,0,0,2h,0,0,25,0
0,24,25,0,0,0,0,0,2h,0,0,0,0,25,24,0
0,24,24,0,0,2h,0,0,0,0,0,2h,0,24,24,0
0,24,24,25,0,0,0,0,0,2h,0,0,25,24,24,0
0,24,24,24,0,0,0,0,0,0,0,0,24,24,24,0
0,24,24,24,0,0,2d,2e,2d,2e,0,0,24,24,24,0
0,24,24,24,p,p,2p,2f,2g,2o,p,p,24,24,24,0
0,24,24,24,28,2a,2b,2m,2n,2c,o,29,24,24,24,0
0,1a,1a,1a,27,2r,23,23,23,23,2q,21,1a,1a,1a,0
0,j,c,c,q,a,1p,1g,1f,1p,1t,1v,c,c,j,0
0,g,j,c,c,q,a,1d,1e,1t,1v,c,c,j,h,0
0,g,c,c,j,c,b,b,b,b,c,c,c,h,e,0
0,g,h,j,c,c,c,c,c,c,j,c,c,j,i,0
0,0,0,i,l,l,h,h,k,l,h,k,e,i,0,0
NAME Encrypted Archives
EXT 7,12 0 2,3 FX tunnel
PAL 0

ROOM 4
0,x,0,w,x,0,w,w,0,0,0,0,x,0,x,0
0,x,0,w,t,u,v,w,0,0,0,0,x,0,x,0
0,t,u,v,0,t,u,v,0,1n,0,0,x,0,x,0
33,30,3x,1n,0,0,0,0,0,3i,3j,0,t,u,x,0
31,2z,3l,0,0,0,0,0,y,14,14,10,0,0,t,u
31,2w,2x,0,0,0,1n,0,15,3h,3f,12,0,0,0,0
31,2w,2y,1n,0,0,0,1o,15,3h,3f,12,1o,0,1n,0
31,2w,2x,0,0,0,0,0,15,3e,3g,12,0,0,0,0
31,2w,2y,0,0,0,0,0,z,13,13,11,0,0,0,0
31,2w,2x,1o,2t,1o,p,1n,p,1m,0,1m,p,1m,p,1m
34,2v,0,0,2s,0,0,0,1k,1l,3m,3n,3o,3p,1j,1l
35,38,39,27,2r,21,f,b,b,b,1q,b,f,b,b,1q
36,37,e,f,b,f,e,0,c,f,f,0,e,0,c,0
0,0,0,e,f,1u,0,0,f,e,e,0,0,0,f,0
0,0,0,0,1u,0,0,0,e,0,0,0,0,0,e,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME Banquet Hall II
EXT 15,10 1 0,10 FX slide_r
EXT 4,10 7 4,10 FX tunnel
PAL 0

ROOM 5
0,0,0,0,2u,0,45,0,0,0,0,3q,41,3w,0,0
45,0,0,0,e,0,0,0,0,0,0,3q,41,3w,3x,0
0,0,0,3u,0,3u,0,3u,0,3u,0,3q,41,3w,0,45
0,3s,3t,3t,3t,3t,3t,3t,3t,3t,3t,40,41,3z,3v,0
3r,3q,0,0,0,0,0,0,45,0,0,p,41,p,3w,3x
0,3q,0,0,4a,4b,0,4k,4l,0,4a,4b,41,p,3w,0
3r,3q,45,0,47,49,4i,4j,4g,4h,47,49,41,p,3w,3x
0,3q,0,0,46,48,4e,4f,4e,4f,46,48,41,p,3w,0
3r,3q,4a,4b,4c,4d,4c,23,23,4d,4c,4d,41,4w,3w,3x
0,3q,47,49,0,4k,4l,45,0,4k,4l,p,41,p,3w,0
3r,3q,46,48,4i,4j,4g,4h,4i,4j,4g,4h,41,p,3w,3x
0,3q,4a,4b,4e,4f,4e,4f,4e,4f,4e,4f,41,p,3w,0
3r,3q,47,49,4c,23,23,4d,4c,23,23,4d,41,p,3w,3x
0,3q,46,4m,6b,6c,45,0,0,45,0,43,42,44,3w,0
0,0,3y,3y,3y,3y,3y,3y,3y,3y,3y,3y,3y,3y,0,0
0,0,45,0,0,0,0,45,0,0,0,45,0,45,0,0
NAME Wine Cellar
EXT 3,13 6 3,13
EXT 12,0 7 12,15 FX slide_u
PAL 0

ROOM 6
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,1p,0,0,0,0,0,0,1p,0,0,0,0,0,0
0,0,0,0,0,4z,0,0,0,0,0,0,51,4y,0,0
0,0,4z,51,0,50,0,0,0,4z,0,0,0,50,0,0
0,0,50,0,0,0,0,0,0,50,0,0,0,1p,0,0
0,0,0,0,1p,0,0,0,0,0,0,0,0,51,4y,0
0,0,0,0,0,0,4z,51,0,0,4y,0,0,0,50,0
0,4x,51,0,0,0,50,0,0,0,0,0,0,0,0,0
0,50,0,0,0,0,0,0,1p,0,0,0,4y,0,0,0
0,0,0,4z,51,0,0,0,0,0,0,0,50,0,0,0
0,1p,0,50,0,0,0,0,0,4y,0,0,0,0,1p,0
0,0,p,p,0,0,4x,51,0,50,0,0,1p,0,0,0
0,p,4p,4q,p,0,50,0,0,4y,0,0,0,0,0,0
0,p,4n,4o,p,0,0,1p,0,50,0,0,51,4y,0,0
0,0,p,p,0,0,0,0,0,0,0,0,0,50,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME Bar
ITM 0 2,13
EXT 3,13 5 3,13
PAL 0

ROOM 7
0,0,0,0,0,0,0,0,0,0,0,0,3q,65,3w,0
0,0,0,0,45,0,0,0,0,0,0,3r,3q,65,3w,3x
0,0,0,3u,0,3u,0,3u,0,3u,0,3u,3q,65,3w,0
0,3s,6a,3t,3t,3t,3t,3t,3t,3t,3t,3t,40,65,3w,3x
3r,3q,69,5h,5j,5j,5m,0,0,5h,5j,5j,5m,65,3w,0
0,3q,69,5i,5k,5l,5n,p,p,5i,5k,5l,5n,65,3w,3x
3r,3q,66,67,68,5e,5f,5g,4r,0,61,62,63,64,3w,0
0,3q,4c,23,4d,4c,5r,4d,41,4c,23,5r,23,4d,3w,3x
3r,3q,5u,5v,p,5q,5q,5t,41,0,0,5q,4r,p,3w,0
0,3q,5x,5w,2t,4c,23,23,23,23,23,4d,41,p,3w,3x
3r,3q,4r,0,2s,0,0,4r,6d,5e,5f,5g,41,p,3w,0
0,3q,41,4c,23,23,4d,41,4c,23,23,23,4d,p,3w,3x
3r,3q,41,p,5b,5c,5d,41,5b,5c,5d,5y,5z,60,3w,0
0,3q,41,0,57,59,58,41,57,59,58,4u,4r,4v,3w,3x
0,53,5a,5a,5a,5a,5a,5a,5a,5a,5a,4s,41,4t,52,0
0,45,0,0,2u,0,0,0,45,0,0,3q,41,3w,3x,0
NAME Kitchen
EXT 4,10 4 4,10 FX tunnel
EXT 12,15 5 12,0 FX slide_d
EXT 13,6 9 13,10 FX slide_u
PAL 0

ROOM 8
31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31
31,31,31,31,31,31,34,31,31,31,31,31,31,31,31,31
31,31,31,31,31,31,75,31,31,31,31,31,31,31,31,31
31,31,31,31,31,31,74,31,31,31,31,31,31,31,31,31
31,31,31,34,34,34,6s,6t,6t,6t,6t,6t,6t,6t,6u,31
31,31,31,6x,6y,6z,3w,3x,0,1n,0,0,0,0,3q,31
31,31,31,72,71,70,3w,0,0,0,0,1n,0,3r,3q,31
31,31,31,77,31,31,3w,3x,0,0,0,0,0,3r,3q,31
31,31,31,77,31,31,3w,0,0,0,0,0,0,0,3q,31
31,31,31,77,31,31,3w,3x,0,0,0,1n,0,0,3q,31
31,31,76,77,76,76,3w,1o,1g,1f,1o,p,7t,p,3q,31
31,76,2a,6w,o,2a,78,6v,1d,1e,6v,6v,6v,6v,3q,34
31,4t,5a,5a,5a,5a,5a,7p,14,2r,7r,5a,5a,5a,5a,4s
31,3w,3x,0,0,1n,0,7q,23,23,7s,0,0,0,0,3q
31,3w,0,73,0,0,73,0,0,73,0,0,1n,0,3r,3q
34,3w,3x,0,0,0,0,1n,0,0,0,0,0,0,0,3q
NAME West Parapet
EXT 8,11 9 8,11 FX tunnel
PAL 0

ROOM 9
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,7x,7w,7w,7w,7w,7w,7w,7w,7w,7w,7y
0,0,0,0,0,7x,x,w,0,0,0,x,0,x,w,7y
0,0,0,0,0,7x,x,w,y,14,10,x,0,x,w,7y
0,0,0,0,0,7x,x,w,15,7m,12,t,u,x,w,7y
0,0,0,0,0,7x,t,v,7k,7l,7j,0,0,x,w,7y
7x,7w,7w,7w,7w,7w,0,0,0,0,0,0,0,t,v,7y
7x,1o,1g,1f,1o,7u,p,6l,1g,1f,3a,3b,p,7o,7i,7y
7x,0,1d,1e,0,0,5o,6k,1d,1e,3c,3d,7c,79,7h,7y
7v,7v,7v,7v,7v,7v,7v,7v,7v,7v,7v,7v,7v,7v,7v,7v
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,7w,7w,7w,0
NAME King's Suite
ITM 1 9,11
EXT 8,11 8 8,11 FX tunnel
EXT 13,10 7 13,6 FX slide_d
EXT 1,11 2 2,1 FX tunnel
PAL 0

ROOM 10
0,0,eh,0,0,eh,0,0,eh,0,0,eh,0,0,eh,0
0,0,eh,0,0,eh,0,0,eh,0,0,eh,0,0,eh,0
0,0,eh,0,0,eh,0,0,eh,0,0,eh,0,0,eh,0
0,0,eh,0,0,eh,0,0,ei,0,0,ei,0,0,ei,0
0,0,eh,0,0,ei,0,0,0,0,0,0,0,0,0,0
0,0,ei,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,ej,ek,ek,ek,ek,ek,ek,ek,ek,ek
p,ee,ef,p,p,p,eh,p,em,p,em,p,em,p,em,p
0,ed,eg,0,er,0,eb,ec,el,ec,el,ec,el,ec,el,ec
e9,e9,e9,e9,e9,e9,e9,e9,e9,e9,e9,e9,e9,e9,e9,e9
0,ea,0,ea,0,ea,0,ea,0,ea,0,ea,0,ea,0,ea
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME bank
EXT 1,11 z 14,14 FX tunnel
EXT 15,11 11 0,11 FX slide_r
PAL 4

ROOM 11
0,0,eh,0,0,eh,0,0,eh,0,0,eh,0,0,eh,0
0,0,eh,0,0,eh,0,0,eh,0,0,eh,0,0,eh,0
0,0,eh,0,0,eh,0,0,eh,0,0,eh,0,0,eh,0
0,0,ei,0,0,ei,0,0,ei,0,0,eh,0,0,eh,0
0,0,0,0,0,0,0,0,0,0,0,ei,0,0,eh,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,ei,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ek,ek,ek,ek,ek,ek,ek,ek,eo,0,0,0,0,0,0,0
em,p,em,p,em,p,0,p,ep,p,p,p,p,p,p,p
el,ec,el,ec,el,ec,en,ec,eq,er,0,es,eu,0,0,0
e9,e9,e9,e9,e9,e9,e9,e9,e9,e9,e9,e9,e9,e9,e9,e9
0,ea,0,ea,0,ea,0,ea,0,ea,0,ea,0,ea,0,ea
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME bank 2
EXT 0,11 10 15,11 FX slide_l
PAL 4

ROOM 12
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,f3,f2,f2,f5,f3,f2,f2,f2,f2,f2,f2,f5,0,0
0,0,f7,f2,f2,f1,f4,f3,f2,f2,f2,f2,f2,f1,0,0
0,0,f3,f2,f2,f2,f1,f4,f3,f2,f2,f2,f2,f5,0,0
0,0,f7,f2,f2,f2,f2,f1,f4,0,0,0,0,f4,0,0
0,0,f3,f2,f2,f2,f2,f2,f1,0,f0,0,0,f4,0,0
0,0,f4,f8,f9,fa,fb,f9,fc,0,0,0,f0,f4,0,0
0,0,f4,0,0,0,0,0,0,0,f0,0,2t,f4,0,0
0,0,f4,f6,ex,fd,fe,ey,ex,ez,0,0,2s,f4,0,0
0,0,e9,e9,e9,e9,e9,e9,e9,e9,e9,e9,ev,e9,ew,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME bar
EXT 12,11 z 15,2 FX tunnel
PAL 5

ROOM 13
0,0,0,90,0,0,aj,aa,ab,ai,0,0,90,0,0,0
0,0,1n,0,90,1p,0,ak,al,0,1p,90,0,0,1n,0
0,90,0,0,0,9l,9m,9m,9m,9m,9n,0,0,d2,90,0
0,9q,9r,9s,0,9k,9k,9k,9k,9k,9k,9o,9q,9r,9s,0
1p,9u,a1,9z,1p,9k,9k,9k,9k,9k,9k,1p,9u,a3,9z,1p
1n,9u,a0,9z,ag,9k,9k,9k,9k,9k,9k,9o,9u,a0,9z,1n
90,9u,a1,9z,a5,9k,9k,9k,9k,9k,9k,9p,9u,a3,9z,90
0,9u,a0,9z,a5,9j,9j,9j,9j,9j,9j,90,9u,a0,9z,0
0,9v,9w,9x,a5,fj,fk,fl,fm,fn,0,0,9v,9w,9x,0
fg,fh,p,p,a5,90,0,0,0,0,0,0,0,p,1n,p
ff,fi,0,5q,d1,0,0,0,0,br,bs,0,8v,0,0,0
b,b,f,b,b,1q,b,c,b,1q,1q,b,b,1r,b,b
0,0,e,f,b,c,c,f,f,b,c,b,f,e,0,4y
4x,51,0,e,f,b,f,e,e,f,b,f,e,0,51,50
50,0,0,4x,e,f,e,0,0,e,f,e,0,4y,0,0
0,0,0,50,51,e,0,4z,51,0,e,51,0,50,0,0
NAME good end
END 0 7,9
END 1 6,10
END 2 8,10
END 7 7,11
PAL 0

ROOM 14
b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
b2,b2,b2,b2,b2,b2,fo,fp,fm,fn,b2,b2,b2,b2,b2,b2
b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
b2,b2,b2,b2,b2,b2,b3,b3,b3,b2,b2,b2,b2,b2,b2,b2
b2,b2,b2,b2,b2,bt,fr,fs,fu,b2,fx,b2,bt,bt,bt,bt
b9,ci,bh,ci,b9,b2,fq,ft,fv,b2,fw,bh,b9,bh,b9,bh
bk,bk,bj,bk,bj,bi,bj,bi,bk,g5,bk,bk,bj,bk,bj,bi
0,0,0,45,0,0,0,0,45,0,0,0,0,0,45,0
0,0,0,0,0,45,0,0,0,0,45,0,0,0,0,0
NAME bad end
END 3 9,11
END 4 8,12
END 5 10,12
END 6 9,13
PAL 0

ROOM 15
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
p,p,p,p,p,p,g0,p,p,p,p,p,p,p,g2,p
0,0,0,0,0,fy,fz,0,0,7c,79,0,0,0,g1,0
23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23
0,2h,0,0,0,0,2h,0,0,0,0,0,0,0,2h,0
0,0,0,2h,0,0,0,0,0,0,2h,0,0,0,0,0
0,0,0,0,0,0,0,0,2h,0,0,0,0,0,0,0
NAME letter
ITM f 8,11
EXT 14,11 16 8,10 FX tunnel
PAL 0

ROOM 16
0,0,0,0,0,0,aj,aa,ab,ai,0,0,0,0,0,0
0,0,1n,0,0,1p,0,ak,al,0,1p,0,0,0,1n,0
0,0,0,0,0,9l,9m,9m,9m,9m,9n,0,0,0,0,0
0,9q,9r,9s,0,9k,9k,9k,9k,9k,9k,9o,9q,9r,9s,0
1p,9u,a1,9z,1p,9k,9k,9k,9k,9k,9k,1p,9u,a3,9z,1p
1n,9u,a0,9z,ag,9k,9k,9k,9k,9k,9k,9o,9u,a0,9z,1n
0,9u,a1,9z,a5,9k,9k,9k,9k,9k,9k,9p,9u,a3,9z,0
0,9u,a0,9z,a5,9j,9j,9j,9j,9j,9j,9o,9u,a0,9z,0
0,9v,9w,9x,a5,15,0,0,0,0,12,0,9v,9w,9x,0
p,1n,p,p,a5,g4,p,p,p,p,g3,p,p,p,1n,p
0,0,0,ah,a4,15,0,0,0,0,12,0,am,0,0,0
b,b,f,b,b,1q,b,b,b,1q,1q,b,b,1r,b,b
0,0,e,f,b,c,c,f,f,b,c,b,f,e,0,0
0,0,0,e,f,b,f,e,e,f,b,f,e,0,0,0
0,0,0,0,e,f,e,0,0,e,f,e,0,0,0,0
0,0,0,0,0,e,0,0,0,0,e,0,0,0,0,0
NAME get stuck
PAL 0

ROOM a
31,31,31,31,31,31,31,34,34,31,31,31,31,31,31,31
34,8m,8n,8n,8n,8n,8n,91,92,8n,8n,8n,8n,8n,8o,34
8l,0,8u,8u,8u,8u,8u,8u,90,8u,8u,8u,8u,8u,8u,8p
8j,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8q
8j,0,0,0,0,0,0,90,0,0,0,0,0,0,0,8q
8j,0,0,0,0,0,0,0,0,2h,0,0,0,0,0,8q
8j,8e,8d,8f,p,p,0,0,90,0,0,0,8e,8d,8f,8q
8j,0,8g,8x,8y,8z,90,0,0,0,0,0,0,8g,0,8q
8j,0,8h,8w,p,p,0,0,90,0,0,0,0,8h,0,8q
8j,p,8h,8w,p,90,2k,2l,p,p,90,p,p,8h,p,8q
8s,7z,8i,81,88,88,2i,2j,88,88,88,8c,80,8i,7z,8t
p,p,8a,82,2h,0,0,0,2h,0,0,2h,86,84,p,p
0,0,8a,82,0,0,2h,0,0,0,2h,0,86,84,84,0
0,8a,8a,82,2h,95,94,2h,0,0,0,2h,86,84,0,0
0,0,8a,83,0,1d,1e,0,8v,2h,0,0,85,84,0,0
0,0,0,0,8b,8b,8b,8b,8b,8b,8b,8b,0,0,0,0
NAME Pool
EXT 8,14 c 1,13 FX wave
EXT 5,14 e 12,4 FX tunnel
PAL 0

ROOM c
96,97,96,97,97,96,97,97,97,97,97,96,97,97,97,97
96,96,96,97,96,96,97,96,96,96,96,96,96,96,96,96
96,97,96,97,96,96,96,96,97,96,97,96,97,97,97,96
96,97,97,96,96,97,97,97,97,96,97,96,97,96,96,96
96,96,96,96,97,97,96,96,97,97,97,96,97,96,97,97
96,97,96,97,97,97,96,97,97,96,96,96,97,97,96,96
97,97,97,97,96,96,96,96,96,96,97,96,96,96,96,96
97,96,96,97,96,97,96,96,97,96,96,96,96,97,97,96
97,96,97,97,96,97,96,97,97,97,97,97,97,97,96,96
97,96,96,97,96,96,96,96,97,97,96,96,96,96,96,97
97,97,96,97,97,97,97,97,97,96,96,97,97,97,96,97
96,96,96,96,96,97,96,96,96,97,97,96,96,97,96,97
97,97,96,97,97,97,96,97,96,96,97,97,96,97,96,97
96,96,96,96,96,96,96,96,97,96,96,97,96,97,96,97
96,96,97,97,96,97,97,97,97,96,97,97,96,97,96,97
99,96,96,97,96,96,96,96,97,96,96,96,96,96,96,97
NAME Bag
ITM 2 2,2
EXT 0,15 d 0,15 FX wave
EXT 2,0 a 7,14 FX wave
PAL 2

ROOM d
0,97,0,97,97,0,97,97,97,97,97,0,97,97,97,97
0,0,0,97,0,0,97,0,0,0,0,0,0,0,0,0
0,97,9a,97,0,0,0,0,97,0,97,0,97,97,97,0
0,97,97,0,0,97,97,97,97,0,97,0,97,0,0,0
0,0,0,0,97,97,0,0,97,97,97,0,97,0,97,97
0,97,0,97,97,97,0,97,97,0,0,0,97,97,0,0
97,97,97,97,0,0,0,0,0,0,97,0,0,0,0,0
97,0,0,97,0,97,0,0,97,0,0,0,0,97,97,0
97,0,97,97,0,97,0,97,97,97,97,97,97,97,0,0
97,0,0,97,0,0,0,0,97,97,0,0,0,0,0,97
97,97,0,97,97,97,97,97,97,0,0,97,97,97,0,97
0,0,0,0,0,97,0,0,0,97,97,0,0,97,0,97
97,97,0,97,97,97,0,97,0,0,97,97,0,97,0,97
0,0,0,0,0,0,0,0,97,0,0,97,0,97,0,97
p,p,97,97,0,97,97,97,97,0,97,97,0,97,0,97
98,0,0,97,0,0,0,0,97,0,0,0,0,0,0,97
NAME Bag 2
EXT 0,15 c 0,15 FX wave
PAL 1

ROOM e
0,0,x,x,0,w,0,0,1n,x,0,0,w,0,0,1n
0,0,x,x,0,w,0,0,0,t,u,u,v,0,0,0
1n,0,x,x,0,w,0,1n,0,p,p,p,p,p,p,p
0,0,x,t,u,v,0,0,p,0,2a,1p,95,94,1p,o
0,0,x,0,w,0,0,p,0,1t,1v,9h,9i,9f,9g,1v
0,0,t,u,v,0,p,0,1t,1v,c,b,b,b,b,c
0,0,1n,0,0,p,0,1t,1v,c,1s,l,c,1s,9d,h
0,0,0,0,p,0,1t,1v,c,9d,i,h,k,9d,h,i
0,1n,0,p,0,1t,1v,1s,c,9d,h,g,j,c,1s,h
p,p,p,0,1t,1v,b,b,b,b,9c,h,g,b,b1,0
0,0,0,1t,9b,c,c,16,17,c,16,17,c,16,17,1h
1q,b,f,1q,1r,b,1q,1r,1q,b,1q,1r,f,1r,1q,b
f,f,e,0,0,c,f,e,0,c,f,e,f,e,f,c
e,f,0,0,0,f,e,0,0,f,e,0,e,0,e,f
0,e,0,0,0,e,0,0,0,e,0,0,0,0,0,e
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME Great Hall - East Cut
EXT 12,4 a 5,14 FX tunnel
EXT 0,10 f 15,10 FX slide_l
EXT 15,3 g 0,3 FX slide_r
EXT 15,10 g 0,10 FX slide_r
PAL 0

ROOM f
0,0,0,0,0,0,aj,aa,ab,ai,0,0,0,0,0,0
0,0,1n,0,0,1p,0,ak,al,0,1p,0,0,0,1n,0
0,0,0,0,0,0,0,ae,af,0,0,0,0,0,0,0
0,9q,9r,9s,0,0,1n,a7,a6,0,0,0,9q,9r,9s,0
1p,9u,a1,9z,1p,0,0,0,0,1n,0,1p,9u,a3,9z,1p
1n,9u,a0,9z,ag,9l,9m,9m,9m,9m,9n,0,9u,a0,9z,1n
0,9u,a1,9z,a5,9k,9k,9k,9k,9k,9k,9p,9u,a3,9z,0
0,9u,a0,9z,a5,9k,9k,9k,9k,9k,9k,9o,9u,a0,9z,0
0,9v,9w,9x,a5,9k,9k,9k,9k,9k,9k,9o,9v,9w,9x,0
p,1n,p,p,a5,9k,9k,9k,9k,9k,9k,9o,0,p,1n,p
0,0,0,ah,a4,9j,9j,9j,9j,9j,9j,9p,am,0,0,0
b,b,f,b,b,1q,b,b,b,1q,1q,b,b,1r,b,b
0,0,e,f,b,c,c,f,f,b,c,b,f,e,0,0
0,0,0,e,f,b,f,e,e,f,b,f,e,0,0,0
0,0,0,0,e,f,e,0,0,e,f,e,0,0,0,0
0,0,0,0,0,e,0,0,0,0,e,0,0,0,0,0
NAME Great Hall
EXT 15,10 e 0,10 FX slide_r
EXT 0,10 0 15,10 FX slide_l
PAL 0

ROOM g
0,0,0,0,0,1n,at,ao,b2,b2,b2,b2,b2,b2,b2,b2
0,1n,0,0,0,0,at,ao,b2,b2,b2,b2,b2,b2,b2,b2
p,p,p,0,0,0,at,ao,b2,b2,b2,b2,b2,b2,b2,b2
o,2a,0,br,bs,0,2a,ax,b2,b2,b2,b2,b2,b2,b2,b2
b,1q,1q,f,f,av,aw,4s,b2,b2,b2,b2,b2,b2,b2,b2
b,h,i,i,0,0,3w,3q,b2,b2,b2,b2,b2,b2,b2,b2
i,0,0,0,0,1n,3w,3q,b2,b2,b2,b2,b2,b2,b2,b2
0,0,0,0,0,0,3w,3q,b2,b2,b2,b2,b2,b2,b2,b2
0,0,1n,0,0,0,3w,3q,b2,b2,b2,b2,bg,bf,be,b2
ap,p,p,bm,p,0,3w,3q,b2,b2,b3,b3,b3,8g,b3,b3
1h,b0,0,bl,0,1n,bo,bn,b2,b2,c3,c0,c0,8h,c0,c0
1q,b,b,q,a,0,bq,bp,bt,bt,c4,c5,c5,8h,c5,c5
0,f,b,h,q,a,az,ay,bh,bh,c2,c1,c1,b4,c1,c1
0,e,f,0,an,an,bi,bj,bi,bi,bk,bj,ba,bb,bd,bj
0,0,e,0,0,0,0,0,4w,0,0,0,0,4w,0,0
0,0,0,0,0,0,0,0,0,0,0,4w,0,0,0,0
NAME Courtyard West
EXT 0,3 e 15,3 FX slide_l
EXT 0,10 e 15,10 FX slide_l
EXT 15,12 h 0,12 FX slide_r
PAL 0

ROOM h
b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
b2,b2,b2,b2,b2,b2,b2,bt,bt,bt,b2,b2,b2,b2,b2,b2
b2,b2,b2,b2,b2,b2,bt,ca,c9,b2,bt,b2,b2,b2,b2,b2
b2,b2,b2,b2,b2,b2,cd,cb,c8,c7,bt,b2,b2,b2,b2,b2
b2,b2,b2,b2,b2,b2,cc,by,bz,c6,b2,b2,b2,b2,b2,b2
b2,b2,b2,b2,b2,b2,b2,bx,bw,b2,b2,b2,b2,b2,b2,b2
b2,b2,bg,bf,be,b2,b2,bx,bw,b2,b2,bg,bf,be,b2,b2
b2,b2,b2,8g,b2,b2,b2,bx,bw,bt,bt,bt,8g,b2,b2,b2
b3,b3,b3,8h,b3,b3,b3,bx,bw,b3,b3,b3,8h,b3,b3,b3
c0,c0,c0,8h,c0,c0,c0,bx,bw,c0,cf,cg,8h,c0,c0,c0
c5,c5,c5,8h,c5,c5,c5,bx,bw,c5,ce,c5,8h,c5,c5,c5
c1,c1,c1,b4,c1,c1,c1,bu,bv,c1,ce,c1,b4,c1,c1,c1
bj,bj,ba,bb,bd,bk,ba,bb,bb,bd,bk,ba,bb,bd,bj,bk
0,0,0,0,0,45,0,0,45,0,0,0,0,0,45,0
0,0,45,0,0,0,0,0,0,0,45,0,0,45,0,0
NAME Courtyard
ITM d 8,3
EXT 0,12 g 15,12 FX slide_l
EXT 15,12 i 0,12 FX slide_r
EXT 9,3 h 10,9 FX tunnel
PAL 0

ROOM i
bt,bt,bt,bt,bt,bt,bt,bt,3w,3x,0,0,0,0,0,0
b2,b2,b2,b2,b2,b2,b2,b2,3w,0,73,0,73,0,73,0
b2,b2,b2,b2,b2,b2,b2,b2,3w,3x,0,0,0,1n,0,0
b2,b2,b2,b2,b2,b2,b2,b2,3w,0,0,0,0,0,0,0
b2,b2,b2,b2,b2,b2,b2,b2,3w,3x,1n,0,0,0,0,1n
b2,b2,b2,b2,b2,b2,b2,b2,3w,0,0,0,0,0,0,0
b2,b2,b2,b2,b2,b2,b2,b2,3w,3x,0,0,1n,0,0,0
b2,b2,b2,b2,b2,b2,b2,b2,3w,0,0,0,0,0,1n,0
b2,bg,bf,be,b2,b2,b2,b2,3w,3x,0,0,0,0,0,0
b3,b3,8g,b3,b3,b3,b3,b3,3w,0,1n,0,0,0,0,0
c0,c0,8h,c0,c0,c0,c0,c0,3w,3x,0,p,1g,1f,1n,0
c5,c5,8h,c5,c5,c5,c5,c5,3w,p,p,0,1d,1e,p,0
c1,c1,b4,c1,c1,c1,c1,c1,78,3x,0,ch,2r,14,15,0
bk,ba,bb,bd,bj,bi,bk,bi,bj,bj,bi,bk,bj,bi,bi,bj
0,0,0,0,0,0,45,0,0,0,0,45,0,0,0,0
0,0,45,0,0,0,0,0,0,45,0,0,0,45,0,0
NAME Courtyard East
EXT 0,12 h 15,12 FX slide_l
EXT 15,12 j 0,12 FX slide_r
EXT 12,11 k 4,13 FX tunnel
PAL 0

ROOM j
1n,0,0,3r,3q,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
0,0,0,0,3q,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
0,0,0,3r,3q,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
0,0,1n,0,3q,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
0,0,0,3r,3q,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
0,0,0,0,3q,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
0,1n,0,3r,3q,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
0,0,0,0,3q,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
0,0,0,3r,3q,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
0,1n,0,0,3q,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
0,0,0,3r,3q,b2,b2,b2,b2,b2,b2,ci,b2,b2,b2,b2
p,p,p,p,3q,bt,bt,bt,bt,bt,bt,cj,bt,bt,bt,bt
0,0,0,3r,cm,b9,b9,cl,b9,cl,b9,cj,b9,cl,b9,bh
bk,bk,bj,bk,bj,bi,bj,bi,bk,bi,bk,bk,bj,bk,bj,bi
0,0,0,45,0,0,0,0,45,0,0,0,0,0,45,0
0,0,0,0,0,45,0,0,0,0,45,0,0,0,0,0
NAME Graves
EXT 0,12 i 15,12 FX slide_l
PAL 0

ROOM k
0,1o,1g,1f,1o,p,p,p,p,p,p,p,p,p,p,0
0,p,1d,1e,0,0,0,0,0,0,0,0,4r,0,0,p
0,0,f,q,27,23,23,23,23,23,23,4d,41,4c,4d,0
0,0,g,j,q,cn,p,p,0,1n,0,1n,41,p,0,0
0,0,0,h,k,co,cp,0,p,0,0,p,41,p,1n,0
0,0,0,0,b,0,0,cp,0,p,0,p,41,p,0,0
0,0,1n,0,f,0,0,cq,a,0,p,p,41,p,0,0
0,0,0,0,e,0,0,0,q,a,o,o,42,0,p,0
0,1n,0,0,0,0,0,0,f,p,20,21,1v,1s,0,0
0,0,0,0,0,0,0,0,1u,0,1t,1v,h,j,0,0
0,0,0,0,1n,0,0,p,0,1t,1v,b,0,i,0,0
0,0,0,0,p,p,p,0,1t,1v,f,f,0,0,0,0
0,0,0,1o,1g,1f,1p,1t,1v,f,e,f,0,0,0,0
1n,0,p,0,1d,1e,1t,1v,e,e,0,e,0,0,0,0
0,0,0,22,1s,1s,b,f,0,0,0,0,0,1n,0,0
0,0,0,0,1c,b,1h,i,0,0,0,0,0,0,0,0
NAME East Parapet Staircase
EXT 4,13 i 12,11 FX tunnel
EXT 2,1 l 12,11 FX tunnel
PAL 0

ROOM l
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
7x,7w,7w,7w,7w,7w,7w,7w,7w,7y,0,0,0,0,0,0
7x,0,0,y,14,14,10,0,0,7y,0,0,0,0,0,0
7x,0,0,15,3e,3f,12,0,0,7y,0,0,0,0,0,0
7x,0,1o,15,0,0,12,1o,0,7y,0,0,0,0,0,0
7x,0,0,15,3e,3g,12,0,0,7y,0,0,0,0,0,0
7x,0,0,z,13,13,11,0,0,7v,7v,7v,7v,7v,7v,7y
7x,p,p,7i,1g,1f,7i,p,p,p,p,1o,1g,1f,1o,7y
7x,0,0,7h,1d,1e,7h,0,0,0,0,0,1d,1e,0,7y
7v,7v,7v,7v,7v,7v,7v,7v,7v,7v,7v,7v,7v,7v,7v,7v
0,0,0,0,0,0,0,0,0,cr,0,cr,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,cr,0,cr,0,0,0,0
NAME Queen's Suite
EXT 12,11 k 2,1 FX tunnel
EXT 10,11 m 13,8 FX wave
PAL 0

ROOM m
0,0,0,0,0,0,3r,3q,41,3w,0,3s,cw,3t,3t,3v
0,0,3u,45,0,3u,0,3q,41,3z,cx,40,0,1o,45,3w
0,3s,3t,3t,3t,cw,3t,40,41,0,d0,0,cz,d2,0,3w
3r,3q,4r,0,0,cz,0,0,42,4t,3y,3y,3y,3y,3y,52
0,3q,41,4t,3y,3y,3y,3y,3y,52,3s,3t,cw,3t,3t,3v
3t,40,41,3z,3t,cw,3t,cw,3t,3t,40,0,0,0,0,3z
45,p,41,p,0,0,45,0,0,0,0,0,0,45,1p,0
p,p,41,p,73,0,73,0,73,45,p,1o,p,p,p,p
0,0,41,p,p,p,p,p,p,p,0,0,cz,0,0,0
3y,cs,42,0,0,cz,0,cz,4r,0,ch,3y,3y,3y,3y,3y
0,p,3y,3y,3y,3y,3y,4s,41,4t,p,45,0,3u,0,0
3s,3t,cw,3t,3t,3t,cx,40,41,3w,0,3s,3t,cw,3t,3v
3q,0,0,0,0,d1,cy,0,41,3z,cx,40,0,45,0,3w
3q,1p,0,0,ch,ct,3y,4s,41,0,cy,0,0,0,1p,3w
3q,0,cz,ch,ct,52,0,3q,41,4t,3y,cu,cs,cz,d2,3w
53,3y,3y,3y,52,0,0,3q,41,3w,0,53,3y,3y,3y,52
NAME Dungeon I
ITM 3 14,2
EXT 8,0 n 8,15 FX slide_u
EXT 0,8 w 9,10
EXT 15,8 w 9,10 FX wave
EXT 8,15 w 9,10 FX wave
PAL 0

ROOM n
0,0,0,0,0,0,3r,3q,41,3w,0,3s,cw,3t,3t,3v
0,0,3u,45,0,3u,0,3q,41,3z,cx,40,0,1o,45,3w
0,3s,3t,3t,3t,cw,3t,40,41,0,d0,0,cz,d2,0,3w
3r,3q,4r,0,0,cz,0,0,42,4t,3y,3y,3y,3y,3y,52
0,3q,41,4t,3y,3y,3y,3y,3y,52,3s,3t,cw,3t,3t,3v
3t,40,41,3z,3t,cw,3t,cw,3t,3t,40,0,0,0,0,3z
45,p,41,p,0,0,45,0,0,0,0,0,0,45,1p,0
p,p,41,p,73,0,73,0,73,45,p,1o,p,p,p,p
0,0,41,p,p,p,p,p,p,p,0,0,cz,0,0,0
3y,cs,42,0,0,cz,0,cz,4r,0,ch,3y,3y,3y,3y,3y
0,p,3y,3y,3y,3y,3y,4s,41,4t,p,45,0,3u,0,0
3s,3t,cw,3t,3t,3t,cx,40,41,3w,0,3s,3t,cw,3t,3v
3q,0,0,0,0,d1,cy,0,41,3z,cx,40,0,45,0,3w
3q,1p,0,0,ch,ct,3y,4s,41,0,cy,0,0,0,1p,3w
3q,0,cz,ch,ct,52,0,3q,41,4t,3y,cu,cs,cz,d2,3w
53,3y,3y,3y,52,0,0,3q,41,3w,0,53,3y,3y,3y,52
NAME Dungeon II
EXT 0,8 o 15,8 FX slide_l
EXT 8,0 w 9,10 FX wave
EXT 15,8 w 9,10 FX wave
EXT 8,15 w 9,10 FX wave
PAL 0

ROOM o
0,0,0,0,0,0,3r,3q,41,3w,0,3s,cw,3t,3t,3v
0,0,3u,45,0,3u,0,3q,41,3z,cx,40,0,1o,45,3w
0,3s,3t,3t,3t,cw,3t,40,41,0,d0,0,cz,d2,0,3w
3r,3q,4r,0,0,cz,0,0,42,4t,3y,3y,3y,3y,3y,52
0,3q,41,4t,3y,3y,3y,3y,3y,52,3s,3t,cw,3t,3t,3v
3t,40,41,3z,3t,cw,3t,cw,3t,3t,40,0,0,0,0,3z
45,p,41,p,0,0,45,0,0,0,0,0,0,45,1p,0
p,p,41,p,73,0,73,0,73,45,p,1o,p,p,p,p
0,0,41,p,p,p,p,p,p,p,0,0,cz,0,0,0
3y,cs,42,0,0,cz,0,cz,4r,0,ch,3y,3y,3y,3y,3y
0,p,3y,3y,3y,3y,3y,4s,41,4t,p,45,0,3u,0,0
3s,3t,cw,3t,3t,3t,cx,40,41,3w,0,3s,3t,cw,3t,3v
3q,0,0,0,0,d1,cy,0,41,3z,cx,40,0,45,0,3w
3q,1p,0,0,ch,ct,3y,4s,41,0,cy,0,0,0,1p,3w
3q,0,cz,ch,ct,52,0,3q,41,4t,3y,cu,cs,cz,d2,3w
53,3y,3y,3y,52,0,0,3q,41,3w,0,53,3y,3y,3y,52
NAME Dungeon III
EXT 0,8 p 15,8 FX slide_l
EXT 15,8 w 9,10 FX wave
EXT 8,0 w 9,10 FX wave
EXT 8,15 w 9,10 FX wave
PAL 0

ROOM p
0,0,0,0,0,0,3r,3q,41,3w,0,3s,cw,3t,3t,3v
0,0,3u,45,0,3u,0,3q,41,3z,cx,40,0,1o,45,3w
0,3s,3t,3t,3t,cw,3t,40,41,0,d0,0,cz,d2,0,3w
3r,3q,4r,0,0,cz,0,0,42,4t,3y,3y,3y,3y,3y,52
0,3q,41,4t,3y,3y,3y,3y,3y,52,3s,3t,cw,3t,3t,3v
3t,40,41,3z,3t,cw,3t,cw,3t,3t,40,0,0,0,0,3z
45,p,41,p,0,0,45,0,0,0,0,0,0,45,1p,0
p,p,41,p,73,0,73,0,73,45,p,1o,p,p,p,p
0,0,41,p,p,p,p,p,p,p,0,0,cz,0,0,0
3y,cs,42,0,0,cz,0,cz,4r,0,ch,3y,3y,3y,3y,3y
0,p,3y,3y,3y,3y,3y,4s,41,4t,p,45,0,3u,0,0
3s,3t,cw,3t,3t,3t,cx,40,41,3w,0,3s,3t,cw,3t,3v
3q,0,0,0,0,d1,cy,0,41,3z,cx,40,0,45,0,3w
3q,1p,0,0,ch,ct,3y,4s,41,0,cy,0,0,0,1p,3w
3q,0,cz,ch,ct,52,0,3q,41,4t,3y,cu,cs,cz,d2,3w
53,3y,3y,3y,52,0,0,3q,41,3w,0,53,3y,3y,3y,52
NAME Dungeon IV
EXT 8,15 q 8,0 FX slide_d
EXT 15,8 w 9,10 FX wave
EXT 8,0 w 9,10 FX wave
EXT 0,8 w 9,10 FX wave
PAL 0

ROOM q
0,0,0,0,0,0,3r,3q,41,3w,0,3s,cw,3t,3t,3v
0,0,3u,45,0,3u,0,3q,41,3z,cx,40,0,1o,45,3w
0,3s,3t,3t,3t,cw,3t,40,41,0,d0,0,cz,d2,0,3w
3r,3q,4r,0,0,cz,0,0,42,4t,3y,3y,3y,3y,3y,52
0,3q,41,4t,3y,3y,3y,3y,3y,52,3s,3t,cw,3t,3t,3v
3t,40,41,3z,3t,cw,3t,cw,3t,3t,40,0,0,0,0,3z
45,p,41,p,0,0,45,0,0,0,0,0,0,45,1p,0
p,p,41,p,73,0,73,0,73,45,p,1o,p,p,p,p
0,0,41,p,p,p,p,p,p,p,0,0,cz,0,0,0
3y,cs,42,0,0,cz,0,cz,4r,0,ch,3y,d9,3y,3y,3y
0,p,3y,3y,3y,3y,3y,4s,41,4t,p,p,0,p,0,0
3s,3t,cw,3t,3t,3t,cx,40,41,3w,0,3s,3t,cw,3t,3v
3q,0,0,0,0,d1,cy,0,41,3z,cx,40,0,45,0,3w
3q,1p,0,0,ch,ct,3y,4s,41,0,cy,0,0,0,1p,3w
3q,0,cz,ch,ct,52,0,3q,41,4t,3y,cu,cs,cz,d2,3w
53,3y,3y,3y,52,0,0,3q,41,3w,0,53,3y,3y,3y,52
NAME Dungeon V
ITM 4 12,10
EXT 15,8 r 0,8 FX slide_r
EXT 8,0 w 9,10 FX wave
EXT 8,15 w 9,10 FX wave
EXT 0,8 w 9,10 FX wave
PAL 0

ROOM r
0,0,0,0,0,0,3r,3q,41,3w,0,3s,cw,3t,3t,3v
0,0,3u,45,0,3u,0,3q,41,3z,cx,40,0,1o,45,3w
0,3s,3t,3t,3t,cw,3t,40,41,0,d0,0,cz,d2,0,3w
3r,3q,4r,0,0,cz,0,0,42,4t,3y,3y,3y,3y,3y,52
0,3q,41,4t,3y,3y,3y,3y,3y,52,3s,3t,cw,3t,3t,3v
3t,40,41,3z,3t,cw,3t,cw,3t,3t,40,0,0,0,0,3z
45,p,41,p,0,0,45,0,0,0,0,0,0,45,1p,0
p,p,41,p,73,0,73,0,73,45,p,1o,p,p,p,p
0,0,41,p,p,p,p,p,p,p,0,0,cz,0,0,0
3y,cs,42,0,0,cz,0,cz,4r,0,ch,3y,3y,3y,3y,3y
0,p,3y,3y,3y,3y,3y,4s,41,4t,p,45,0,3u,0,0
3s,3t,cw,3t,3t,3t,cx,40,41,3w,0,3s,3t,cw,3t,3v
3q,0,0,0,0,d1,cy,0,41,3z,cx,40,0,45,0,3w
3q,1p,0,0,ch,ct,3y,4s,41,0,cy,0,0,0,1p,3w
3q,0,cz,ch,ct,52,0,3q,41,4t,3y,cu,cs,cz,d2,3w
53,3y,3y,3y,52,0,0,3q,41,3w,0,53,3y,3y,3y,52
NAME Dungeon VI
EXT 0,8 s 15,8 FX slide_l
EXT 8,0 w 9,10
EXT 15,8 w 9,10 FX wave
EXT 8,15 w 9,10 FX wave
PAL 0

ROOM s
0,0,0,0,0,0,3r,3q,41,3w,0,3s,cw,3t,3t,3v
0,0,3u,45,0,3u,0,3q,41,3z,cx,40,0,1o,45,3w
0,3s,3t,3t,3t,cw,3t,40,41,0,d0,0,cz,d2,0,3w
3r,3q,4r,0,0,cz,0,0,42,4t,3y,3y,3y,3y,3y,52
0,3q,41,4t,3y,3y,3y,3y,3y,52,3s,3t,cw,3t,3t,3v
3t,40,41,3z,3t,cw,3t,cw,3t,3t,40,0,0,0,0,3z
45,p,41,p,0,0,45,0,0,0,0,0,0,45,1p,0
p,p,41,p,73,0,73,0,73,45,p,1o,p,p,p,p
0,0,41,p,p,p,p,p,p,p,0,0,cz,0,0,0
3y,cs,42,0,0,cz,0,cz,4r,0,ch,3y,3y,3y,3y,3y
0,p,3y,3y,3y,3y,3y,4s,41,4t,p,45,0,3u,0,0
3s,3t,cw,3t,3t,3t,cx,40,41,3w,0,3s,3t,cw,3t,3v
3q,0,0,0,0,d1,cy,0,41,3z,cx,40,0,45,0,3w
3q,1p,0,0,ch,ct,3y,4s,41,0,cy,0,0,0,1p,3w
3q,0,cz,ch,ct,52,0,3q,41,4t,3y,cu,cs,cz,d2,3w
53,3y,3y,3y,52,0,0,3q,41,3w,0,53,3y,3y,3y,52
NAME Dungeon VII
ITM 5 4,9
EXT 8,0 t 8,15 FX slide_u
EXT 15,8 w 9,10 FX wave
EXT 0,8 w 9,10 FX wave
EXT 8,15 w 9,10 FX wave
PAL 0

ROOM t
0,0,0,0,0,0,3r,3q,41,3w,0,3s,cw,3t,3t,3v
0,0,3u,45,0,3u,0,3q,41,3z,cx,40,0,1o,45,3w
0,3s,3t,3t,3t,cw,3t,40,41,0,d0,0,cz,d2,0,3w
3r,3q,4r,0,0,cz,0,0,42,4t,3y,3y,3y,3y,3y,52
0,3q,41,4t,3y,3y,3y,3y,3y,52,3s,3t,cw,3t,3t,3v
3t,40,41,3z,3t,cw,3t,cw,3t,3t,40,0,0,0,0,3z
45,p,41,p,0,0,45,0,0,0,0,0,0,45,1p,0
p,p,41,p,73,0,73,0,73,45,p,1o,p,p,p,p
0,0,41,p,p,p,p,p,p,p,0,0,cz,0,0,0
3y,cs,42,0,0,cz,0,cz,4r,0,ch,3y,3y,3y,3y,3y
0,p,3y,3y,3y,3y,3y,4s,41,4t,p,45,0,3u,0,0
3s,3t,cw,3t,3t,3t,cx,40,41,3w,0,3s,3t,cw,3t,3v
3q,0,0,0,0,d1,cy,0,41,3z,cx,40,0,45,0,3w
3q,1p,0,0,ch,ct,3y,4s,41,0,cy,0,0,0,1p,3w
3q,0,cz,ch,ct,52,0,3q,41,4t,3y,cu,cs,cz,d2,3w
53,3y,3y,3y,52,0,0,3q,41,3w,0,53,3y,3y,3y,52
NAME Dungeon VIII
EXT 8,15 u 8,0 FX slide_d
EXT 0,8 w 9,10 FX wave
EXT 8,0 w 9,10 FX wave
EXT 15,8 w 9,10 FX wave
PAL 0

ROOM u
0,0,0,0,0,0,3r,3q,41,3w,0,3s,cw,3t,3t,3v
0,0,3u,45,0,3u,0,3q,41,3z,cx,40,0,1o,45,3w
0,3s,3t,3t,3t,cw,3t,40,41,0,d0,0,cz,d2,0,3w
3r,3q,4r,0,0,cz,0,0,42,4t,3y,3y,3y,3y,3y,52
0,3q,41,4t,3y,3y,3y,3y,3y,52,3s,3t,cw,3t,3t,3v
3t,40,41,3z,3t,cw,3t,cw,3t,3t,40,0,0,0,0,3z
45,p,41,p,0,0,45,0,0,0,0,0,0,45,1p,0
p,p,41,p,73,0,73,0,73,45,p,1o,p,p,p,p
0,0,41,p,p,p,p,p,p,p,0,0,cz,0,0,0
3y,cs,42,0,0,cz,0,cz,4r,0,ch,3y,3y,3y,3y,3y
0,p,3y,3y,3y,3y,3y,4s,41,4t,p,45,0,3u,0,0
3s,3t,cw,3t,3t,3t,cx,40,41,3w,0,3s,3t,cw,3t,3v
3q,0,0,0,0,d1,cy,0,41,3z,cx,40,0,45,0,3w
3q,1p,0,0,ch,ct,3y,4s,41,0,cy,0,0,0,1p,3w
3q,0,cz,ch,ct,52,0,3q,41,4t,3y,cu,cs,cz,d2,3w
53,3y,3y,3y,52,0,0,3q,41,3w,0,53,3y,3y,3y,52
NAME Dungeon IX
EXT 15,8 v 0,8 FX slide_r
EXT 8,0 w 9,10 FX wave
EXT 0,8 w 9,10 FX wave
EXT 8,15 w 9,10 FX wave
PAL 0

ROOM v
0,0,0,0,0,0,3r,3q,41,3w,0,3s,cw,3t,3t,3v
0,0,3u,45,0,3u,0,3q,41,3z,cx,40,0,1o,45,3w
0,3s,3t,3t,3t,cw,3t,40,41,0,d0,0,cz,d2,0,3w
3r,3q,4r,0,0,cz,0,0,42,4t,3y,3y,3y,3y,3y,52
0,3q,41,4t,3y,3y,3y,3y,3y,52,3s,3t,cw,3t,3t,3v
3t,40,41,3z,3t,cw,3t,cw,3t,3t,40,0,0,0,0,3z
45,p,41,p,0,0,45,0,0,0,0,0,0,45,1p,0
p,p,41,p,73,0,73,0,73,45,p,1o,p,p,p,p
0,0,41,p,p,p,p,p,p,p,0,0,cz,0,0,0
3y,cs,42,0,0,cz,0,cz,4r,0,ch,3y,3y,3y,3y,3y
0,p,3y,3y,3y,3y,3y,4s,41,4t,p,45,0,3u,0,0
3s,3t,cw,3t,3t,3t,cx,40,41,3w,0,3s,3t,cw,3t,3v
3q,0,0,0,0,d1,cy,0,41,3z,cx,40,0,45,0,3w
3q,1p,0,0,ch,ct,3y,4s,41,0,cy,0,0,0,1p,3w
3q,0,cz,ch,ct,52,0,3q,41,4t,3y,cu,cs,cz,d2,3w
53,3y,3y,3y,52,0,0,3q,41,3w,0,53,3y,3y,3y,52
NAME Dungeon X
EXT 0,8 w 9,10 FX wave
EXT 15,8 w 9,10 FX wave
EXT 8,15 w 9,10 FX wave
EXT 8,0 x 8,11 FX wave
PAL 0

ROOM w
0,5x,5w,0,0,0,0,0,5x,5w,5w,0,0,5w,5x,0
0,0,0,0,0,3u,0,3u,3s,d8,3v,0,45,0,0,0
0,0,0,0,3s,3t,3t,3t,40,41,3w,3x,0,0,0,0
0,0,0,3r,3q,4r,0,0,0,41,3w,45,0,0,0,0
0,0,45,0,3q,41,4t,3y,3y,3y,52,0,0,0,0,45
0,0,d3,0,3q,41,3w,3x,0,0,0,0,0,0,d3,0
0,0,0,0,3q,41,3w,0,0,0,0,0,0,0,0,0
0,0,0,3r,3q,41,3z,cw,3t,3t,3t,3t,3v,0,0,0
0,0,0,0,3q,41,p,0,0,0,0,0,3w,0,0,0
0,0,0,3r,3q,41,p,p,d5,p,p,d5,3w,3x,0,0
0,0,0,0,3q,42,0,cz,d4,d6,d7,d4,3w,0,0,0
0,45,0,0,53,3y,3y,3y,3y,3y,3y,3y,52,0,0,45
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,45,0,0,0,0,0,0,0,0,d3,0,0
0,0,d3,0,0,0,0,0,45,0,0,45,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME tomb
EXT 9,2 j 9,12 FX slide_u
PAL 0

ROOM x
b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
b2,b3,b3,b3,b3,b3,b3,b3,b3,b3,b2,b2,b2,b2,b2,b2
b2,6s,6t,6t,6t,6t,6t,6t,6t,6u,b2,b2,b2,b2,b2,b2
b2,3w,0,1n,0,0,0,0,0,3q,b2,b2,b2,b2,b2,b2
b2,3w,3x,0,0,0,1n,0,3r,3q,b2,b2,b2,b2,b2,b2
b2,3w,0,0,0,0,0,0,0,3q,b2,b2,b2,b2,b2,b2
b2,3w,0,1n,0,0,0,0,3r,3q,b2,b2,b2,b2,b2,b2
b2,3w,3x,0,0,0,0,0,0,3q,b2,b2,b2,b2,b2,b2
bt,3w,p,1o,1g,1f,1o,1n,p,3q,bt,bt,bt,bt,bt,bt
b3,78,6v,6v,1d,1e,6v,6v,6v,cm,bh,bh,bh,da,b3,bt
4t,5a,5a,7p,2r,2q,7r,5a,5a,5a,5a,5a,5a,5a,4s,bt
78,0,0,7q,23,23,7s,cr,0,cr,0,0,1n,0,3q,bt
78,0,0,1n,0,0,0,cr,0,cr,0,0,0,0,3q,bt
78,0,0,0,cr,0,0,cr,0,cr,0,0,0,0,3q,bt
NAME East Parapet
ITM 6 2,11
EXT 0,11 y 14,0 FX fade_w
PAL 0

ROOM y
b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3
NAME rain
ITM 7 13,2
ITM 8 9,5
ITM 9 11,7
ITM a 6,13
ITM b 9,9
ITM c 7,10
EXT 0,15 h 7,3 FX fade_w
EXT 1,15 h 7,3 FX fade_w
EXT 2,15 h 7,3 FX fade_w
EXT 3,15 h 7,3 FX fade_w
EXT 4,15 h 7,3 FX fade_w
EXT 5,15 h 7,3 FX fade_w
EXT 6,15 h 7,3 FX fade_w
EXT 7,15 h 7,3 FX fade_w
EXT 8,15 h 7,3 FX fade_w
EXT 9,15 h 7,3 FX fade_w
EXT 10,15 h 7,3 FX fade_w
EXT 11,15 h 7,3 FX fade_w
EXT 12,15 h 7,3 FX fade_w
EXT 13,15 h 7,3 FX fade_w
EXT 15,15 h 7,3 FX fade_w
EXT 14,15 h 7,3 FX fade_w
PAL 0

ROOM z
dn,do,dd,df,dd,0,0,0,0,0,0,dd,df,dd,dv,dx
dg,dg,dd,df,dd,dh,dh,dh,dh,dh,dh,dd,df,dw,0,0
dg,dg,dd,df,dd,dk,dk,dk,dk,dk,dk,dd,df,dd,dr,du
e1,db,dc,df,dc,db,db,db,db,db,db,dc,df,dc,db,db
dd,0,de,dj,de,de,de,de,de,de,de,de,dj,de,de,de
e2,db,dc,df,dc,db,db,db,db,db,db,dc,df,dc,db,db
dh,dm,dd,df,dd,0,0,0,0,0,0,dd,df,dd,di,dh
dh,dm,dd,df,dd,0,0,0,0,0,0,dd,df,dd,di,dh
dh,dm,dd,df,dd,0,0,0,0,0,0,dd,df,dd,di,dh
dh,dm,dd,df,dd,0,0,0,0,0,0,dd,df,dd,di,dh
e1,db,dc,df,dc,db,db,db,db,db,db,dc,df,dc,db,db
dd,0,de,dj,de,de,de,de,de,de,de,de,dj,de,de,de
e2,db,dc,df,dc,db,db,db,db,db,db,dc,df,dc,db,db
45,0,dd,df,dd,dy,dy,dy,0,dy,dy,dd,df,dd,e6,e5
45,45,dd,df,dd,e8,45,0,0,0,e0,dd,df,dd,e3,e4
45,45,dd,df,dd,dz,e7,45,0,45,e0,dd,df,dd,45,0
NAME neighborhood
ITM e 6,0
ITM e 1,6
ITM e 1,1
ITM e 14,1
ITM e 15,15
EXT 14,14 10 1,11 FX tunnel
EXT 15,2 12 12,11 FX tunnel
PAL 3

TIL 10
11111110
00100001
00011101
00000101
00000101
00000011
00000001
00000001

TIL 11
00000001
00000001
10000001
01000010
01000010
00100100
00011000
00000000

TIL 12
00000001
00000001
00000001
00000001
00000001
00000001
00000001
00000001

TIL 13
00000000
00000000
10000001
01000010
01000010
00100100
00011000
00000000

TIL 14
11111111
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL 15
10000000
10000000
10000000
10000000
10000000
10000000
10000000
10000000

TIL 16
11111111
11111111
11111111
11111111
11000000
10111111
11000000
11101111

TIL 17
11111111
11111111
11111111
11111111
00000011
11111101
00000011
11101111

TIL 19
11111111
11111111
11000001
10111110
10100010
10111110
11000010
10111110
WAL true

TIL 20
11111111
00100000
00000000
00000000
00000000
00000000
00000000
00000000

TIL 21
11111110
00000000
00000011
00000001
00001111
00000111
00111111
00011111

TIL 22
00001110
00001101
00110011
00110011
00001101
00001100
00000011
11000011
WAL true

TIL 23
11111111
00000000
00000000
00000000
00000000
00000000
00000000
00000000
WAL true

TIL 24
01011101
01000001
01011110
01000001
01011101
01000001
00111101
01000001
WAL true

TIL 25
00000000
00000000
00111110
01000001
01011101
01000001
00111101
01000001

TIL 27
01111111
00000000
11000000
10000000
11110000
11100000
11111100
11111000

TIL 28
00000000
00000000
00000000
01000100
01111111
01000100
01000100
01000100

TIL 29
00000000
00000000
00000000
01000100
11111100
01000100
01000100
01000100

TIL 30
00000100
00000011
00000100
00000100
00000100
00000010
00000100
00000100

TIL 31
00000000
00001000
00000000
00000010
00000000
00000000
00000000
00100000
>
00010000
00000000
00000100
00000000
00000001
00000000
00000000
00000000

TIL 33
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00100000
>
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL 34
00000000
00001000
00000000
00000010
00000000
00000000
00000000
00000000
>
00010000
00000000
00000100
00000000
00000001
00000000
00000000
00000000
NAME rain

TIL 35
00000000
00000000
00110110
01001001
00110110
01001000
00001000
00000000
>
00000000
00000000
00110110
01001001
00110110
00001000
01001000
00000000

TIL 36
01010101
00000000
00101010
00000000
00010101
00000000
00000000
00000000

TIL 37
01010000
00000000
10100000
00000000
01000000
00000000
00000000
00000000

TIL 38
00001110
00001101
00110011
00110011
00001101
00101100
11000011
00000011
>
00001110
00001101
00110011
00110011
00001101
00001100
11100011
00000011

TIL 39
11111111
11111111
11111111
11111111
11111111
11111111
00111100
00111100
WAL true

TIL 40
00100100
00000100
00000100
00100100
11011000
00000000
00000000
00000000
WAL true

TIL 41
10000001
11111111
10000001
10000001
11000001
11111111
10000001
10000001

TIL 42
10000001
11111111
10000001
10000001
11000001
11111111
10000001
11100111

TIL 43
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000011

TIL 44
00000000
00000000
00000000
00000000
00000000
00000000
00000000
11000000

TIL 45
00000000
00000100
01000000
00000000
00010000
00000000
00000000
00000000
NAME dirt
WAL false

TIL 46
01000000
01101111
01000000
01100000
01001101
00100000
00011111
00001000
WAL true

TIL 47
01001101
00100000
00011111
00001000
00011111
00100000
01001111
01100000
WAL true

TIL 48
00000010
11110110
00000010
00000110
10100010
00000100
11111000
00010000
WAL true

TIL 49
01000010
00000100
11111000
00010000
11111000
00000100
11110010
00000110
WAL true

TIL 50
01111110
00000000
00000000
00000000
00000000
00000000
00000000
00000000
>
00111100
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL 51
00000100
00000000
00010000
00111110
00011100
00001000
00001000
00011100
>
00000000
00010000
00000100
00111110
00011100
00001000
00001000
00011100

TIL 52
11100000
10000000
00000000
00000000
00000000
00000000
00000000
00000000
WAL true

TIL 53
00000011
00000001
00000000
00000000
00000000
00000000
00000000
00000000
WAL true

TIL 57
00100001
00100001
00100001
01111111
00100000
00100000
00101011
00100000

TIL 58
01000100
01000100
01000100
11111110
00000100
00000100
11010100
00000100

TIL 59
00100010
00011100
01111111
11111111
00000000
00000000
01100110
00000000

TIL 60
11111100
11111110
01111110
10010110
11111100
00000000
00000000
00000000
WAL true

TIL 61
00010000
00101000
00010000
11111111
01000000
01000000
01011011
01000000

TIL 62
00000000
00000000
00000000
11111111
00000000
00000000
01100110
00000000

TIL 63
00000000
00000000
00000000
11111111
00000010
00000010
11011010
00000010

TIL 64
01000010
01111110
01000010
01000010
01110010
01000010
01111110
00000000
>
00000010
01111110
01000010
01000010
01110010
01000010
01111110
00000000

TIL 65
01000010
00000000
01000010
00000010
01000000
01000010
01000010
00000000
>
00000000
01000010
00000010
01000000
00000010
01000010
01000000
01000010
WAL true

TIL 66
00010100
00010111
00010111
00011111
00011111
00111111
00111111
00001011

TIL 67
00111100
11111111
11000011
10010001
10010101
10101001
11000011
11111111
>
00111100
11111111
11000011
10001001
10101001
10010101
11000011
11111111

TIL 68
00000000
11000000
11100000
11110000
11111000
11111100
11111100
11010000

TIL 69
00010100
00010100
00010100
00010100
00010100
00010100
00010100
00010100
WAL true

TIL 70
00010000
00011000
00010000
00010010
00010000
11100000
00000000
00100000
>
00010000
00010000
00010100
00010000
00010001
00010000
11100000
00000000

TIL 71
00000000
00000000
00000000
00000000
00000000
00000000
11000111
00111000
>
00000000
00000000
00000000
00000000
00000000
00000000
00111000
11000111

TIL 72
00100100
00100100
00100100
00100100
00100100
00100100
00100111
00100100
>
00100100
00100100
00100100
00100100
00100100
00100100
00100100
00100111

TIL 73
00000000
01111100
10101010
11111110
10101010
11111110
10101010
01111100

TIL 74
00010000
00101000
01111100
00001010
00101000
00101000
00101000
00101000
>
00010000
00101000
01111100
00001000
00101001
00101000
00101000
00101000

TIL 75
00110000
01011000
01110100
01111100
01111100
00111000
00010000
00000000
>
00000000
00110000
01011000
01110100
01111101
01111100
00111000
00000000

TIL 76
00000000
00001000
00000000
00000010
00000000
00000000
00000000
00000000
>
00010000
00000000
00000100
00000000
00000001
00000000
00000000
00000000
WAL true

TIL 77
00100100
00100100
00100100
00100100
00100100
00100100
00100100
00100100
WAL true

TIL 78
00010000
00001100
00010000
00010000
00010000
00001001
00010000
00010000
WAL false

TIL 79
00000000
00000000
11111100
00100010
00011110
00000010
11111110
00000100

TIL 80
00000000
00000000
00000000
00000000
00000000
01111111
10010000
01111111

TIL 81
01000010
01000010
01000010
01111110
01000010
11111110
00010001
11111110

TIL 82
00001000
00001000
00001000
00001000
00001000
00001000
00001000
11110000
WAL true

TIL 83
00001000
00001000
00001000
00001000
00001000
00001000
00001000
11110111
WAL true

TIL 84
00000000
00000000
00000000
00000000
00000000
00000000
00000000
10010111
WAL true

TIL 85
00010000
00010000
00010000
00010000
00010000
00010000
00010000
11101111
WAL true

TIL 86
00010000
00010000
00010000
00010000
00010000
00010000
00010000
00001111
WAL true

TIL 88
00000000
00000000
00000000
00000000
00000000
00100010
11011101
00000000
>
00000000
00000000
00000000
00000000
00000000
01000100
10111011
00000000

TIL 89
00000000
00000000
01000000
00000000
00000000
00000000
00000000
00000000
>
00000000
00000000
01000000
00000000
00000000
00000000
00000000
00000000

TIL 90
00000000
00000000
00000000
00000000
00001000
00010100
00001000
00000000
>
00000000
00000000
00000000
00000000
00000000
00001000
00000000
00000000
NAME bubble 2
WAL true

TIL 91
00000000
00000000
00000000
00000011
00001100
00110000
11000111
00000000

TIL 92
00001100
00111000
11000100
00000100
00000010
00000010
11111001
00000001

TIL 93
00000000
00001000
00000010
00000000
00000000
00001000
00000010
00000000
>
00000000
00000010
00001000
00000000
00000000
00000010
00001000
00000000
WAL false

TIL 94
11110000
00001000
00000100
01100100
01100010
10011010
10011010
00000010
WAL false

TIL 95
00001111
00010000
00100000
00100110
01000110
01011001
01011001
01000000
WAL false

TIL 96
11111110
11111111
11111111
11111111
11111111
11111111
11111111
11111111
>
11111111
11111111
11111111
11111111
11111111
11111111
11111111
01111111

TIL 97
11111110
11111111
11111111
11111111
11111111
11111111
11111111
11111111
>
11111111
11111111
11111111
11111111
11111111
11111111
11111111
01111111
WAL true

TIL 98
00000000
00000000
00000000
00101010
01010101
00100010
00000000
00000000
>
00000000
00000000
00000000
00101010
01010101
00100010
00000000
00000000

TIL 99
11111110
11111111
11111111
11010101
10101010
11011101
11111111
11111111
>
11111111
11111111
11111111
11010101
10101010
11011101
11111111
01111111

TIL a
00000000
00000000
11000000
10000000
11110000
11100000
11111100
11111000

TIL b
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
WAL true

TIL c
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111

TIL e
00110000
00110000
00001100
00001100
00010000
00001000
00010000
00000000

TIL f
11111111
11111111
11111111
11111111
11111100
11111100
00111100
00111100
WAL true

TIL g
00001110
00001101
00110011
00110011
00001101
00001100
00000011
11000011
WAL true

TIL h
01010011
00100011
11001101
11001100
00110011
00110011
11000000
11000000
WAL true

TIL i
01010110
10110011
00000000
00000000
00110000
00110000
00001100
00001100
WAL true

TIL j
11111111
11111111
11111111
11110111
11111111
00111111
11111111
11000111

TIL k
11111111
11011111
10111111
10111111
01111111
10111111
11111111
11111111
WAL true

TIL l
11111111
11111111
11111111
11111111
11111111
11111111
00111111
11101111

TIL m
00010000
00111000
00010000
11111111
01111110
01111110
00111100
00011000
>
00010100
00111000
00010000
11111111
01111110
01111110
00111100
00011000

TIL n
00000000
00011000
00100100
01000100
01001110
01001110
00100100
00100000
WAL true

TIL o
00000000
00000000
00000000
01000100
11111111
01000100
01000100
01000100

TIL p
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
WAL true

TIL q
11111111
11111110
11111111
11111111
11111111
11111111
11111111
11111111
WAL true

TIL r
11111111
11111110
11111111
11111111
11111111
11111111
11111111
11111111
WAL false

TIL t
01111110
01111111
01111111
01111111
00110111
00000111
00000011
00000000
WAL true

TIL u
00100001
00110011
11111111
11111111
11111111
11111111
01111011
00000000

TIL v
11111000
11111000
11111000
11111000
11111000
10110000
00000000
00000000

TIL w
11111000
11111000
11111000
11111000
11111000
11111000
11111000
11111000

TIL x
01111100
01111100
01111100
01111100
01111100
01111100
01111100
01111100

TIL y
01111111
10000100
10111000
10100000
10100000
11000000
10000000
10000000

TIL z
10000000
10000000
10000001
01000010
01000010
00100100
00011000
00000000

TIL 1a
01011101
01000001
00111110
10000000
11111111
11111111
11111111
11111111
WAL true

TIL 1c
01111111
11111111
00011111
00111111
00000111
00001111
00000001
00000011
WAL true

TIL 1d
01011111
01000000
01011001
01011001
01000010
01000100
01011001
01011001

TIL 1e
11111010
00000010
10011010
10011010
01100010
01100010
10011010
10011010

TIL 1f
11110000
00001000
00000100
01100100
01100010
10011010
10011010
00000010
WAL true

TIL 1g
00001111
00010000
00100000
00100110
01000110
01011001
01011001
01000000
WAL true

TIL 1h
11001100
11011100
11110011
11110010
11111101
11111110
11111111
11111111

TIL 1i
00000000
00000000
11111110
00000001
00000010
11111100
00110000
00010000

TIL 1j
00000000
00000000
11111111
00000000
00000000
11111111
00010000
00010000

TIL 1k
00000000
00000000
00011111
00100000
01000000
00111111
00011000
00010000

TIL 1l
00111110
00100010
11111111
01111111
00011100
11111111
00100010
00100010

TIL 1m
00000000
00000000
00000000
00000000
00000000
00100000
00111110
00100010
WAL true

TIL 1n
00000000
00000110
00000000
01100000
00000000
00000000
00000110
00000000
NAME brick
WAL true

TIL 1o
00010000
00000000
00010000
00011000
00011000
00111100
00011000
00000000
>
00000000
00000000
00010000
00011000
00011000
00111100
00011000
00000000
WAL true

TIL 1p
00010000
00000000
00010000
00011000
00011000
00111100
00011000
00000000
>
00000000
00000000
00010000
00011000
00011000
00111100
00011000
00000000
WAL false

TIL 1q
10100101
11111111
11111111
11111111
11111111
11111111
11111111
11111111
WAL true

TIL 1r
00101001
11111111
11111111
11111111
11111100
11111100
00111100
00111100
WAL true

TIL 1s
11111111
11111001
10011111
11111111
11111111
11111111
11001111
11111111
WAL true

TIL 1t
00000000
00000000
00000011
00000001
00001111
00000111
00111111
00011111

TIL 1u
00110000
00110000
00001100
00001100
00010000
00001000
00010000
00000000
WAL true

TIL 1v
11111111
01111111
11111111
11111111
11111111
11111111
11111111
11111111
WAL true

TIL 1w
00000000
01010101
01111111
01010101
00111110
00111110
00011100
01111111

TIL 1y
00000000
00000000
00100000
00100000
00100000
11111000
01010000
01010000
WAL true

TIL 1z
01010000
01111000
01100100
01011100
01000100
01110100
01001100
00111000

TIL 2a
00000000
00000000
00000000
01000100
11111110
01000100
01000100
01000100

TIL 2b
01010101
01010111
01110101
01010101
01011101
01010101
01110101
01010101

TIL 2c
10101010
10101010
11101110
10101010
10111010
10101010
10111010
10101010

TIL 2d
00000000
00001111
00010100
00100111
01001000
01010011
01110110
01010101

TIL 2e
00000000
11110000
10001000
11100100
01010010
11001110
00101010
10101010

TIL 2f
00101010
01010010
01010111
01011000
01010000
00100000
00011111
00100000
>
00101010
01010010
01010111
01011000
01010000
00100000
00011111
00100000
WAL true

TIL 2g
01010100
01001010
11101010
00011010
00001010
00000100
11000100
00000100
>
01010100
01001010
11101010
00011010
00001010
00000100
11010100
00000100
WAL true

TIL 2h
00000000
00000000
00000000
00000000
00001000
00010100
00001000
00000000
>
00000000
00000000
00000000
00000000
00000000
00001000
00000000
00000000
NAME bubble

TIL 2i
00000100
00011111
00111111
01110111
01111111
01111111
10111111
00000000
>
00000100
00011111
00111111
01110111
01111111
01111111
10111111
00000000

TIL 2j
00000000
00001010
10001110
11100110
11111110
11111110
11111101
00000000
>
00000000
00010100
10011100
11101100
11111100
11111100
11111011
00000000

TIL 2k
00000000
00000000
00000000
00000000
00000000
00011011
00100100
00000100
>
00000000
00000000
00000000
00000000
00011011
00100100
00000100
00000100
WAL true

TIL 2l
00000000
00000000
00000000
00000000
00000000
00000000
10000000
00000000
>
00000000
00000000
00000000
00000000
00000000
10000000
00000000
00000000
WAL true

TIL 2m
00101011
00100000
00011111
00100000
00101011
00100000
00011111
00100000
>
00100011
00100000
00011111
00100000
00100011
00100000
00011111
00100000

TIL 2n
11111000
00000100
11000100
00000100
11111000
00000100
11000100
00000100
>
11111000
00000100
11010100
00000100
11111000
00000100
11010100
00000100

TIL 2o
10101010
10101010
11101110
10101010
10111010
10101010
10111010
10101010
WAL true

TIL 2p
01010101
01010111
01110101
01010101
01011101
01010101
01110101
01010101
WAL true

TIL 2q
11111111
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL 2r
11111111
00000000
00000000
01100000
00000000
00000110
00000000
00000000

TIL 2s
10000001
10000001
10110001
10000001
10000101
10000011
10000101
10000011

TIL 2t
00000000
00111100
01100110
11000011
10011001
10100101
10100101
10011001
WAL true

TIL 2u
00110000
00110000
00001100
00001100
00110000
00110000
00001100
00001100
WAL true

TIL 2v
00000100
00010100
00000100
00011111
00001010
00000111
00011111
00001111
>
00000100
00000100
00100100
00011111
00001010
00100111
00001111
00001111
WAL true

TIL 2w
00000100
00010100
00000100
00000100
00000100
00000111
00000100
00010100
>
00000100
00100100
00000100
00000100
00000100
00000111
00100100
00000100
WAL true

TIL 2x
00000000
00000000
00000000
00000000
00000000
10000000
00000000
00000000
>
00000000
00000000
00000000
00000000
00000000
01000000
00000000
00000000
WAL true

TIL 2y
00000000
00000000
00000000
00000000
00000000
01000000
00000000
00000000
>
00000000
00000000
00000000
00000000
00000000
10000000
00000000
00000000

TIL 2z
00000111
00001010
00011111
00000100
00000100
00000111
00010100
00000100
>
00000111
00001010
00011111
00000100
00000100
00100111
00000100
00000100

TIL 3a
00001000
00001010
00001111
00001111
00001000
00001111
00011111
00011010
WAL true

TIL 3b
10101000
10101000
11111000
11111000
00001000
11111000
11111000
10101000
WAL true

TIL 3c
00011101
00011111
00011101
00011111
00011111
00011111
00011111
00001111
>
00011101
00011111
00011111
00011111
00011111
00011111
00011111
00001111

TIL 3d
11011000
11111000
11111000
11111000
11111000
11111000
11111000
11110000
>
11011000
11111000
11111000
11111000
11111000
11111000
11111000
11110000

TIL 3e
00000000
10000000
00000000
00110000
00011000
00001111
00000011
00000000

TIL 3f
00000000
00000001
00000000
00000100
00011000
11110000
11000000
00000000

TIL 3g
00000000
00000010
00000000
00001100
00111000
11100000
10000000
00000000

TIL 3h
00000000
00000000
00100000
00011000
00001100
00000111
00000001
00000000

TIL 3i
00000000
00000000
00000000
00000001
00000110
00011000
01100000
10000000

TIL 3j
00000000
00000000
00000000
10000000
01100000
00011000
00000110
00000001

TIL 3l
00000000
00000000
00000000
00000000
00000000
01000000
00000000
00000000
>
00000000
00000000
00000000
00000000
00000000
10000000
00000000
00000000

TIL 3m
00101010
00101010
10100010
00011111
00000000
11111111
00010000
00010000

TIL 3n
00000111
10100100
10101001
11110011
00000000
11111111
00000000
00000000

TIL 3o
10000001
01011111
00011111
10011111
00000000
11111111
00010000
00010000

TIL 3p
00111110
00100010
01111111
01111111
00011100
11111111
00100010
00100010

TIL 3q
00000100
10001000
00000100
00000100
00000100
00011000
00000100
00000100
WAL true

TIL 3r
00000000
00000001
00000000
00000000
00000000
00000011
00000000
00000000

TIL 3s
00000000
00000000
00000000
00000000
00000011
00000100
00000100
00000100

TIL 3t
00100000
00000000
00000010
00100010
11011101
00000000
00000000
00000000
WAL true

TIL 3u
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00100000

TIL 3v
00000000
00000000
00000000
00000000
11100000
00010000
00010000
00010000

TIL 3w
00010000
00001100
00010000
00010000
00010000
00001001
00010000
00010000
WAL true

TIL 3x
00000000
01100000
00000000
00000000
00000000
10000000
00000000
00000000

TIL 3y
10011101
00000000
01100010
00000000
00001000
00000000
00000000
00000000
WAL true

TIL 3z
00010000
00010000
00010010
00010010
00001101
00000000
00000000
00000000
WAL true

TIL 4a
00011111
00100000
01001111
01100000
01000000
01101111
01000000
01100000

TIL 4b
11111000
00000100
11110010
00000110
00000010
11110110
00000010
00000110
WAL true

TIL 4c
01111111
00011000
00001000
00000000
00000000
00000000
00000000
00000000
WAL true

TIL 4d
11111110
00011000
00010000
00000000
00000000
00000000
00000000
00000000
WAL true

TIL 4e
00011000
00010000
00010001
00011100
00010000
00001000
00000111
00000100

TIL 4f
00011000
10001000
10001000
00011000
00001000
00010000
11100000
00100000
WAL true

TIL 4g
10001000
10001000
00011000
00001000
00010000
11100111
00101010
00010000

TIL 4h
00000000
00000000
00000000
00000000
00000000
11100000
01010000
00001000
WAL true

TIL 4i
00000000
00000000
00000000
00000000
00000000
00000111
00001010
00010000

TIL 4j
00010000
00010001
00011100
00010000
00001000
11100111
01010100
00001000

TIL 4k
00000000
00000000
00000000
00000000
00000111
00001010
00010000
00011000

TIL 4l
00000000
00000000
00000000
00000000
11100000
01010000
00001000
00011000

TIL 4m
00000010
11110110
00000010
00000111
10100010
00000100
11111000
00010000
>
00000010
11110110
00000010
00000110
10100010
00000100
11111000
00010001
WAL false

TIL 4n
01111111
01111111
01111111
01111111
01111111
00111111
00011111
00000000

TIL 4o
11111100
11111000
10000000
11100000
11110000
11111100
11111000
00000000

TIL 4p
00000000
00000000
00000000
00000000
00011111
00111111
01110001
01011111
WAL true

TIL 4q
00000000
00000000
00000000
00000000
11111111
11111110
00110000
11100000
WAL true

TIL 4r
11000000
10000011
10000001
10000001
10000001
11111111
10000001
10000001

TIL 4s
11110000
00001000
00000100
00000100
00000100
00011000
00000100
00000100
WAL true

TIL 4t
00000111
00001000
00010000
00010000
00010000
00001001
00010000
00010000
WAL true

TIL 4u
00000001
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL 4v
00000000
10000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL 4w
00000000
00000100
01000000
00000000
00010000
00000000
00000000
00000000
NAME dots
WAL true

TIL 4x
00111100
01111110
01001010
01000000
01111110
01111110
01111110
01111110
>
00000000
00111100
01111110
01001010
01000000
01111110
01111110
01111110

TIL 4y
00000000
00110000
01111100
01111110
00101010
00000010
01111110
01111110
>
00110000
01111100
01111110
00101010
00000010
01111110
01111110
01111110

TIL 4z
00000000
00011100
00111110
01010100
01000000
01111110
01111110
01111110
>
00000000
00000000
00011100
00111110
01010100
01000000
01111110
01111110

TIL 5a
11111111
00100010
00000010
00100000
00000000
00000000
00000000
00000000
WAL true

TIL 5b
00001000
00001000
00000100
00000100
00000000
00011110
00100001
01011110
>
00000100
00000100
00001000
00001000
00000000
00011110
00100001
01011110
WAL true

TIL 5c
00000000
00000000
00000000
00000000
00000000
00011100
00101010
00100010
WAL true

TIL 5d
00000000
00000000
00000000
00000000
00000000
00111000
01000100
00111000
WAL true

TIL 5e
00000000
01110001
10001010
01110001
10001010
10001010
11001011
11111011

TIL 5f
00000000
11000111
00101000
11000111
00101000
00101000
00101100
11101111

TIL 5g
00000000
00011100
10100010
00011100
10100010
10100010
10110010
10111110

TIL 5h
00000000
01000000
01111111
01010101
00001000
00010101
00001000
00010101

TIL 5i
00001000
00010101
00001000
00010100
00001000
00010100
00001000
00000000
WAL true

TIL 5j
00000000
00000000
11111111
01010101
10001000
01010101
10001000
01010101

TIL 5k
10001000
01010101
10001000
00010101
00001000
00000001
00000000
00000000
WAL true

TIL 5l
10001000
01000000
10000000
01000000
10000000
01000000
10000000
00000000
WAL true

TIL 5m
00000000
00000001
11111111
01010101
10001000
01010100
10001000
01010100

TIL 5n
10001000
00010100
00001000
00010100
00001000
00000000
00000000
00000000
WAL true

TIL 5o
00000000
00000000
00111110
01000001
01011101
01111111
01000001
01000001
NAME chest

TIL 5q
00111100
01000010
00111100
01000010
01000010
01100010
00111100
01000010

TIL 5r
11111111
00000000
00000000
00000000
00000100
00001010
00100100
00000000
>
11111111
00000000
00000000
00000000
00000000
00100100
01010000
00100000
WAL true

TIL 5t
00000110
00101000
00001000
00001000
00001000
11110000
11110000
01100000
>
00000110
00001000
00001000
01001000
00001000
11110000
11110000
01100000

TIL 5u
00000000
01000100
01111111
01000100
00000100
00001100
00010100
00010010

TIL 5v
00000000
00010001
11111111
00010001
00101000
01001100
01001010
01001000

TIL 5w
01001000
10010100
00000100
00000100
00000000
00000000
00000000
00000000
WAL true

TIL 5x
00010010
00101010
00100000
00000000
00000000
00000000
00000000
00000000
WAL true

TIL 5y
00000000
00000000
01111111
00000000
00000000
00000000
00000000
00000000
WAL true

TIL 5z
00000000
00000001
11111111
00000001
00000000
00000000
00000000
00000000
WAL true

TIL 6a
00100000
00000000
00000010
00100010
11011101
00010100
00010100
00010100
WAL true

TIL 6b
00000000
00010001
00101010
00110011
00101010
00110010
00000000
00000000

TIL 6c
00000000
00010000
10101000
10110000
10101000
10101000
00000000
00000000

TIL 5s
01111111
00011000
00001000
00111100
01000010
10100001
10000001
01000010
>
01111111
00011000
00001000
00000000
00111100
01100010
01010010
01000010
WAL true

TIL 6d
00000000
00011100
00100010
00011100
00100010
00100010
00110010
00111110

TIL 6k
00010000
00010000
00010000
00010000
00010000
00010000
00010000
00111000

TIL 6l
00000000
00111000
00101000
01011100
01011100
11111110
10101010
00010000
WAL true

TIL 6r
00000001
00000001
00000001
00000001
00000001
00000001
00000001
00000001

TIL 6s
01111100
10000010
10000010
10000010
10000010
10000001
01100000
00010000

TIL 6t
01111100
10000010
10000010
10000010
10000010
00000001
00000000
00000000

TIL 6u
01111100
10000010
10000010
10000010
10000010
00000010
00000100
00000100

TIL 6v
00000000
00000000
00000000
00000000
00000000
00001000
00000000
00100100
>
00000000
00000000
00000000
00000000
00001000
00000000
01000010
00000000

TIL 6w
00100100
00100100
00100100
00100100
00100100
00100100
00110100
00101100

TIL 6x
00011000
00100111
00100100
00100100
00100100
00100100
00100100
00100100
>
00011000
00100100
00100111
00100100
00100100
00100100
00100100
00100100

TIL 6y
00000000
11000111
00111000
00000000
00000000
00000000
00000000
00000000
>
00000000
00111000
11000111
00000000
00000000
00000000
00000000
00000000

TIL 6z
11100000
00011000
00010000
00010010
00010000
00010000
00010000
00010000
>
00000000
11100000
00010100
00010000
00010001
00010000
00010000
00010000

TIL 7c
00000000
00000000
00111111
01000000
01000000
01000000
01111111
00100000

TIL 7h
01111100
01000100
01000100
00111000
11111110
01000100
01111100
01000100

TIL 7i
00000000
00010000
00011000
00010000
00110000
00010000
00011000
00010000
WAL true

TIL 7j
00000001
00000001
00000011
00000101
00000101
00011101
00100001
11111110

TIL 7k
10000000
10000000
11000000
10100000
10100000
10111000
10000100
01111111

TIL 7l
00000000
00000000
00000000
00000000
00000000
00000000
00000000
11111111

TIL 7m
00101010
00111110
01111110
01101010
01111110
01111110
01111110
01111110

TIL 7o
00000000
00000000
01111110
01000010
01000010
01110010
01000010
01111110

TIL 7p
01111111
10000000
01110000
00100000
00011100
00001000
00000111
00000010

TIL 7q
00000001
00000000
00000000
00000000
00000000
00000000
00000000
00000000
WAL true

TIL 7r
11111110
00000001
00001110
00000100
00111000
00010000
11100000
01000000

TIL 7s
10000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
WAL true

TIL 7t
00000000
00000000
00000000
00000000
00000000
00001000
00000000
01000100
>
00000000
00000000
00000000
00000000
00001000
00000000
10000010
00000000
WAL true

TIL 7u
00111110
01000001
01111111
01010101
01010101
01010101
01111111
01010001
WAL true

TIL 7v
00000000
01101011
00000000
11010110
00000000
01101011
00000000
00000000
WAL true

TIL 7w
00000000
00000000
11010110
00000000
01101011
00000000
11010110
00000000
WAL true

TIL 7x
00001000
00101010
00100010
00001000
00100010
00001000
00101010
00100010
WAL true

TIL 7y
00010000
01000100
00010000
01000100
01010100
00010000
01000100
01010100
WAL true

TIL 7z
00000000
00000000
00001000
00001010
00101010
11111111
00010000
11111111

TIL 8a
00000000
00000000
00000000
00000000
00000000
00000000
00000000
11101001
WAL true

TIL 8b
00000000
01011110
00000000
00110000
00000000
00001000
00000000
00010000
>
00000000
01101110
00000000
00011000
00000000
00010000
00000000
00000100
WAL true

TIL 8c
01000000
01000010
01000010
01111110
01000010
01100010
11011101
00000000
>
01000000
01000010
01000010
01111110
01000010
01000110
10111011
00000000

TIL 8d
00000000
00000000
00000000
11000011
00100100
00011000
10000001
01000010
WAL true

TIL 8e
00000000
00000000
00000000
00000011
00000100
00001000
00001001
00000110
WAL true

TIL 8f
00000000
00000000
00000000
11000000
00100000
00010000
10010000
01100000
WAL true

TIL 8g
00100100
00100100
00100100
00100100
00100100
00100100
01000010
01000010
WAL true

TIL 8h
01000010
01100010
01000010
01000010
01000010
01001110
01000010
01000010
WAL true

TIL 8i
10000001
10000001
10000001
10000011
10000001
11111111
00010000
11111111

TIL 8j
01000000
01000000
01000000
01000000
01000000
01000000
01000000
00100011
WAL true

TIL 8l
00000011
00000100
00001000
00010000
00010000
00100000
00100000
00100000

TIL 8m
00000000
00001000
00000000
00000010
00000000
00000000
00011111
11100000
>
00010000
00000000
00000100
00000000
00000001
00000000
00011111
11100000

TIL 8n
00000000
00001000
00000000
00000010
00000000
00000000
01111111
10000000
>
00010000
00000000
00000100
00000000
00000001
00000000
01111111
10000000

TIL 8o
00000000
00001000
00000000
00000010
00000000
00000000
01111000
10000111
>
00010000
00000000
00000100
00000000
00000001
00000000
01111000
10000111

TIL 8p
11000000
00100000
00010000
00001000
00001000
00000100
00000100
00000100

TIL 8q
00000010
00000010
00000010
00000010
00000010
00000010
00000010
11000100
WAL true

TIL 8s
01000000
01000000
01000100
01000101
01010101
11111111
00010000
11111111

TIL 8t
00000010
00000010
00001010
00101010
10101010
11111111
00010000
11111111

TIL 8u
00000000
00000000
00000000
00000000
10000000
10000000
00000000
00000000

TIL 8v
00011000
00100100
00111100
01000010
10011001
10010001
10000001
01111110

TIL 8w
01000010
01000010
01000010
01111110
01000010
01000010
01000010
01111110

TIL 8x
00000000
00000000
00000000
00000000
00000000
00111111
01000000
01111111

TIL 8y
00000000
00000000
00000000
00000000
00000000
11111111
00000000
11111111

TIL 8z
00000000
00000000
00000000
00000000
00000000
11111111
00000010
11111100

TIL 9a
00000000
01000100
00101000
00010000
00101000
01000100
00000000
00000000

TIL 9b
11111111
01111111
11111111
11111111
11111111
11111111
11111111
11111111
WAL false

TIL 9c
11001100
11001100
11110111
11111110
11101101
11111011
11111101
11111111
WAL true

TIL 9d
11111100
11100100
11111111
11101110
11110100
11111100
11111111
11111111
WAL false

TIL 9e
00001110
00001101
00110011
00110011
00001101
00001100
00000011
11000011
WAL false

TIL 9f
01000100
10111011
00000000
10011010
01100010
01100010
10011010
10011010
>
10001000
01110111
00000000
10011010
01100010
01100010
10011010
10011010

TIL 9g
01000100
10111000
00000011
00000001
00001111
00000111
00111111
00011111
>
10001000
01110100
00000011
00000001
00001111
00000111
00111111
00011111

TIL 9h
00000100
00111011
11000000
10000000
11110000
11100000
11111100
11111000
>
00001000
00110111
11000000
10000000
11110000
11100000
11111100
11111000

TIL 9i
01000100
10111011
00000000
01011001
01000010
01000100
01011001
01011001
>
10001000
01110111
00000000
01011001
01000010
01000100
01011001
01011001

TIL 9j
01110111
01110111
01110111
01110111
11111111
01110111
00100010
00000000

TIL 9k
01110111
01110111
01110111
01110111
01110111
11111111
01110111
01110111
WAL true

TIL 9l
00000000
00011111
00111111
01111111
01111000
01110011
01110111
01110111

TIL 9m
00000000
11111111
11111111
11111111
00000000
11100011
11110111
11110111

TIL 9n
00000000
11111000
11111100
11111110
00001111
11100111
11110111
11110111

TIL 9o
00000000
00000000
00000000
00000000
00000000
10000000
00000000
00000000
WAL true

TIL 9p
00000000
00000000
00000000
00000000
10000000
00000000
00000000
00000000

TIL 9q
00000000
00000000
01111111
10011000
01110011
00010111
00010111
00010111

TIL 9r
00000000
00000000
11111111
00000000
11111111
11111111
11111111
11111111

TIL 9s
00000000
00000000
11111100
00110010
10011100
11010000
11010000
11010000

TIL 9u
00010111
00010111
00010111
00010111
00010111
00010111
00010111
00010111

TIL 9v
00010111
00010111
00010111
00010011
00011000
00011111
00001110
00000100
WAL true

TIL 9w
11111111
11111111
11111111
11111111
00000000
11111111
11101110
01000100

TIL 9x
11010000
11010000
11010000
10010000
00110000
11110000
11100000
01000000

TIL 9y
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL 9z
11010000
11010000
11010000
11010000
11010000
11010000
11010000
11010000

TIL a0
11111111
11000011
10011111
10011111
11000111
11110011
11110011
10000111

TIL a1
11111111
11111111
01110101
01010101
00000001
01010101
00000001
10000011

TIL a3
11111111
11111111
11111111
01101101
10101011
10000011
10000011
11000111

TIL a4
01000000
00000100
00111000
11000100
01010100
11000100
00111000
01000100

TIL a5
01000000
00000100
01000000
00000100
01000000
00000100
01000000
00000100
WAL true

TIL a6
11111010
01111010
00011010
11110010
00000110
11111110
10011100
00001000

TIL a7
10111100
10111000
10110000
10011111
11000000
11111111
01110011
00100001
WAL false

TIL a8
10111111
10111111
10111111
10111111
10111111
10111111
10111111
10111111

TIL a9
11111010
11111010
11111010
11111010
11111010
11111010
11111010
11111010

TIL aa
00000000
00000000
11111111
11000000
10011111
10111101
10110110
10110100

TIL ab
00000000
00000000
11111111
00000110
11110011
10111010
10111010
01011010

TIL ae
10111110
10111110
10111110
10111110
10111110
10111110
10111110
10111110

TIL af
11111010
11111010
11111010
11111010
11111010
11111010
11111010
11111010

TIL ag
00000000
00111000
01000100
01010100
01000100
00111000
01000000
00000100

TIL ah
00000000
00111100
01000010
01011011
01011010
01010011
01011010
01000010

TIL ai
00000000
00000000
10000000
01000000
10000000
00000000
00000000
00000000

TIL aj
00000000
00000000
00000011
00000100
00000011
00000000
00000000
00000000

TIL ak
10101010
10101000
10110110
10101010
10110000
10101010
10110010
10111100

TIL al
10011010
01101010
10011010
01001010
10011010
01101010
10011010
01111010

TIL am
00111100
01000010
01011010
01000010
00111100
00100100
00100100
01000010

TIL an
01011011
00000000
00000000
00000000
00000000
00000000
00000000
00000000
WAL true

TIL ao
00010000
00010000
00010000
00010000
00010000
11110000
00011000
00010000
>
00010000
00010000
00010000
00010000
00010000
01110100
00010000
00010100

TIL ap
00000000
00000000
00000000
00000000
11000100
10001000
00110000
10110000
WAL true

TIL at
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
>
00000000
00000000
00000000
00000000
00000000
00000001
00000000
00000000
WAL true

TIL au
00010000
00010000
00010000
00010000
00010000
11111100
11101100
11111000

TIL av
11111111
11111111
11111111
10000000
00110000
00110000
00001000
00000000
WAL true

TIL aw
11111111
11111111
11111100
00010000
00010000
00001010
00010000
00010000
WAL true

TIL ax
00010000
00010000
00010000
01111100
10101000
11110000
11110000
11110000
WAL true

TIL ay
00100000
00100000
00100000
10100000
10100000
00100000
00100000
00100000

TIL az
00000011
00000011
00000011
00000010
00000010
00000011
00000011
00000011

TIL b0
00000000
00000000
00000000
00000000
11000100
10001000
00110000
10110000
WAL false

TIL b1
11111100
11100100
11111111
11101110
11110100
11111100
11111111
11111111
WAL true

TIL b2
00000000
00010000
00000000
01000000
00000000
00000000
00000000
00000100
>
00001000
00000000
00100000
00000000
10000000
00000000
00000000
00000000
NAME rain2

TIL b3
00000000
00010000
00000000
01000000
00000000
00000000
00000000
00000000
>
00001000
00000000
00100000
00000000
10000000
00000000
00000000
00000000
NAME rain3

TIL b4
10000001
10000001
10000001
10000011
10000001
10000001
10000001
10000001

TIL b9
00000000
00010000
00000000
01000000
00000000
00010000
01010100
01010101
>
00001000
00000000
00100000
00000000
10000000
00010000
01010100
01010101

TIL ba
11010101
00010101
00010100
00010010
00001001
00000100
00000011
00000000
WAL true

TIL bb
01111110
00000000
11111111
00000000
11111111
00000000
11111111
00000000
WAL true

TIL bd
10101011
10101000
00101000
01001000
10010000
00100000
11000000
00000000
WAL true

TIL be
00000000
00010000
00000000
11000000
00100000
00010000
10010000
01100100
>
00001000
00000000
00100000
11000000
00100000
00010000
10010000
01100000
WAL true

TIL bf
00000000
00010000
00000000
11000011
00100100
00011000
10000001
01000010
>
00001000
00000000
00100000
11000011
00100100
00011000
10000001
01000010
WAL true

TIL bg
00000000
00010000
00000000
01000011
00000100
00001000
00001001
00000110
>
00001000
00000000
00100000
00000011
10000100
00001000
00001001
00000110
WAL true

TIL bh
00000000
00010000
00000000
01000000
00000000
00000000
01000001
01010101
>
00001000
00000000
00100000
00000000
10000000
00000000
01000001
01010101

TIL bi
01101110
10010001
10010001
01110001
00001110
00000000
00000000
00000000
WAL true

TIL bj
01110110
10001001
10001001
10001110
10001000
01110000
00000000
00000000
WAL true

TIL bk
01110110
10001001
10001001
01110110
00000000
00000000
00000000
00000000
WAL true

TIL bl
00001010
00001100
00001000
00001000
00001000
00001000
00011100
00101010

TIL bm
00000000
00000000
00000000
00011100
00001100
00111110
00001000
00001000
WAL true

TIL bn
00000100
01001000
00000100
00000100
00000100
00011000
00000100
11111100
WAL true

TIL bo
00010000
00001100
00010000
00010000
00010000
00001000
00010000
00011111
WAL true

TIL bp
10000100
01000100
01000000
00100100
00100000
00100000
00100000
00100000
>
10000100
01000000
01000100
00100000
00100000
00100100
00100000
00100000
WAL true

TIL bq
00000000
00000001
00000001
00000011
00000011
00000011
00000011
00000011
WAL true

TIL br
01010101
01000100
01111111
01010001
01010101
01010100
01111111
01000000

TIL bs
01010110
01010110
11111110
00010110
01010110
01010110
11111110
00000110

TIL bt
00000000
00010000
00000000
01000000
00000000
00000000
00000000
00000100
>
00001000
00000000
00100000
00000000
10000000
00000000
00000000
00000000
WAL true

TIL bu
00100000
01000000
01000000
01000000
01000000
01000000
01100000
01000000

TIL bv
00000100
00000010
00000010
00000110
00000010
00000010
00000010
00000010

TIL bw
00000100
00001100
00000100
00000100
00000100
00011100
00000100
00000100
WAL true

TIL bx
00100000
00100000
00100000
00111000
00100000
00100000
00100000
00110000
WAL true

TIL by
00000000
01110000
10001000
00001000
00001000
00010000
00100000
00100000
WAL true

TIL bz
00000000
00001110
00010001
00010000
00110000
00001000
00000100
00000100
WAL true

TIL c0
00000000
00000101
11111111
00000000
00000000
11011010
00000000
00000000
>
10001000
00000000
11111111
00000000
00000000
11011010
00000000
00000000
WAL true

TIL c1
00000000
01011011
00000000
00000000
00000000
11011010
00000000
00000000

TIL c2
00100000
00101011
00100000
00100000
00100000
00101010
00100000
00100000

TIL c3
00000000
00000101
11111111
10000000
10000000
01111010
00100000
00100000
>
10001000
00000000
11111111
10000000
10000000
01111010
00100000
00100000

TIL c4
00100000
00101011
00100000
00100000
00100000
00101010
00100000
00100000
WAL true

TIL c5
00000000
01011011
00000000
00000000
00000000
11011010
00000000
00000000
WAL true

TIL c6
00000100
00000010
00000001
10000001
10000001
10000001
01000010
00111100

TIL c7
00000000
00010000
00000000
01000000
00000000
00000000
11110000
00001000
>
00001000
00000000
00100000
00000000
10000000
00000000
11110000
00001000
WAL true

TIL c8
00010000
00010000
00010000
00100000
01000000
01000000
00100111
00011000
WAL true

TIL c9
00000000
00010000
00000000
01000000
00000000
10000000
10000000
01100000
>
00001000
00000000
00100000
00000000
00000000
10000000
10000000
01100000

TIL ca
00000000
00010000
00000000
01000000
00000011
00000100
00001011
00001010
>
00001000
00000000
00100000
00000000
10000011
00000100
00001011
00001010

TIL cb
00001000
00011000
00001000
01000100
00000010
00000010
11100100
00011000
>
00001000
00001000
00101000
00000100
10000010
00000010
11100100
00011000
WAL true

TIL cc
00100000
01000000
10000000
10000001
10000001
10000001
01000010
00111100

TIL cd
00000000
00010000
00000000
01000000
00000000
00000000
00001111
00010000
>
00001000
00000000
00100000
00000000
10000000
00000000
00001111
00010000

TIL ce
01000010
01111111
01000010
01000010
01000010
11111110
01000010
01000010

TIL cf
01000010
01000111
11111111
01000010
01000010
11111110
01000010
01000010
>
11001010
01000010
11111111
01000010
01000010
11111110
01000010
01000010

TIL cg
01011100
01011100
11111111
00000000
00000000
11011010
00000000
00000000
WAL true

TIL ch
00000000
00000111
00000010
00011100
00001000
01110000
00100000
11000000

TIL ci
01111100
10000010
10111010
10000010
10111010
10000010
10111010
10000010
WAL true

TIL cj
10111010
10000010
10111010
10000010
10111010
10000010
10110010
10000010
WAL false

TIL cl
00111100
01000010
01011010
01000010
01011010
01000010
01011010
01000010

TIL cm
00000100
10001000
00000100
00000100
00000100
00011000
00000100
00000100
WAL false

TIL cn
00000000
10000000
11000000
11100000
11100000
11110000
11110000
01110000
WAL false

TIL co
01110000
01100000
00100000
00100000
00000000
00000000
00000000
00000000
WAL true

TIL cp
00000000
00000010
11000000
00000000
00110000
00000000
00001100
01000000
WAL true

TIL cq
00000000
00000000
00000001
00000011
00000011
00000011
00000011
00000010
WAL true

TIL cr
00000000
01000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL cs
00000000
11100000
01000000
00111000
00010000
00001110
00000100
00000011

TIL ct
00000111
11111000
00010000
00010000
00010000
00001001
00010000
00010000
WAL true

TIL cu
11110000
00001111
00000100
00000100
00000100
00011000
00000100
00000100
WAL true

TIL cv
00111110
01000001
01011111
01000001
01111101
01000001
01011111
01000001

TIL cw
00100000
00000000
00000010
00100010
11011101
00010000
00000000
00010000
>
00100000
00000000
00000010
00100010
11011101
00010000
00010000
00000000
WAL true

TIL cx
00100000
00000000
00000010
00100010
11011101
10010010
10010010
10010010
WAL true

TIL cy
10010010
10010010
11110010
11010010
11110010
10010010
10010010
10010010
WAL true

TIL cz
00000000
00000000
00000000
00000000
00000000
00010000
01000100
00000000
>
00010000
00000000
00000000
00000000
00000000
00000000
00010000
00101000

TIL d0
10100001
00000000
00000000
00000000
00000000
00100000
00010001
10010010

TIL d1
00000000
00111000
01111100
01010100
01111100
01111100
01010100
00000000
>
00000000
00111000
01111100
01010100
01111100
01111100
00101000
00000000

TIL d2
00000000
00000000
00011100
00111110
01010110
01111110
00111100
00111000

TIL d3
00000000
00000000
00000000
00000000
00011000
01100000
00000000
00000000
>
00000000
00000000
00000000
00001000
00010000
01100000
00000000
00000000

TIL d4
00001000
00001000
00001000
00001000
00001000
00001000
00011100
00100010

TIL d5
00000000
00001000
00001100
00010100
00001000
00011100
00001000
00001000
>
00000000
00001000
00011000
00010100
00001000
00011100
00001000
00001000
WAL true

TIL d6
00000000
00000000
00111111
01000000
01111111
01000000
01000000
00111111

TIL d7
00000000
00000000
11111110
00101001
11111111
00101011
00100011
11111110

TIL d8
00100000
00000000
00000010
00100010
11011101
11111111
10000001
10000001
WAL true

TIL d9
10011101
00000000
01100010
00000000
00001000
00000000
00000000
00000000
WAL false

TIL da
00001000
00000000
00100100
00001010
10001110
00000100
01000101
01010101
>
00000000
00010000
00000100
01001010
00001110
00000100
01000101
01010101

TIL db
00000000
10111111
01000100
01000100
01000100
01000100
11111011
00000000

TIL dc
01000010
10000001
00000000
00000000
00000000
00000000
10000001
01000010

TIL dd
01000010
01000010
00111010
01000010
01000010
01000010
01101110
01000010

TIL de
00000000
00000000
00000000
00000000
11001100
00000000
00000000
00000000

TIL df
00000000
00000000
00010000
00010000
00000000
00000000
00010000
00010000

TIL dg
00000000
00010000
00010010
00000010
01000000
01000000
00000100
00000000

TIL dh
01111100
10000010
11111110
10000010
10000010
10101010
10100010
00000000
WAL true

TIL di
00000000
00000000
00000000
00000000
00000000
00100010
10101010
00000000

TIL dj
00000000
00000000
00010000
00000000
01000100
00000000
00010000
00000000

TIL dk
00001000
00001000
00100000
00100100
00000100
00000000
00010000
00010000

TIL dm
00000000
00000000
00000000
00000000
00000000
01000100
01010101
00000000

TIL dn
00000000
00000000
00000000
00111111
00001000
00011111
00111111
00001000

TIL do
00000000
00000000
00000000
11111100
00100000
11111000
11111100
00100000
WAL false

TIL dp
00000000
00000000
00000000
00000000
10101010
11111111
10101010
00000000
WAL true

TIL dq
00000000
00000000
00000000
00000000
10101010
11111110
10101010
00000000
WAL true

TIL dr
00111111
01000000
01111111
01000000
01011110
01011110
01000000
00111111

TIL du
11111000
00000100
11111100
00000100
11100100
10100100
10100100
11111000

TIL dv
00000000
01001001
01001001
01001001
00000000
00000000
00000000
00000000

TIL dw
00111100
00000000
00000000
00000000
00000000
00000000
00000000
00111100

TIL dx
00000000
00100100
00100100
00100100
00000000
00000000
00000000
00000000

TIL dy
00000000
10001000
01010101
10101010
01010101
10101010
01010101
10101010
WAL true

TIL dz
01000000
10011111
01010101
10010100
01010001
10011111
01001010
10000100
WAL true

TIL e0
00000001
00000010
00000001
00000010
00000001
00000010
00000001
00000010
WAL true

TIL e1
00000000
00111111
01000100
01000100
01000100
01000000
01110001
01000010

TIL e2
01000010
01000001
00111000
01000000
01000010
01000010
00111111
00000000

TIL e3
00101101
00101101
00101101
00101101
00101101
00101101
01100000
11111111

TIL e4
10110100
10110100
10110100
10110100
10110100
10110100
00000110
11111111
WAL true

TIL e5
00000000
11111000
00000100
00000010
11111111
00000100
10110100
10110100
WAL true

TIL e6
00000000
00011111
00100000
01000000
11111111
00100000
00101101
00101101
WAL true

TIL e7
00000000
11100000
01010000
01101000
01001000
11111000
01010000
00100000
WAL true

TIL e8
01000000
10000000
01000000
10000000
01000000
10000000
01000000
10000000
WAL true

TIL e9
11111111
10001000
10001000
10001000
01110111
10001000
10001000
10000000
WAL true

TIL ea
00001000
10000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL eb
00010000
00010000
00010000
00010000
01111111
00110000
00010000
00010000

TIL ec
00000000
00000000
00000000
00000000
11111111
00000000
00000000
00000000

TIL ed
10100000
10100001
10100001
10100001
10100000
10100000
10100000
10100000

TIL ee
00111111
01000000
10011111
10100000
10100000
10100000
10100000
10100000
WAL true

TIL ef
11111100
00000010
11111001
10000101
10000101
10000101
10000101
10000101
WAL true

TIL eg
10000101
10000101
10000101
10000101
10000101
10000101
10000101
10000101

TIL eh
00010000
00010000
00010000
00010000
00010000
00010000
00010000
00010000
WAL true

TIL ei
00111000
01000100
11111110
00000000
00101000
00010000
00000000
00000000
>
00111000
01000100
11111110
00000000
01000100
00000000
00010000
00000000

TIL ej
00111111
01000000
01000000
01000000
01000000
01100000
01111111
00111111

TIL ek
11111111
00000000
00000000
00000000
00000000
00000000
11111111
11111111

TIL el
10100101
10100101
10100101
10100101
11111111
00000000
00000000
00000000

TIL em
00000000
00000000
00000000
00111100
01100110
10100101
10100101
10100101
WAL true

TIL en
11111111
11011011
11100111
11111111
11111111
00000000
00000000
00000000

TIL eo
11111100
00000010
00000010
00000010
00000010
00000110
11111110
11111000

TIL ep
00010000
00010000
00010000
00010000
00010000
00010000
00010000
00010000
WAL true

TIL eq
00010000
00010000
00010000
00010000
11111100
00011000
00010000
00010000

TIL er
00111110
01000001
01011001
01000001
00111110
00001000
00001000
01111111

TIL es
00000000
01000000
10100000
01100000
01011000
01000111
01000000
01000000
WAL true

TIL et
00000000
00000000
00000000
00000000
00000000
11111111
00000000
00000000

TIL eu
00000000
00000010
00000101
00000110
00011010
11100010
00000010
00000010

TIL ev
11111111
10001000
10001000
10001000
01110111
10001000
10001000
10000000
WAL true

TIL ew
10000000
10000000
10000000
10000000
00000000
10000000
10000000
10000000
WAL true

TIL ex
00000000
11111111
00000000
00111000
01000100
01111101
00010000
00111000

TIL ey
00000000
11111111
00000000
00000000
00000000
11111111
00000000
00000000

TIL ez
00000000
11110000
00001000
00000100
00000010
11000010
00100010
00100010

TIL f0
10000001
01111110
01000010
01010010
01011010
01011010
01111110
10000001
WAL true

TIL f1
00100010
00100010
00100010
11000010
00000010
00000010
00000010
11111100

TIL f2
00000000
00000000
00000000
11111111
00000000
00000000
00000000
11111111

TIL f3
00000000
00000000
00000000
00011111
00100000
00100000
00100000
00100001

TIL f4
00100010
00100010
00100010
00100010
00100010
00100010
00100010
00100010
WAL true

TIL f5
00000000
00000000
00000000
11111100
00000010
00000010
00000010
11000010

TIL f6
00000000
00001111
00010000
00100000
01000000
01000011
01000100
01000100

TIL f7
00100010
00100010
00100010
00100001
00100000
00100000
00100000
00011111

TIL f8
00000000
01111111
10000000
10010000
10110011
10110011
10110011
01111111

TIL f9
00000000
11111111
00000000
00000100
00000110
01010110
01110110
11111111

TIL fa
00000000
11111111
00000000
00000000
00000000
00000000
00000000
11111111

TIL fb
00000000
11111111
00000000
01111100
01000100
01000100
01111100
11111111

TIL fc
00000000
11111110
00000001
00001101
00101101
11100001
11101101
11111110

TIL fd
11111111
11111111
00000000
00000000
00000000
11111111
00000000
00000000

TIL fe
01110000
11111111
00000000
00111000
01000100
01111101
00010000
00111000
>
00111000
11111111
00000000
00111000
01000100
01111101
00010000
00111000

TIL ff
00011111
00011111
00011111
00011111
00011111
00011111
00011111
00001111
>
00011111
00011111
00011111
00011111
00011111
00011111
00011111
00001111

TIL fg
00001000
00001010
00001111
00001111
00001000
00001111
00011111
00011100
WAL true

TIL fh
10101000
10101000
11111000
11111000
00001000
11111000
11111000
11001000
WAL true

TIL fi
11111000
11111000
11111000
11111000
11111000
11111000
11111000
11110000
>
11111000
11111000
11111000
11111000
11111000
11111000
11111000
11110000

TIL fj
00000000
00000000
01110001
10000010
10011010
10001010
01110001
00000000

TIL fk
00000000
00000000
11000111
00101000
00101000
00101000
11000111
00000000

TIL fl
00000000
00000000
00111000
10100100
10100100
10100100
00111000
00000000

TIL fm
00000000
00000000
01111010
01000011
01111010
01000010
01111010
00000000

TIL fn
00000000
00000000
00101110
00101001
10101001
01101001
00101110
00000000

TIL fo
00000000
00000000
11100011
10010100
11100111
10010100
11100100
00000000

TIL fp
00000000
00000000
00111000
10100100
10100100
10100100
10111000
00000000

TIL fq
00010000
00010000
00010100
00010100
00010000
00010100
00100000
11000000

TIL fr
00000000
00000000
00000000
00000111
00001000
00010010
00010100
00010100

TIL fs
00000000
00000000
00000000
11111111
00000010
00000100
00000100
00000100

TIL ft
00000100
00000100
00000100
00000100
00000100
00000100
00001000
00110000

TIL fu
00000000
00000000
00000000
10000000
11000000
10100000
10100000
10100000

TIL fv
10100000
10100000
10100000
10100000
10100000
10100000
10010000
10001000

TIL fw
00100100
11111111
01000010
01000010
11111111
01000010
01000010
11111111

TIL fx
00000000
00000000
00010000
00000000
00000100
00010000
00011000
00111100
>
00000000
00000000
00001000
00100000
00001000
00011000
00111100
00111100

TIL fy
01000000
01000000
01000000
01111100
01111110
01000010
01000010
01000010

TIL fz
00001000
00001000
00011100
01111111
00001000
00001000
00001000
00010100

TIL g0
00000000
00000000
00000000
00000000
00000000
00000000
00001000
00000000
>
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00001000
WAL true

TIL g1
10111010
10000010
10100010
10000010
10111010
10101010
10111010
10000010

TIL g2
00000000
00000000
00000000
01111100
11111110
10000010
10111010
10101010
WAL true

TIL g3
00000001
00000001
00000001
00000001
00000001
00000001
00000001
00000001
WAL true

TIL g4
10000000
10000000
10000000
10000000
10000000
10000000
10000000
10000000
WAL true

TIL g5
01101110
10010001
10010001
01110001
00001110
00000000
00000000
00000000
WAL false

SPR 10
00000000
00000000
00111111
01010101
01010101
01010001
01111111
01010101
DLG SPR_l
POS g 3,2

SPR 11
00000000
00011100
00111110
01101010
11111110
11111100
01111000
00000000
>
00000000
00000000
00111000
01111100
11010100
11111100
01111000
00000000
DLG SPR_n
POS g 5,2

SPR 12
01001000
01111000
10101100
11111101
01111001
01111001
01111010
01111100
>
01001000
01111000
10101100
11111101
01111010
01111010
01111010
01111100
NAME cat
DLG SPR_o
POS h 11,9

SPR 13
10111010
10000010
10111010
10000010
10111010
10000010
10111010
10000010
DLG SPR_p
POS j 11,11

SPR 14
00011000
00111100
01000010
00101010
00000010
01000110
01111110
01111110
DLG SPR_q
POS j 14,12

SPR 15
00011000
00111100
00101010
00000010
00111110
00111110
00111110
00111110
DLG SPR_r
POS k 13,1

SPR 16
10010010
10010010
11110010
11010010
11110010
10010010
10010010
10010010
NAME ghost
DLG SPR_s
POS m 6,12

SPR 17
11110010
10010010
11110010
11010010
11110010
10010010
10010010
10010010
DLG SPR_t
POS m 10,13

SPR 18
00001000
00001000
00111100
01111110
01111110
01010010
00000010
01111110
DLG SPR_u
POS w 11,10

SPR 19
00111000
01111100
01000000
01010100
01000000
01100100
01111100
01111100
DLG SPR_v
POS v 14,2

SPR 21
00000000
00000000
00010000
00010100
00000100
01000001
01000000
00000000
POS z 9,9

SPR 22
00000000
00000000
00010000
00010100
00000100
01000001
01000000
00000000
POS z 5,9

SPR 23
00000000
00000000
00010000
00010100
00000100
01000001
01000000
00000000
POS z 6,9

SPR 24
00000000
00000000
00010000
00010100
00000100
01000001
01000000
00000000
POS z 8,9

SPR 25
00000000
00000000
00010000
00010100
00000100
01000001
01000000
00000000
POS z 10,9

SPR 27
00000000
00000000
00010000
00010100
00000100
01000001
01000000
00000000
POS z 8,6

SPR 28
00000000
00000000
00010000
00010100
00000100
01000001
01000000
00000000
POS z 7,6

SPR 29
00000000
00000000
00010000
00010100
00000100
01000001
01000000
00000000
POS z 5,6

SPR A
00000000
00011100
00111110
01111010
01101110
01111110
01111110
01111110
POS 15 7,11

SPR e
01011101
01000001
00111101
01000001
01011101
01000001
01011110
01000001
DLG SPR_3

SPR f
01011101
01000001
00111101
01000001
01011101
01000001
01011110
01000001
DLG SPR_4
POS 3 3,9

SPR g
00101010
01010010
01010111
01011000
01010000
00100000
00011111
00100000
DLG SPR_5
POS 3 7,8

SPR h
01010100
01001010
11101010
00011010
00001010
00000100
11000100
00000100
>
01010100
01001010
11101010
00011010
00001010
00000100
11010100
00000100
DLG SPR_7
POS 3 8,8

SPR i
00000000
00010000
00111100
01111110
00101010
00000010
01111110
01111110
DLG SPR_0
POS 2 14,7

SPR j
00000100
00010100
00000100
00011111
00001010
00000111
00011110
00001111
>
00000100
00000100
00100100
00011111
00001010
00100111
00001110
00001111
DLG SPR_1
POS 4 1,10

SPR k
00000000
00000000
00000000
00000000
00000000
00000000
11100000
10011000
DLG SPR_9
POS 4 11,9

SPR l
00000000
00000000
00000000
00000000
00000000
00000000
00011111
00100010
DLG SPR_8
POS 4 10,9

SPR m
00000000
00000000
00000000
00000000
00000000
00001110
00011111
01010101
DLG SPR_2
POS 4 12,9

SPR o
00111000
01111100
01010010
00000010
01111110
01111110
01111110
01111110
>
00111000
01111100
00101010
00000010
01111110
01111110
01111110
01111110
DLG SPR_a
POS 5 13,13

SPR p
01111111
00011000
00001000
00000000
00011100
00101010
00111110
00111110
>
01111111
00011000
00001000
00000000
00000000
00011100
00101010
00111110
DLG SPR_b
POS 7 5,7

SPR q
00001000
00001010
00001111
00001111
00001000
00001111
00011111
00011010
DLG SPR_c
POS 9 10,10

SPR r
00110000
01111100
11111111
01010010
00000010
01111110
01111110
01111110
DLG SPR_d
POS 8 12,11

SPR s
01010101
01000101
01111111
01010001
01010101
01010101
01111111
01000001
DLG SPR_e
POS 9 5,11

SPR t
00111110
01101101
01010010
01101101
01111111
10111110
00000000
11111111
DLG SPR_f
POS a 4,7

SPR u
11000001
10100100
11011010
10100100
10000000
11000001
11111111
11111111
DLG SPR_g
POS c 2,15

SPR v
00111110
01011011
00100101
01011011
01111111
00111110
00000000
00000000
DLG SPR_h
POS d 2,15

SPR w
00000100
00011111
00111111
01110111
01111111
01111111
10111111
00000000
NAME Whale
DLG SPR_i
POS a 6,10

SPR x
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Lock
DLG SPR_j
POS f 3,9

SPR y
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Map
DLG SPR_k
POS f 12,9

SPR z
00000000
00000000
11111100
00010110
01010111
01010111
11111110
01000110
DLG SPR_m
POS g 4,2

SPR 1a
10010010
10010010
11110010
11010010
11110010
10010010
10010010
10010010
NAME ghost2
DLG SPR_w
POS n 6,12

SPR 1b
10010010
10010010
11110010
11010010
11110010
10010010
10010010
10010010
NAME ghost3
DLG SPR_x
POS o 6,12

SPR 1c
10010010
10010010
11110010
11010010
11110010
10010010
10010010
10010010
NAME ghost4
DLG SPR_y
POS p 6,12

SPR 1d
10010010
10010010
11110010
11010010
11110010
10010010
10010010
10010010
NAME ghost5
DLG SPR_z
POS q 6,12

SPR 1e
10010010
10010010
11110010
11010010
11110010
10010010
10010010
10010010
NAME ghost6
DLG SPR_10
POS r 6,12

SPR 1f
10010010
10010010
11110010
11010010
11110010
10010010
10010010
10010010
NAME ghost7
DLG SPR_11
POS s 6,12

SPR 1g
10010010
10010010
11110010
11010010
11110010
10010010
10010010
10010010
NAME ghost8
DLG SPR_12
POS t 6,12

SPR 1h
10010010
10010010
11110010
11010010
11110010
10010010
10010010
10010010
NAME ghost9
DLG SPR_13
POS u 6,12

SPR 1i
10010010
10010010
11110010
11010010
11110010
10010010
10010010
10010010
NAME ghost10
DLG SPR_14
POS v 6,12

SPR 1j
00101010
00111110
01111110
01010100
01000000
01111110
01111110
01111110
NAME queen
DLG SPR_15
POS x 12,11

SPR 1k
01011111
01000000
01011001
01011001
01000010
01000100
01011001
01011001
NAME locked
DLG SPR_16
POS x 4,11

SPR 1l
00111110
01010101
01111111
01010101
01111111
01010101
01111111
01010101
POS z 7,8

SPR 1m
01111111
01111111
01111111
01111111
01111111
01111111
01111111
00111111
POS z 8,8

SPR 1n
10000000
10010000
00010100
00000101
00000000
01010101
11111111
11111111
POS z 8,7

SPR 1o
11111111
11111101
11101111
11111111
11111111
11111111
11111111
11111111
POS z 9,8

SPR 1p
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111110
POS z 10,8

SPR 1q
11111100
11111100
11111100
11111100
11111100
01010101
11111111
11111111
POS z 10,7

SPR 1r
00010001
01010001
01000101
00000001
00000001
01010101
11111111
11111111
POS z 9,7

SPR 1s
10101010
11111111
01111111
01101101
01111111
01111111
11111111
10000000
POS z 7,7

SPR 1t
00100011
01110011
01111011
00100011
00100011
11111111
11111111
11111111
POS z 6,8

SPR 1u
01111111
01111111
01111111
01111111
01010101
11111111
11111111
01111111
POS z 5,8

SPR 1v
00000000
10101010
11111111
01111111
01111111
01011011
01111111
01111111
POS z 5,7

SPR 1w
00000000
10010000
10010100
00000101
01000000
01000101
00000111
00000011
POS z 6,7

SPR 1x
00000000
00000000
10101010
11111110
11111100
11111100
01110100
11111100
POS z 10,6

SPR 1y
00000000
00000000
00010010
01010011
01000001
00000101
00000001
00000001
POS z 9,6

SPR 2a
00000000
00000000
00010000
00010100
00000100
01000001
01000000
00000000
POS z 6,6

SPR 2b
00000000
00011100
00111110
01111010
01011110
01111110
01100110
01111110
DLG SPR_17
POS z 9,14

SPR 2c
01111110
11111111
01111110
00110110
01111110
01111110
01111110
00000000
DLG SPR_18
POS z 15,1

SPR 2d
01111110
11111111
10001001
11111111
10010101
11111111
01111110
01000010
DLG SPR_19
POS z 1,13

SPR 2e
00000000
00000000
00000000
00111100
01000010
10011001
10111101
11011011
DLG SPR_1a
POS 11 6,10

SPR 2f
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00001000
DLG SPR_1b
POS 10 4,10

SPR 2g
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00001000
DLG SPR_1c
POS 11 9,10

SPR 2h
00000000
00011110
01111111
11011101
10001000
11011101
10111110
11111111
DLG SPR_1d
POS 12 5,10

SPR 2i
00000000
01111110
11111111
01111110
00110110
01111110
01111110
01111110
POS 13 14,10

SPR 2j
00000000
00011100
00111110
01111010
01011110
01111110
01100110
01111110
POS 13 2,10

SPR 2k
01010100
01111100
01111110
00101010
00000010
01111110
01111110
01111110
POS 13 15,14

SPR 2l
01001000
01111000
10101100
11111101
01111001
01111001
01111010
01111100
>
01001000
01111000
10101100
11111101
01111010
01111010
01111010
01111100
POS 13 15,10

SPR 2m
00000000
00000000
00111110
01011011
00100101
01011011
01111111
00111110
POS 13 11,10

SPR 2n
00011000
00111100
01000010
00101010
00000010
01000110
01111110
01111110
POS 13 13,10

SPR 2o
00000000
00000000
00000000
00000000
00011100
00101010
00111110
00111110
>
00000000
00000000
00000000
00000000
00000000
00011100
00101010
00111110
POS 13 3,9

SPR 2p
00000000
00000000
00111111
01010101
01010101
01010001
01111111
01010101
POS 13 9,9

SPR 2q
00000000
00000000
11111100
00010110
01010111
01010111
11111110
01000110
POS 13 10,9

SPR 2r
00000000
00011100
00111110
01101010
11111110
11111100
01111000
00000000
>
00000000
00000000
00111000
01111100
11010100
11111100
01111000
00000000
POS 13 11,9

SPR 2s
00000000
00000000
00111100
01111110
01111110
01001010
01000000
01111110
POS 13 5,10

SPR 2t
00000000
00011100
00111110
01111010
01011110
01111110
01100110
01111110
POS 14 13,12

SPR 2u
00000000
01111110
11111111
01111110
00110110
01111110
01111110
01111110
POS 14 11,12

SPR 2v
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
DLG SPR_1e
POS 16 11,10

SPR 2w
01000000
00000100
00111000
11000100
01010100
11000100
00111000
01000100
DLG SPR_1f
POS 16 4,10

SPR 2x
00101010
00111110
01111110
01010100
01000000
01111110
01111110
01111110
DLG SPR_1g
POS y 1,4

ITM 0
01111111
01110011
01100101
01101101
01110011
00111111
00011111
00000000
NAME eyeball
DLG ITM_0

ITM 1
10111111
00100001
10100101
10100001
00101101
00101101
10100001
10111111
NAME letter
DLG ITM_1

ITM 2
11111110
11011101
10101001
10101101
10101101
10101101
11011101
11111111
>
11111111
11011101
10101001
10101101
10101101
10101101
11011101
01111111
NAME passcode
DLG ITM_2

ITM 3
00111110
00100010
00111110
00100010
01111100
10001000
11111000
10111000
NAME scroll
DLG ITM_3

ITM 4
00000000
01111110
10011001
11001001
10000011
11100001
11111111
00000000
NAME gold
DLG ITM_4

ITM 5
00000000
00000000
00000110
00001001
01101001
10010110
10010000
01100000
NAME cufflink
DLG ITM_5

ITM 6
01111110
01000010
01011010
01000010
01010010
01000010
01000010
01111110
NAME queen letter
DLG ITM_6

ITM 7
00000000
00010000
00000000
01000100
00000000
00000000
00000000
00000100
>
00001000
00000000
00100100
00001010
10000100
00000000
00000000
00000000
DLG ITM_7

ITM 8
00001000
00000000
00100000
00000100
10000000
00000000
00000000
00000000
>
00000000
00010000
00000100
01001010
00000100
00000000
00000000
00000100
DLG ITM_8

ITM 9
00001000
00000000
00100000
00000100
10000000
00000000
00000000
00000000
>
00000000
00010000
00000100
01001010
00000100
00000000
00000000
00000100
DLG ITM_9

ITM a
00001000
00000000
00100000
00000100
10000000
00000000
00000000
00000000
>
00000000
00010000
00000100
01001010
00000100
00000000
00000000
00000100
DLG ITM_a

ITM b
00001000
00000000
00100000
00000100
10000000
00000000
00000000
00000000
>
00000000
00010000
00000100
01001010
00000100
00000000
00000000
00000100
DLG ITM_b

ITM c
00001000
00000000
00100000
00000100
10000000
00000000
00000000
00000000
>
00000000
00010000
00000100
01001010
00000100
00000000
00000000
00000100
DLG ITM_c

ITM d
00000000
00010000
00000000
01000000
11000000
00100000
00010000
00010000
>
00001000
00000000
00100000
00000000
11000000
00100000
00010000
00010000
NAME fruit
DLG ITM_d

ITM e
00000000
00000000
00000000
00111000
01001100
01000100
00111000
00000000
DLG ITM_e

ITM f
01111110
01000010
01011010
01000010
01010010
01000010
01000010
01111110
NAME greta letter
DLG ITM_f

DLG ITM_0
"""
You found the Eyeball of Communion.
Now it is possible to speak to shadows.
"""

DLG SPR_3
"""
The stacks are heavily encrypted.
You can't take out data without messing up the whole stack.
"""

DLG SPR_4
"""
The stacks are heavily encrypted.
You can't take out data without messing up the whole stack.
"""

DLG SPR_6
|{}[]|{}[]/\\ \\|||| }|{}{|}{}{><?><<|{}[]|{}[]/\\\\ ||||}|{}{|}{}{><?><<|{}[]|{} []/\\\\||||}|{}{|}{}{>< ?><<|{}[]|{}[]/\\\\||||}|{}{|}{}{><?><<

DLG SPR_5
"""
{
  - {item "passcode"} == 0 ?
    ENTER PASSCODE TO DE-ENCRYPT ARCHIVES...
    ...
    
    NO PASSCODE ENTERED... TRY AGAIN LATER...
  - {item "passcode"} == 1 ?
    ENTER PASSCODE TO DE-ENCRYPT ARCHIVES...
    ...
    
    PASSCODE ACCEPTED.
    
    ACCESSING DUNGEON BLUEPRINTS...
    
    ACQUIRING TRAVERSAL ROUTE...
    
    THIS IS THE DUNGEON TRAVERSAL ROUTE...FEEL FREE TO RECORD IT: 
    UP - LEFT - LEFT - DOWN - RIGHT - LEFT - UP - DOWN - RIGHT - {shk}ERR{shk}
    LAST TURN CORRUPTED... SORRY

}
"""

DLG SPR_1
"""
It's raining hard outside. 
Ugh, this place is so drafty!
"""

DLG SPR_2
"""
{
  - {item "eyeball"} == 0 ?
    ...
    
    ...
    
    ...
  - {item "eyeball"} == 1 ?
    Ahh, I see you have the Eyeball of Communion.
    The roast ham beside me looks pretty good. 
    But what really catches my eye is this covered painting here.
    What horror could possibly be hiding under that burlap sheet?
    The allure of mystery...
}
"""

DLG SPR_8
A giant, dense, and glistening hunk of ham. It is still warm.

DLG SPR_9
A giant, dense, and glistening hunk of ham. It is still warm.

DLG SPR_a
"""
{
  - {item "eyeball"} == 0 ?
    ...
    
    ...
    
    ...
    
    (It seems to be gesturing to the opposite wall.)
  - {item "eyeball"} == 1 ?
    Ahh, I see you have the Eyeball of Communion...
    Now, you may speak freely with us, the Shadows.
    You might be surprised by how much we have to say!
}
"""

DLG SPR_b
"""
Hi, I'm just a kitchen ghoul...

Downstairs is the wine cellar. It's kind of scary.
Upstairs is the West Parapet. It's where the King lives.
You have to take the dumbwaiter up, since the door's locked.
I'm content staying right here!
"""

DLG ITM_1
You picked up the King's Letter.

DLG SPR_0
"""
{
  - {item "eyeball"} == 0 ?
    ...
    
    ...
    
    ...
  - {item "eyeball"} == 1 ?
    Ahh, I see you have the Eyeball of Communion...
    These relics beside me are sentimental heirlooms.
    The "S" on the shield presumably stands for "Seaborg".
    Don't worry, I won't pilfer them. 
    Hahahahah!
}
"""

DLG SPR_d
"""
{
  - {item "eyeball"} == 0 ?
    ...
    
    ...
    
    ...
  - {item "eyeball"} == 1 ?
    Ahh, I see you have the Eyeball of Communion...
    The King's history with his wife is a sad tale.
    However, his spin on it may not be entirely true...
    I'd suggest that you seek out the Queen, in the East Parapet.
    If you want to escape the Manor, you should pay her a visit.
    She's made it very difficult to get to her, though. Good luck!
}
"""

DLG SPR_e
A bookcase has been put in front of the door, blocking the way.

DLG SPR_f
"""
{
  - {item "passcode"} == 0 ?
    Hi...
    
    I'm the Manor Architect.
    
    I didn't know anyone was gonna come here...
    I feel like you might need my blueprints for something.
    If that's the case, you're out of luck.
    They're all heavily encrypted in the Castle Archives.
    But...
    
    There is a way to unencrypt the archives:
    You have to put in a passcode.
    
    But...
    
    The passcode is in my Quantum Bag, down in the pool.
    And I can't swim!
    
    You'll have to get it yourself...
  - {item "passcode"} == 1 ?
    You got the code?
    
    The archives are in the West Cut of the Manor.
    As well as containing the blueprints for the whole manor,
    they contain the blueprints for the ever-changing dungeon.
    It's said that there's quite a treasure at the end of it.
    But that's just a rumor!
    
    Oh...
    
    Did you meet my brother?
    
    We shall not speak of him.
    (The architect glances away.)
}
"""

DLG ITM_2
"""
You got the Archives Passcode!
It says: Seaborg12345
To exit the Quantum Bag, take two steps North.
"""

DLG SPR_g
"""
{sequence
  - Hello. I am the Manor Architect's brother.
    He trapped me in his Quantum Bag as punishment for my sins.
    I'd love to leave, but if I did, I'd die instantly.
    My body has become too used to existing in this quantum space.
    Here, there is no up or down, and the walls deceive you.
    My special glasses break the deception. Use them wisely.
  - My brother sent me here because I tried to defy him.
    In the physical world, I was evil and conniving.
    I wanted every cent for myself, and I betrayed my brother.
    But in the end, his tricks triumphed, trapping me here.
    I will not go into more detail.
  - It's pretty boring here, but I get used to it.
}
"""

DLG SPR_h
"""
Do you see the path?

Take a screenshot, if you want.
"""

DLG SPR_i
"""
I love to swim in the pool.

Did you know that the pool is also a greenhouse?
"""

DLG SPR_k
"""
-MANOR MAP-

Great Hall: you are here.

West Wing

West F1: Banquet Hall, Kitchen

West B1: Wine Cellar

West F2: Castle Archives

West F3: King's Suite

East Wing

East F1: Courtyard, Dungeon Entrance, Graveyard
East B1-B???: Grand Dungeon

East F2: Pool

East F3: Queen's Suite
"""

DLG SPR_l
"""
The books on this shelf are each labelled with a single letter.
Opening the one that says "G", you find the following passage:
"GgggGGGggggggggggGGGGgggggggggGgGGGGGGGggGGGGGGGGGGGGggGGGgGG"

You close the book.

There are 26 books on the shelf.
"""

DLG SPR_m
"""
The books on this shelf are each labelled with a single number.
Opening the one that says "120", you find the following passage:
"120120120120120120120120120120120120120120120120120120120120"

You close the book.

There are infinite books on the shelf.
"""

DLG SPR_n
"""
{sequence
  - Hi, I'm just a book ghoul...
    
    Unlike a lot of old castles, there aren't many books here.
    Everything's digitally archived, as you may have noticed.
    The bookshelf here is the only one in the manor.
    The king feared that without a physical archive of every letter and number, the language we speak would cease to exist.
    I'm here to make sure nobody destroys the books.
    If that happened, I'd be in a lot of trouble.
  - Actually, there is another bookshelf in the castle.
    It contains books of all the punctuation in the alphabet.
    It is in the King's Suite.
  - If we don't remember our language, who will?
}
"""

DLG SPR_p
"""
This exceedingly long tombstone reads:
"The last will and testament of Charles Seaborg III..."
Skipping down, you read:

"V. My immense wealth of gold coins, which I love most dearly,  is buried in the dungeon.

I will allow it to be unburied 100 years after my passing.
The coins are hidden in the 5th room of the dungeon.
There is a fake floor that can be walked through to get them."
Buried in 1920... that means it's okay to steal his treasure.
"""

DLG SPR_q
"""
{
  - {item "eyeball"} == 0 ?
    ...
    
    ...
    
    ...
  - {item "eyeball"} == 1 ?
    Ahh, I see you have the Eyeball of Communion...
    I am the Undertaking Shadow.
    
    I undertake this job because someone has to do it!
    In this plot, the four Seaborg elders are buried.
    They are the greatest of the Seaborg line.
    There's the first Seaborg that rose to power, Dotto Seaborg.
    Then there's the warlord Giuseppe Seaborg, who singlehandedly conquered all of Prussia in the 1400s.
    There's Charles Seaborg III, who amassed incredible riches.
    And finally, there's Osiris Seaborg, a Hollywood movie star.
    In the end, they all ended up 6 feet under.
}
"""

DLG SPR_7
"""
{
  - {item "passcode"} == 0 ?
    ENTER PASSCODE TO DE-ENCRYPT ARCHIVES...
    ...
    
    NO PASSCODE ENTERED... TRY AGAIN LATER...
  - {item "passcode"} == 1 ?
    ENTER PASSCODE TO DE-ENCRYPT ARCHIVES...
    ...
    
    PASSCODE ACCEPTED.
    
    ACCESSING DUNGEON BLUEPRINTS...
    
    ACQUIRING TRAVERSAL ROUTE...
    
    THIS IS THE DUNGEON TRAVERSAL ROUTE...FEEL FREE TO RECORD IT: 
    UP - LEFT - LEFT - DOWN - RIGHT - LEFT - UP - DOWN - RIGHT - {shk}ERR{shk}
    LAST TURN CORRUPTED... SORRY

}
"""

DLG SPR_r
"""
{
  - {item "eyeball"} == 0 ?
    ...
    
    ...
    
    ...
  - {item "eyeball"} == 1 ?
    Ahh, I see you have the Eyeball of Communion...
    The stairs here are so old that they collapsed.
    Fortunately, someone constructed a scaffold.
    The Queen's Suite is right up ahead. Watch where you step.
}
"""

DLG SPR_s
"""
{
  - {item "cufflink"} == 0 ?
    Who am I? I've been in here too long, and I forgot my name.
    If you could go to the trouble of finding my name,
    I would greatly appreciate it.
  - {item "cufflink"} == 1 ?
    {sequence
      - Ahh, those are my cufflinks, I know that much.
        Let me see...
        
        Oh, E. Guzman. That must be my name.
        Now I can exit this world...
      - ...
    }
}
"""

DLG SPR_t
"""
There is a note on the prison cell door:
"{wvy}Sorry, dead.{wvy}"
"""

DLG ITM_3
"""
There is a long scroll here. It reads:


Day 1
I have been hereby interned for my crimes against House Seaborg. There is no hope in sight for me; release of prisoners from the Seaborg dungeon is unheard of.

Day 9
I have subsisted on drops of water from ceiling mold for an unknowable amount of time. In truth, I don't know what day it is, as no light penetrates the depths of the dungeon. By my best guess, it's my 9th day.
Day 14?
I have not seen a single soul this entire time. Assuredly, there must be some kind of jailer. I hear the ghostly moans of the other prisoners, who are long dead themselves. How much longer until I join their ranks?
Day ???
My dearest Eliza Seaborg,
I now know for certain that I shall die here. Our love was never meant to be. How could a lowly peasant such as myself love a Queen of House Seaborg? The ghosts tell me that you and the King have separated. If you somehow receive this letter, you must know one thing: even in death, I love you.
...

The rest of the scroll is blank and damp. {letter = 1}
"""

DLG SPR_u
"""
{
  - {item "eyeball"} == 0 ?
    ...
    
    ...
    
    ...
  - {item "eyeball"} == 1 ?
    {wvy}Boo!{wvy}
    
    Did I scare you?
    
    Sorry, I meant "Ahh, I see you have the Eyeball of Communion."
    I'm practicing my severed head impression.
    Don't worry, I'm not the ghost of Giuseppe Seaborg.
    But if I was, I wouldn't want you messing around in my tomb!
    You probably came from the dungeon.
    If you're stuck, I suggest consulting the architect.
    He built the whole manor, including the dungeon.
    These days, he hangs out at the pool.
}
"""

DLG ITM_4
"""
You found the buried treasure of Charles Seaborg III!
There's hundreds of gold coins in the chest...
"""

DLG ITM_5
"""
Embroidered cufflinks lie on the ground.
They are stitched with a name:

"E. Guzman"

You take the cufflinks.
"""

DLG SPR_v
"""
{
  - {item "eyeball"} == 0 ?
    ...
    
    ...
    
    ...
  - {item "eyeball"} == 1 ?
    AHH, I SEE YOU HAVE THE EYEBALL OF COMMUNION...
    I....
    
    AM THE SECOND UNDERTAKER...
    
    YOU NEED...
    
    TO GO...
    
    {shk}UP...{shk}
}
"""

DLG SPR_w
"""
{
  - {item "cufflink"} == 0 ?
    Who am I? I've been in here too long, and I forgot my name.
    If you could go to the trouble of finding my name,
    I would greatly appreciate it.
  - {item "cufflink"} == 1 ?
    {sequence
      - Ahh, those are my cufflinks, I know that much.
        Let me see...
        
        Oh, E. Guzman. That must be my name.
        Now I can exit this world...
      - ...
    }
}
"""

DLG SPR_x
"""
{
  - {item "cufflink"} == 0 ?
    Who am I? I've been in here too long, and I forgot my name.
    If you could go to the trouble of finding my name,
    I would greatly appreciate it.
  - {item "cufflink"} == 1 ?
    {sequence
      - Ahh, those are my cufflinks, I know that much.
        Let me see...
        
        Oh, E. Guzman. That must be my name.
        Now I can exit this world...
      - ...
    }
}
"""

DLG SPR_y
"""
{
  - {item "cufflink"} == 0 ?
    Who am I? I've been in here too long, and I forgot my name.
    If you could go to the trouble of finding my name,
    I would greatly appreciate it.
  - {item "cufflink"} == 1 ?
    {sequence
      - Ahh, those are my cufflinks, I know that much.
        Let me see...
        
        Oh, E. Guzman. That must be my name.
        Now I can exit this world...
      - ...
    }
}
"""

DLG SPR_z
"""
{
  - {item "cufflink"} == 0 ?
    Who am I? I've been in here too long, and I forgot my name.
    If you could go to the trouble of finding my name,
    I would greatly appreciate it.
  - {item "cufflink"} == 1 ?
    {sequence
      - Ahh, those are my cufflinks, I know that much.
        Let me see...
        
        Oh, E. Guzman. That must be my name.
        Now I can exit this world...
      - ...
    }
}
"""

DLG SPR_10
"""
{
  - {item "cufflink"} == 0 ?
    Who am I? I've been in here too long, and I forgot my name.
    If you could go to the trouble of finding my name,
    I would greatly appreciate it.
  - {item "cufflink"} == 1 ?
    {sequence
      - Ahh, those are my cufflinks, I know that much.
        Let me see...
        
        Oh, E. Guzman. That must be my name.
        Now I can exit this world...
      - ...
    }
}
"""

DLG SPR_11
"""
{
  - {item "cufflink"} == 0 ?
    Who am I? I've been in here too long, and I forgot my name.
    If you could go to the trouble of finding my name,
    I would greatly appreciate it.
  - {item "cufflink"} == 1 ?
    {sequence
      - Ahh, those are my cufflinks, I know that much.
        Let me see...
        
        Oh, E. Guzman. That must be my name.
        Now I can exit this world...
      - ...
    }
}
"""

DLG SPR_12
"""
{
  - {item "cufflink"} == 0 ?
    Who am I? I've been in here too long, and I forgot my name.
    If you could go to the trouble of finding my name,
    I would greatly appreciate it.
  - {item "cufflink"} == 1 ?
    {sequence
      - Ahh, those are my cufflinks, I know that much.
        Let me see...
        
        Oh, E. Guzman. That must be my name.
        Now I can exit this world...
      - ...
    }
}
"""

DLG SPR_13
"""
{
  - {item "cufflink"} == 0 ?
    Who am I? I've been in here too long, and I forgot my name.
    If you could go to the trouble of finding my name,
    I would greatly appreciate it.
  - {item "cufflink"} == 1 ?
    {sequence
      - Ahh, those are my cufflinks, I know that much.
        Let me see...
        
        Oh, E. Guzman. That must be my name.
        Now I can exit this world...
      - ...
    }
}
"""

DLG SPR_14
"""
{
  - {item "cufflink"} == 0 ?
    Who am I? I've been in here too long, and I forgot my name.
    If you could go to the trouble of finding my name,
    I would greatly appreciate it.
  - {item "cufflink"} == 1 ?
    {sequence
      - Ahh, those are my cufflinks, I know that much.
        Let me see...
        
        Oh, E. Guzman. That must be my name.
        Now I can exit this world...
      - ...
    }
}
"""

DLG SPR_15
"""
{
  - {item "letter"} == 1 ?
    {sequence
      - I've seen you, scrambling around my manor.
        I know exactly how and why you came up here.
        Now, let me see your letter...
        
        ...
        
        Yes, the usual. Even if the King could write the perfect letter,
        I still could never love him.
        
        I have turned into a Shadow. My soul can no longer feel emotion.
        Take the letter over on the left to the King.
      - Leave me... allow me to contemplate the rain.
        ...Oh, is the door locked?  Walk off the edge instead.
    }
  - {item "letter"} == 0 ?
    {sequence
      - I've seen you, scrambling around my manor.
        For now, you have nothing that I need.
        You should speak to the King of this castle.
        Perhaps he would be more hospitable than I.
      - ...Oh, is the door locked?  Walk off the edge instead.
    }
}
"""

DLG SPR_16
Locked.

DLG ITM_6
You picked up the Queen's Letter.

DLG ITM_7
Somehow, you're walking in the air.

DLG ITM_8
You are stepping on the raindrops as they fall.

DLG ITM_9
This really has been an unusual day for you.

DLG ITM_a
Anyway, it's time for you to come down...

DLG ITM_b
Are you awake, or are you dreaming?

DLG ITM_c
In here, is there a difference?

DLG ITM_d
You got a chunk of the tree's bulb.

DLG SPR_o
"""
{
  - {item "fruit"} == 0 ?
    {sequence
      - Hello.
        
        All you need to know about me is that I'm an exotic cat.
        I've been eyeing this tree for quite some time.
        When the tree is fully grown, it bears a large bulb.
        This bulb is very delicious!
        
        It seems that the bulb has come into blossom.
        However, I can't get the bulb, and neither can you.
        Looks like we're useless to each other.
      - Looks like we're useless to each other.
    }
  - {item "fruit"} == 1 ?
    {sequence
      - I...
        What?
        How did you...
        
        Never mind. Can I have some of your fruit?
        (Crunch, munch)
        
        Well, that tastes very good. Let me tell you a secret.
        The shadows you see lurking throughout the castle...
        Once, they were people.
        
        Castle guests, court charlatans, dukes, duchesses...
        As time passed, they turned recluse.
        Their eyes changed. They began to transcend our world.
        They are all fully aware of their pasts and histories.
        They stay in the manor still. What for?
        Are they bound to their spots, or do they just like the place?
        We'll never find out. Shadows only communicate to outsiders
        via small-talk.
        
        Speaking of which, I think you should leave.
      - Hmmm... that bulb was very good.
    }
}
"""

DLG SPR_c
"""
{
  - {item "queen letter"} == 0 ?
    {sequence
      - {shk}Waaaah...{shk}
        
        Oh, you can just leave the food on the table...
        Oh...
        
        Sorry, you aren't who I thought you were.
        ...
        
        So, you're young Seaborg? And you've inherited my manor?
        I guess the lawyers didn't know I was still around...
        I'm Old King Seaborg. You must be one of my descendants.
        I've been cooped up in this room for who knows how long.
        The world turns around me while I stand still.
        ...
        
        Oh, you want to escape? Figures. Nobody wants to stay here long.
        I'll tell you what: I'll give you the key to the front gate...
        If you deliver this letter.
        
        My wife, the Queen, lives in the East Parapet.
        Every day, I long for her to love me again.
        Take my letter to her. I'm too scared to do it myself.
        Now go! Begone from my sight, and let me wallow in my sorrow!
      - {shk}Waaaah...{shk}
    }
  - {item "queen letter"} == 1 ?
    {sequence
      - She wrote a letter to me this time?
        Let me see...
        
        It seems that she's turned into a shadow.
        There's nothing that can be done for me now...
        But you can still carry on, young Seaborg.
        I give you the key to the manor gate.
        {key = 1}There... there you go. The world is yours, kid.
      - {wvy}zzz...{wvy}
    }
}
"""

DLG SPR_j
"""
{
  - key == 0 ?
    The gate is firmly sealed by a device.
    However, there is a keyhole on the side of the mechanism.
  - key == 1 ?
    You put the key in the keyhole.
    (exit "neighborhood,7,9")
}
"""

DLG SPR_17
"""
{sequence
  - Hey man, got a dollar?
    
    ...
    
    Alright then, screw you pal.
  - (Stuck up prick...)
}
"""

DLG ITM_e
Got a crushed soda can.

DLG SPR_18
"""
{sequence
  - This neighborhood is the pits.
    
    Nobody ever moves in or out of this awful place.
    Just project house after project house... and a god-damn castle.
    Hell on earth!
  - Empty lots and dead ends...
}
"""

DLG SPR_19
"""
{clr3}Evil A$ Bank{clr3}
{clr1}"We buy gold!"{clr1}
{clr2}2 blocks thataway...{clr2}
{wvy}-->{wvy}
"""

DLG SPR_1a
"""
{
  - {item "gold"} == 0 ?
    Good afternoon :)
    Welcome to Evil Ass Bank :)
    "We own your ass!" :)
    ...
    Oh you must be Mr. Seaborg :)
    You got an invoice...
    It's from your aunt Greta.
    It says:
    "Seaborg, you know I've always wanted to own the manor.
    I don't care if Grandpa Osiris left his estate to you, I'm having the bank repossess it for me to keep!
    Try me in court, bitch. If you want the manor back, it'll burn a $2 million hole in your pocket!
    ~Signed, Greta Seaborg"
    
    Sorry, but we're making your ass homeless :)
    Tough luck buddy :)
    (exit "bad end,9,12")
  - {item "gold"} == 1 ?
    Good afternoon :)
    Welcome to Evil Ass Bank :)
    "We own your ass!" :)
    ...
    Oh you must be Mr. Seaborg :)
    You got an invoice...
    It's from your aunt Greta.
    It says:
    "Seaborg, you know I've always wanted to own the manor.
    I don't care if Grandpa Osiris left his estate to you, I'm having the bank repossess it for me to keep!
    Try me in court, bitch. If you want the manor back, it'll burn a $2 million hole in your pocket!
    ~Signed, Greta Seaborg"
    Tough luck bud-
    ...
    Wait, what did you say?
    
    You have {shk}how many{shk} gold coins?
    And you're buying the estate back?
    Ah shit {wvy}:){wvy}
    (exit "good end,7,10")
}
"""

DLG SPR_1b
"Abandon all hope, ye who enter here."

DLG SPR_1c
"Employees only"

DLG SPR_1d
"""
{sequence
  - Hey there youngster. Kin I git you anything?
    ...
    
    Alright, coming right up...
    
    ...
    
    Here.
    
    You know, I've been working this bar fer 52 years an' I ain never seen someone with your kind of attitude walk in.
    You look too well-off to be from these parts.
    The whole city's just gone on down the drain.
    This whole ward was built around that ancient castle out back.
    Nowerdays, the castle sticks out like a sore thumb.
    Don't nobody know what to do next.
    ...
    
    Wait er minute. You're one of those Seaborg folks! Your family's the whole darn reason we're in the mess in the first place!
    
    Money-grubbing POS... git on out of here before I make ye!
  - Git the hell out! I don't ever want to see yer face again!
}
"""

DLG ITM_f
"""
To my nephew Seaborg,

As I'm sure you are aware, your wealthy great-uncle Osiris Seaborg recently passed as of this December. His grand estate, consisting of a castle from the 12th century, has been granted not to me, his rightful heir, but to you, the youngest member of the Seaborg line. If grandpa was still alive, I'd most certainly contest his decision, but his will is his will. You shall move into your new residence on short notice.
Signed, Greta Seaborg
"""

DLG SPR_1e
"""
SLAM!
(exitNow "Great Hall,10,10")

The gate slammed down behind you, trapping you in the manor!
"""

DLG SPR_1f
"""
SLAM!
(exitNow "Great Hall,5,10")

The gate slammed down behind you, trapping you in the manor!
"""

DLG SPR_1g
"""
{
  - letter == 0 ?
    You don't have anything that I need. Disregard me, Seaborg.
  - letter == 1 ?
    {sequence
      - The nature of this meeting is not important. You have something I need.
        
        Let me see the scroll you have there...
        
        
        ...
        
        So, he still loved me after all that time...
        I wonder where he is now?
      - How strange it is to feel emotions...
    }
}
"""

END 0
{wvy}Fin{wvy}

END 1
{wvy}Fin{wvy}

END 2
{wvy}Fin{wvy}

END 3
{wvy}Fin{wvy}

END 4
{wvy}Fin{wvy}

END 5
{wvy}Fin{wvy}

END 6
{wvy}Fin{wvy}

END 7
{wvy}Fin{wvy}

VAR key
0

VAR letter
0


</script>

<style>
html {
	margin:0px;
	padding:0px;
}

body {
	margin:0px;
	padding:0px;
	overflow:hidden;
	background:#000;
}

#game {
	background:black;
	width:100vw;
	max-width:100vh;
	margin:auto;
	display:block;
	touch-action: none; /* fixing touch-input errors in chrome */

	/* sharp pixel edges */
	/* https://caniuse.com/#search=image-render */
  	-ms-interpolation-mode: nearest-neighbor; /* IE */
  	image-rendering: -moz-crisp-edges; /* FF 6.0+ */
  	image-rendering: pixelated; /* Chrome, Safari */
}

</style>

<!-- SCRIPTS -->
<script>
function startExportedGame() {
	attachCanvas( document.getElementById("game") );
	load_game( document.getElementById("exportedGameData").text.slice(1) );
}
</script>

<script>
//hex-to-rgb method borrowed from stack overflow
function hexToRgb(hex) {
	// Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
	var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
	hex = hex.replace(shorthandRegex, function(m, r, g, b) {
		return r + r + g + g + b + b;
	});

	var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
	return result ? {
		r: parseInt(result[1], 16),
		g: parseInt(result[2], 16),
		b: parseInt(result[3], 16)
	} : null;
}
function componentToHex(c) {
    var hex = c.toString(16);
    return hex.length == 1 ? "0" + hex : hex;
}
function rgbToHex(r, g, b) {
    return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
}

function hslToHex(h,s,l) {
    var rgbArr = hslToRgb(h,s,l);
    return rgbToHex( Math.floor(rgbArr[0]), Math.floor(rgbArr[1]), Math.floor(rgbArr[2]) );
}

function hexToHsl(hex) {
    var rgb = hexToRgb(hex);
    return rgbToHsl(rgb.r, rgb.g, rgb.b);
}

// really just a vector distance
function colorDistance(a1,b1,c1,a2,b2,c2) {
    return Math.sqrt( Math.pow(a1 - a2, 2) + Math.pow(b1 - b2, 2) + Math.pow(c1 - c2, 2) );
}

function hexColorDistance(hex1,hex2) {
    var color1 = hexToRgb(hex1);
    var color2 = hexToRgb(hex2);
    return rgbColorDistance(color1.r, color1.g, color1.b, color2.r, color2.g, color2.b);
}


// source : http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c
/* accepts parameters
 * h  Object = {h:x, s:y, v:z}
 * OR 
 * h, s, v
*/
function HSVtoRGB(h, s, v) {
    var r, g, b, i, f, p, q, t;
    if (arguments.length === 1) {
        s = h.s, v = h.v, h = h.h;
    }
    i = Math.floor(h * 6);
    f = h * 6 - i;
    p = v * (1 - s);
    q = v * (1 - f * s);
    t = v * (1 - (1 - f) * s);
    switch (i % 6) {
        case 0: r = v, g = t, b = p; break;
        case 1: r = q, g = v, b = p; break;
        case 2: r = p, g = v, b = t; break;
        case 3: r = p, g = q, b = v; break;
        case 4: r = t, g = p, b = v; break;
        case 5: r = v, g = p, b = q; break;
    }
    return {
        r: Math.round(r * 255),
        g: Math.round(g * 255),
        b: Math.round(b * 255)
    };
}

/* accepts parameters
 * r  Object = {r:x, g:y, b:z}
 * OR 
 * r, g, b
*/
function RGBtoHSV(r, g, b) {
    if (arguments.length === 1) {
        g = r.g, b = r.b, r = r.r;
    }
    var max = Math.max(r, g, b), min = Math.min(r, g, b),
        d = max - min,
        h,
        s = (max === 0 ? 0 : d / max),
        v = max / 255;

    switch (max) {
        case min: h = 0; break;
        case r: h = (g - b) + d * (g < b ? 6: 0); h /= 6 * d; break;
        case g: h = (b - r) + d * 2; h /= 6 * d; break;
        case b: h = (r - g) + d * 4; h /= 6 * d; break;
    }

    return {
        h: h,
        s: s,
        v: v
    };
}

// source : https://gist.github.com/mjackson/5311256
/**
 * Converts an HSL color value to RGB. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Assumes h, s, and l are contained in the set [0, 1] and
 * returns r, g, and b in the set [0, 255].
 *
 * @param   Number  h       The hue
 * @param   Number  s       The saturation
 * @param   Number  l       The lightness
 * @return  Array           The RGB representation
 */
function hslToRgb(h, s, l) {
  var r, g, b;

  if (s == 0) {
    r = g = b = l; // achromatic
  } else {
    function hue2rgb(p, q, t) {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    }

    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;

    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }

  return [ r * 255, g * 255, b * 255 ];
}

/**
 * From: http://stackoverflow.com/questions/2353211/hsl-to-rgb-color-conversion
 *
 * Converts an RGB color value to HSL. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Assumes r, g, and b are contained in the set [0, 255] and
 * returns h, s, and l in the set [0, 1].
 *
 * @param   {number}  r       The red color value
 * @param   {number}  g       The green color value
 * @param   {number}  b       The blue color value
 * @return  {Array}           The HSL representation
 */
function rgbToHsl(r, g, b){
    r /= 255, g /= 255, b /= 255;
    var max = Math.max(r, g, b), min = Math.min(r, g, b);
    var h, s, l = (max + min) / 2;

    if(max == min){
        h = s = 0; // achromatic
    }else{
        var d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch(max){
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }

    return [h, s, l];
}
</script>

<script>
var TransitionManager = function() {
	var transitionStart = null;
	var transitionEnd = null;
	var effectImage = null;

	var isTransitioning = false;
	var transitionTime = 0; // milliseconds
	var frameRate = 8; // cap the FPS
	var prevStep = -1; // used to avoid running post-process effect constantly

	this.BeginTransition = function(startRoom,startX,startY,endRoom,endX,endY,effectName) {
		// console.log("--- START ROOM TRANSITION ---");

		curEffect = effectName;

		var tmpRoom = player().room;
		var tmpX = player().x;
		var tmpY = player().y;

		if (transitionEffects[curEffect].showPlayerStart) {
			player().room = startRoom;
			player().x = startX;
			player().y = startY;
		}
		else {
			player().room = "_transition_none"; // kind of hacky!!
		}

		drawRoom(room[startRoom]);
		var startPalette = getPal( room[startRoom].pal );
		var startImage = new PostProcessImage( ctx.getImageData(0,0,canvas.width,canvas.height) ); // TODO : don't use global ctx?
		transitionStart = new TransitionInfo(startImage, startPalette, startX, startY);

		if (transitionEffects[curEffect].showPlayerEnd) {
			player().room = endRoom;
			player().x = endX;
			player().y = endY;
		}
		else {
			player().room = "_transition_none";
		}

		drawRoom(room[endRoom]);
		var endPalette = getPal( room[endRoom].pal );
		var endImage = new PostProcessImage( ctx.getImageData(0,0,canvas.width,canvas.height) );
		transitionEnd = new TransitionInfo(endImage, endPalette, endX, endY);

		effectImage = new PostProcessImage( ctx.createImageData(canvas.width,canvas.height) );

		isTransitioning = true;
		transitionTime = 0;
		prevStep = -1;

		player().room = tmpRoom;
		player().x = tmpX;
		player().y = tmpY;
	}

	this.UpdateTransition = function(dt) {
		if (!isTransitioning) {
			return;
		}

		transitionTime += dt;

		var transitionDelta = transitionTime / transitionEffects[curEffect].duration;
		var maxStep = Math.floor(frameRate * (transitionEffects[curEffect].duration / 1000));
		var step = Math.floor(transitionDelta * maxStep);

		if (step != prevStep) {
			// console.log("step! " + step + " " + transitionDelta);
			for (var y = 0; y < effectImage.Height; y++) {
				for (var x = 0; x < effectImage.Width; x++) {
					var color = transitionEffects[curEffect].pixelEffectFunc(transitionStart,transitionEnd,x,y,(step / maxStep));
					effectImage.SetPixel(x,y,color);
				}
			}
		}
		prevStep = step;

		ctx.putImageData(effectImage.GetData(), 0, 0);

		if (transitionTime >= transitionEffects[curEffect].duration) {
			isTransitioning = false;
			transitionTime = 0;
			transitionStart = null;
			transitionEnd = null;
			effectImage = null;
			prevStep = -1;
		}
	}

	this.IsTransitionActive = function() {
		return isTransitioning;
	}

	var transitionEffects = {};
	var curEffect = "none";
	this.RegisterTransitionEffect = function(name, effect) {
		transitionEffects[name] = effect;
	}

	this.RegisterTransitionEffect("none", {
		showPlayerStart : false,
		showPlayerEnd : false,
		pixelEffectFunc : function() {},
	});

	this.RegisterTransitionEffect("fade_w", { // TODO : have it linger on full white briefly?
		showPlayerStart : false,
		showPlayerEnd : true,
		duration : 750,
		pixelEffectFunc : function(start,end,pixelX,pixelY,delta) {
			var pixelColorA = delta < 0.5 ? start.Image.GetPixel(pixelX,pixelY) : {r:255,g:255,b:255,a:255};
			var pixelColorB = delta < 0.5 ? {r:255,g:255,b:255,a:255} : end.Image.GetPixel(pixelX,pixelY);

			delta = delta < 0.5 ? (delta / 0.5) : ((delta - 0.5) / 0.5); // hacky

			return PostProcessUtilities.LerpColor(pixelColorA, pixelColorB, delta);
		}
	});

	this.RegisterTransitionEffect("fade_b", {
		showPlayerStart : false,
		showPlayerEnd : true,
		duration : 750,
		pixelEffectFunc : function(start,end,pixelX,pixelY,delta) {
			var pixelColorA = delta < 0.5 ? start.Image.GetPixel(pixelX,pixelY) : {r:0,g:0,b:0,a:255};
			var pixelColorB = delta < 0.5 ? {r:0,g:0,b:0,a:255} : end.Image.GetPixel(pixelX,pixelY);

			delta = delta < 0.5 ? (delta / 0.5) : ((delta - 0.5) / 0.5); // hacky

			return PostProcessUtilities.LerpColor(pixelColorA, pixelColorB, delta);
		}
	});

	this.RegisterTransitionEffect("wave", {
		showPlayerStart : true,
		showPlayerEnd : true,
		duration : 1500,
		pixelEffectFunc : function(start,end,pixelX,pixelY,delta) {
			var waveDelta = delta < 0.5 ? delta / 0.5 : 1 - ((delta - 0.5) / 0.5);

			var offset = (pixelY + (waveDelta * waveDelta * 0.2 * start.Image.Height));
			var freq = 4;
			var size = 2 + (14 * waveDelta);
			pixelX += Math.floor(Math.sin(offset / freq) * size);

			if (pixelX < 0) {
				pixelX += start.Image.Width;
			}
			else if (pixelX >= start.Image.Width) {
				pixelX -= start.Image.Width;
			}

			var curImage = delta < 0.5 ? start.Image : end.Image;
			return curImage.GetPixel(pixelX,pixelY);
		}
	});

	this.RegisterTransitionEffect("tunnel", {
		showPlayerStart : true,
		showPlayerEnd : true,
		duration : 1500,
		pixelEffectFunc : function(start,end,pixelX,pixelY,delta) {
			if (delta <= 0.4) {
				var tunnelDelta = 1 - (delta / 0.4);

				var xDist = start.PlayerCenter.x - pixelX;
				var yDist = start.PlayerCenter.y - pixelY;
				var dist = Math.sqrt((xDist * xDist) + (yDist * yDist));

				if (dist > start.Image.Width * tunnelDelta) {
					return {r:0,g:0,b:0,a:255};
				}
				else {
					return start.Image.GetPixel(pixelX,pixelY);
				}
			}
			else if (delta <= 0.6)
			{
				return {r:0,g:0,b:0,a:255};
			}
			else {
				var tunnelDelta = (delta - 0.6) / 0.4;

				var xDist = end.PlayerCenter.x - pixelX;
				var yDist = end.PlayerCenter.y - pixelY;
				var dist = Math.sqrt((xDist * xDist) + (yDist * yDist));

				if (dist > end.Image.Width * tunnelDelta) {
					return {r:0,g:0,b:0,a:255};
				}
				else {
					return end.Image.GetPixel(pixelX,pixelY);
				}
			}
		}
	});

	this.RegisterTransitionEffect("slide_u", {
		showPlayerStart : false,
		showPlayerEnd : true,
		duration : 1000,
		pixelEffectFunc : function(start,end,pixelX,pixelY,delta) {
			var pixelOffset = -1 * Math.floor(start.Image.Height * delta);
			var slidePixelY = pixelY + pixelOffset;

			var colorDelta = clampLerp(delta, 0.4);

			if (slidePixelY >= 0) {
				var colorA = start.Image.GetPixel(pixelX,slidePixelY);
				var colorB = PostProcessUtilities.GetCorrespondingColorFromPal(colorA,start.Palette,end.Palette);
				var colorLerped = PostProcessUtilities.LerpColor(colorA, colorB, colorDelta);
				return colorLerped;
			}
			else {
				slidePixelY += start.Image.Height;
				var colorB = end.Image.GetPixel(pixelX,slidePixelY);
				var colorA = PostProcessUtilities.GetCorrespondingColorFromPal(colorB,end.Palette,start.Palette);
				var colorLerped = PostProcessUtilities.LerpColor(colorA, colorB, colorDelta);
				return colorLerped;
			}
		}
	});

	this.RegisterTransitionEffect("slide_d", {
		showPlayerStart : false,
		showPlayerEnd : true,
		duration : 1000,
		pixelEffectFunc : function(start,end,pixelX,pixelY,delta) {
			var pixelOffset = Math.floor(start.Image.Height * delta);
			var slidePixelY = pixelY + pixelOffset;

			var colorDelta = clampLerp(delta, 0.4);

			if (slidePixelY < start.Image.Height) {
				var colorA = start.Image.GetPixel(pixelX,slidePixelY);
				var colorB = PostProcessUtilities.GetCorrespondingColorFromPal(colorA,start.Palette,end.Palette);
				var colorLerped = PostProcessUtilities.LerpColor(colorA, colorB, colorDelta);
				return colorLerped;
			}
			else {
				slidePixelY -= start.Image.Height;
				var colorB = end.Image.GetPixel(pixelX,slidePixelY);
				var colorA = PostProcessUtilities.GetCorrespondingColorFromPal(colorB,end.Palette,start.Palette);
				var colorLerped = PostProcessUtilities.LerpColor(colorA, colorB, colorDelta);
				return colorLerped;
			}
		}
	});

	this.RegisterTransitionEffect("slide_l", {
		showPlayerStart : false,
		showPlayerEnd : true,
		duration : 1000,
		pixelEffectFunc : function(start,end,pixelX,pixelY,delta) {
			var pixelOffset = -1 * Math.floor(start.Image.Width * delta);
			var slidePixelX = pixelX + pixelOffset;

			var colorDelta = clampLerp(delta, 0.4);

			if (slidePixelX >= 0) {
				var colorA = start.Image.GetPixel(slidePixelX,pixelY);
				var colorB = PostProcessUtilities.GetCorrespondingColorFromPal(colorA,start.Palette,end.Palette);
				var colorLerped = PostProcessUtilities.LerpColor(colorA, colorB, colorDelta);
				return colorLerped;
			}
			else {
				slidePixelX += start.Image.Width;
				var colorB = end.Image.GetPixel(slidePixelX,pixelY);
				var colorA = PostProcessUtilities.GetCorrespondingColorFromPal(colorB,end.Palette,start.Palette);
				var colorLerped = PostProcessUtilities.LerpColor(colorA, colorB, colorDelta);
				return colorLerped;
			}
		}
	});

	this.RegisterTransitionEffect("slide_r", {
		showPlayerStart : false,
		showPlayerEnd : true,
		duration : 1000,
		pixelEffectFunc : function(start,end,pixelX,pixelY,delta) {
			var pixelOffset = Math.floor(start.Image.Width * delta);
			var slidePixelX = pixelX + pixelOffset;

			var colorDelta = clampLerp(delta, 0.4);

			if (slidePixelX < start.Image.Width) {
				var colorA = start.Image.GetPixel(slidePixelX,pixelY);
				var colorB = PostProcessUtilities.GetCorrespondingColorFromPal(colorA,start.Palette,end.Palette);
				var colorLerped = PostProcessUtilities.LerpColor(colorA, colorB, colorDelta);
				return colorLerped;
			}
			else {
				slidePixelX -= start.Image.Width;
				var colorB = end.Image.GetPixel(slidePixelX,pixelY);
				var colorA = PostProcessUtilities.GetCorrespondingColorFromPal(colorB,end.Palette,start.Palette);
				var colorLerped = PostProcessUtilities.LerpColor(colorA, colorB, colorDelta);
				return colorLerped;
			}
		}
	});

	function clampLerp(deltaIn, clampDuration) {
		var clampOffset = (1.0 - clampDuration) / 2;
		var deltaOut = Math.min(clampDuration, Math.max(0.0, deltaIn - clampOffset)) / clampDuration;
		return deltaOut;
	}

	// TODO : WIP
	// this.RegisterTransitionEffect("fuzz", {
	// 	showPlayerStart : true,
	// 	showPlayerEnd : true,
	// 	duration : 1500,
	// 	pixelEffectFunc : function(start,end,pixelX,pixelY,delta) {
	// 		var curImage = delta <= 0.5 ? start : end;
	// 		var sampleSize = delta <= 0.5 ? (2 + Math.floor(14 * (delta/0.5))) : (16 - Math.floor(14 * ((delta-0.5)/0.5)));

	// 		var palIndex = 0;

	// 		var sampleX = Math.floor(pixelX / sampleSize) * sampleSize;
	// 		var sampleY = Math.floor(pixelY / sampleSize) * sampleSize;

	// 		var frameState = transitionEffects["fuzz"].frameState;

	// 		if (frameState.time != delta) {
	// 			frameState.time = delta;
	// 			frameState.preCalcSampleValues = {};
	// 		}

	// 		if (frameState.preCalcSampleValues[[sampleX,sampleY]]) {
	// 			palIndex = frameState.preCalcSampleValues[[sampleX,sampleY]];
	// 		}
	// 		else {
	// 			var paletteCount = {};
	// 			var foregroundValue = 1.0;
	// 			var backgroundValue = 0.4;
	// 			for (var y = sampleY; y < sampleY + sampleSize; y++) {
	// 				for (var x = sampleX; x < sampleX + sampleSize; x++) {
	// 					var color = curImage.Image.GetPixel(x,y)
	// 					var palIndex = PostProcessUtilities.GetColorPalIndex(color,curImage.Palette);
	// 					if (palIndex != -1) {
	// 						if (paletteCount[palIndex]) {
	// 							paletteCount[palIndex] += (palIndex != 0) ? foregroundValue : backgroundValue;
	// 						}
	// 						else {
	// 							paletteCount[palIndex] = (palIndex != 0) ? foregroundValue : backgroundValue;
	// 						}
	// 					}
	// 				}
	// 			}

	// 			var maxCount = 0;
	// 			for (var i in paletteCount) {
	// 				if (paletteCount[i] > maxCount) {
	// 					palIndex = i;
	// 					maxCount = paletteCount[i];
	// 				}
	// 			}

	// 			frameState.preCalcSampleValues[[sampleX,sampleY]] = palIndex;
	// 		}

	// 		return PostProcessUtilities.GetPalColor(curImage.Palette,palIndex);
	// 	},
	// 	frameState : { // ok this is hacky but it's for performance ok
	// 		time : -1,
	// 		preCalcSampleValues : {}
	// 	}
	// });
}; // TransitionManager()


// TODO : extract the scale variable so it can be changed?
var PostProcessUtilities = {
	SamplePixelColor : function(image,x,y) {
		var pixelIndex = (y * scale * image.width * 4) + (x * scale * 4);
		var r = image.data[pixelIndex + 0];
		var g = image.data[pixelIndex + 1];
		var b = image.data[pixelIndex + 2];
		var a = image.data[pixelIndex + 3];
		return { r:r, g:g, b:b, a:a };
	},
	SetPixelColor : function(image,x,y,colorRgba) {
		for (var yDelta = 0; yDelta <= scale; yDelta++) {
			for (var xDelta = 0; xDelta <= scale; xDelta++) {
				var pixelIndex = (((y * scale) + yDelta) * image.width * 4) + (((x * scale) + xDelta) * 4);
				image.data[pixelIndex + 0] = colorRgba.r;
				image.data[pixelIndex + 1] = colorRgba.g;
				image.data[pixelIndex + 2] = colorRgba.b;
				image.data[pixelIndex + 3] = colorRgba.a;
			}
		}
	},
	LerpColor : function(colorA,colorB,t) {
		// TODO: move to color_util.js?
		return {
			r : colorA.r + ((colorB.r - colorA.r) * t),
			g : colorA.g + ((colorB.g - colorA.g) * t),
			b : colorA.b + ((colorB.b - colorA.b) * t),
			a : colorA.a + ((colorB.a - colorA.a) * t),
		};
	},
	GetColorPalIndex : function(colorIn,curPal) {
		var colorIndex = -1;

		for (var i = 0; i < curPal.length; i++) {
			if (colorIn.r == curPal[i][0] && colorIn.g == curPal[i][1] && colorIn.b == curPal[i][2]) {
				colorIndex = i;
			}
		}

		return colorIndex;
	},
	GetPalColor : function(palette,index) {
		return { r: palette[index][0], g: palette[index][1], b: palette[index][2], a: 255 }
	},
	GetCorrespondingColorFromPal : function(colorIn,curPal,otherPal) { // this is kind of hacky!
		var colorIndex = PostProcessUtilities.GetColorPalIndex(colorIn,curPal);

		if (colorIndex >= 0 && colorIndex <= otherPal.length) {
			return PostProcessUtilities.GetPalColor(otherPal,colorIndex);
		}
		else {
			return colorIn;
		}
	},
};

var PostProcessImage = function(imageData) {
	this.Width = imageData.width / scale;
	this.Height = imageData.height / scale;

	this.GetPixel = function(x,y) {
		return PostProcessUtilities.SamplePixelColor(imageData,x,y);
	};

	this.SetPixel = function(x,y,colorRgba) {
		PostProcessUtilities.SetPixelColor(imageData,x,y,colorRgba);
	};

	this.GetData = function() {
		return imageData;
	};
};

var TransitionInfo = function(image, palette, playerX, playerY) {
	this.Image = image;
	this.Palette = palette;
	this.PlayerTilePos = { x: playerX, y: playerY };
	this.PlayerCenter = { x: Math.floor((playerX * tilesize) + (tilesize / 2)), y: Math.floor((playerY * tilesize) + (tilesize / 2)) };
};
</script>

<script>
/*
TODO:
- can I simplify this more now that I've removed the external resources stuff?
*/

function FontManager(packagedFontNames) {

var self = this;

var fontExtension = ".bitsyfont";
this.GetExtension = function() {
	return fontExtension;
}

// place to store font data
var fontResources = {};

// load fonts from the editor
if (packagedFontNames != undefined && packagedFontNames != null && packagedFontNames.length > 0
		&& Resources != undefined && Resources != null) {

	for (var i = 0; i < packagedFontNames.length; i++) {
		var filename = packagedFontNames[i];
		fontResources[filename] = Resources[filename];
	}
}

// manually add resource
this.AddResource = function(filename, fontdata) {
	fontResources[filename] = fontdata;
}

this.ContainsResource = function(filename) {
	return fontResources[filename] != null;
}

function GetData(fontName) {
	return fontResources[fontName + fontExtension];
}
this.GetData = GetData;

function Create(fontData) {
	return new Font(fontData);
}
this.Create = Create;

this.Get = function(fontName) {
	var fontData = self.GetData(fontName);
	return self.Create(fontData);
}

function Font(fontData) {
	var name = "unknown";
	var width = 6; // default size so if you have NO font or an invalid font it displays boxes
	var height = 8;
	var chardata = {};
	var invalidCharData = {};

	this.getName = function() {
		return name;
	}

	this.getData = function() {
		return chardata;
	}

	this.getWidth = function() {
		return width;
	}

	this.getHeight = function() {
		return height;
	}

	this.hasChar = function(char) {
		var codepoint = char.charCodeAt(0);
		return chardata[codepoint] != null;
	}

	this.getChar = function(char) {

		var codepoint = char.charCodeAt(0);

		if (chardata[codepoint] != null) {
			return chardata[codepoint];
		}
		else {
			return invalidCharData;
		}
	}

	this.allCharCodes = function() {
		var codeList = [];
		for (var code in chardata) {
			codeList.push(code);
		}
		return codeList;
	}

	function parseFont(fontData) {
		if (fontData == null)
			return;

		var lines = fontData.split("\n");

		var isReadingChar = false;
		var isReadingCharProperties = false;
		var curCharLineCount = 0;
		var curCharCode = 0;

		for (var i = 0; i < lines.length; i++) {
			var line = lines[i];

			if (line[0] === "#") {
				continue; // skip comment lines
			}

			if (!isReadingChar) {
				// READING NON CHARACTER DATA LINE
				var args = line.split(" ");
				if (args[0] == "FONT") {
					name = args[1];
				}
				else if (args[0] == "SIZE") {
					width = parseInt(args[1]);
					height = parseInt(args[2]);
				}
				else if (args[0] == "CHAR") {
					isReadingChar = true;
					isReadingCharProperties = true;

					curCharLineCount = 0;
					curCharCode = parseInt(args[1]);
					chardata[curCharCode] = { 
						width: width,
						height: height,
						offset: {
							x: 0,
							y: 0
						},
						spacing: width,
						data: []
					};
				}
			}
			else {
				// CHAR PROPERTIES
				if (isReadingCharProperties) {
					var args = line.split(" ");
					if (args[0].indexOf("CHAR_") == 0) { // Sub-properties start with "CHAR_"
						if (args[0] == "CHAR_SIZE") {
							// Custom character size - overrides the default character size for the font
							chardata[curCharCode].width = parseInt(args[1]);
							chardata[curCharCode].height = parseInt(args[2]);
							chardata[curCharCode].spacing = parseInt(args[1]); // HACK : assumes CHAR_SIZE is always declared first
						}
						else if (args[0] == "CHAR_OFFSET") {
							// Character offset - shift the origin of the character on the X or Y axis
							chardata[curCharCode].offset.x = parseInt(args[1]);
							chardata[curCharCode].offset.y = parseInt(args[2]);
						}
						else if (args[0] == "CHAR_SPACING") {
							// Character spacing:
							// specify total horizontal space taken up by the character
							// lets chars take up more or less space on a line than its bitmap does
							chardata[curCharCode].spacing = parseInt(args[1]);
						}
					}
					else {
						isReadingCharProperties = false;
					}
				}

				// CHAR DATA
				if (!isReadingCharProperties) {
					// READING CHARACTER DATA LINE
					for (var j = 0; j < chardata[curCharCode].width; j++)
					{
						chardata[curCharCode].data.push( parseInt(line[j]) );
					}

					curCharLineCount++;
					if (curCharLineCount >= height) {
						isReadingChar = false;
					}
				}
			}
		}

		// init invalid character box
		invalidCharData = { 
			width: width,
			height: height,
			offset: {
				x: 0,
				y: 0
			},
			spacing: width, // TODO : name?
			data: []
		};
		for (var y = 0; y < height; y++) {
			for (var x = 0; x < width; x++) {
				if (x < width-1 && y < height-1) {
					invalidCharData.data.push(1);
				}
				else {
					invalidCharData.data.push(0);
				}
			}
		}
	}

	parseFont(fontData);
}

} // FontManager
</script>

<script>
function Script() {

this.CreateInterpreter = function() {
	return new Interpreter();
};

this.CreateUtils = function() {
	return new Utils();
};

var Interpreter = function() {
	var env = new Environment();
	var parser = new Parser( env );

	this.SetDialogBuffer = function(buffer) { env.SetDialogBuffer( buffer ); };

	// TODO -- maybe this should return a string instead othe actual script??
	this.Compile = function(scriptName, scriptStr) {
		// console.log("COMPILE");
		var script = parser.Parse( scriptStr );
		env.SetScript( scriptName, script );
	}
	this.Run = function(scriptName, exitHandler) { // Runs pre-compiled script
		// console.log("RUN");
		// console.log(env.GetScript( scriptName ));
		env.GetScript( scriptName )
			.Eval( env, function(result) { OnScriptReturn(result, exitHandler); } );

		// console.log("SERIALIZE!!!!");
		// console.log( env.GetScript( scriptName ).Serialize() );
	}
	this.Interpret = function(scriptStr, exitHandler) { // Compiles and runs code immediately
		// console.log("INTERPRET");
		var script = parser.Parse( scriptStr );
		script.Eval( env, function(result) { OnScriptReturn(result, exitHandler); } );
	}
	this.HasScript = function(name) { return env.HasScript(name); };

	this.ResetEnvironment = function() {
		env = new Environment();
		parser = new Parser( env );
	}

	this.Parse = function(scriptStr) { // parses a script but doesn't save it
		return parser.Parse( scriptStr );
	}
	this.Eval = function(scriptTree, exitHandler) { // runs a script stored externally
		scriptTree.Eval( env, function(result) { OnScriptReturn(result, exitHandler); } );
	}

	function OnScriptReturn(result, exitHandler) {
		if (isReturnObject(result)) {
			result = result.result; // pull out the contained result
		}

		// console.log("RESULT " + result);

		if (exitHandler != null) {
			exitHandler(result);
		}
	}

	this.CreateExpression = function(expStr) {
		return parser.CreateExpression( expStr );
	}

	this.SetVariable = function(name,value,useHandler) {
		env.SetVariable(name,value,useHandler);
	}

	this.DeleteVariable = function(name,useHandler) {
		env.DeleteVariable(name,useHandler);
	}
	this.HasVariable = function(name) {
		return env.HasVariable(name);
	}

	this.SetOnVariableChangeHandler = function(onVariableChange) {
		env.SetOnVariableChangeHandler(onVariableChange);
	}
	this.GetVariableNames = function() {
		return env.GetVariableNames();
	}
	this.GetVariable = function(name) {
		return env.GetVariable(name);
	}

	this.DebugVisualizeScriptTree = function(scriptName) {
		var printVisitor = {
			Visit : function(node,depth) {
				console.log("-".repeat(depth) + "- " + node.ToString());
			},
		};

		env.GetScript( scriptName ).VisitAll( printVisitor );
	}
}


var Utils = function() {
	// for editor ui
	this.CreateDialogBlock = function(children,doIndentFirstLine) {
		if(doIndentFirstLine === undefined) doIndentFirstLine = true;
		var block = new BlockNode( BlockMode.Dialog, doIndentFirstLine );
		for(var i = 0; i < children.length; i++) {
			block.AddChild( children[i] );
		}
		return block;
	}

	this.ChangeSequenceType = function(oldSequence,type) {
		if(type === "sequence") {
			return new SequenceNode( oldSequence.options );
		}
		else if(type === "cycle") {
			return new CycleNode( oldSequence.options );
		}
		else if(type === "shuffle") {
			return new ShuffleNode( oldSequence.options );
		}
		return oldSequence;
	}

	this.CreateSequenceBlock = function() {
		var option1 = new BlockNode( BlockMode.Dialog, false /*doIndentFirstLine*/ );
		var option2 = new BlockNode( BlockMode.Dialog, false /*doIndentFirstLine*/ );
		var sequence = new SequenceNode( [ option1, option2 ] );
		var block = new BlockNode( BlockMode.Code );
		block.AddChild( sequence );
		return block;
	}

	this.CreateIfBlock = function() {
		var leftNode = new BlockNode( BlockMode.Code );
		leftNode.AddChild( new FuncNode("item", [new LiteralNode("0")] ) );
		var rightNode = new LiteralNode( 1 );
		var condition1 = new ExpNode("==", leftNode, rightNode );

		var condition2 = new ElseNode();

		var result1 = new BlockNode( BlockMode.Dialog );
		var result2 = new BlockNode( BlockMode.Dialog );

		var ifNode = new IfNode( [ condition1, condition2 ], [ result1, result2 ] );
		var block = new BlockNode( BlockMode.Code );
		block.AddChild( ifNode );
		return block;
	}

	this.ReadDialogScript = function(lines, i) {
		var scriptStr = "";
		if (lines[i] === Sym.DialogOpen) {
			scriptStr += lines[i] + "\n";
			i++;
			while(lines[i] != Sym.DialogClose) {
				scriptStr += lines[i] + "\n";
				i++;
			}
			scriptStr += lines[i];
			i++;
		}
		else {
			scriptStr += lines[i];
		}
		return { script:scriptStr, index:i };
	}

	// TODO this.ReadCodeScript (reads through code open and close symbols), and this.ReadScript

	this.EnsureDialogBlockFormat = function(dialogStr) {
		// TODO -- what if it's already enclosed in dialog symbols??
		if(dialogStr.indexOf('\n') > -1) {
			dialogStr = Sym.DialogOpen + "\n" + dialogStr + "\n" + Sym.DialogClose;
		}
		return dialogStr;
	}

	this.RemoveDialogBlockFormat = function(source) {
		var sourceLines = source.split("\n");
		var dialogStr = "";
		if(sourceLines[0] === Sym.DialogOpen) {
			// multi line
			var i = 1;
			while (i < sourceLines.length && sourceLines[i] != Sym.DialogClose) {
				dialogStr += sourceLines[i] + (sourceLines[i+1] != Sym.DialogClose ? '\n' : '');
				i++;
			}
		}
		else {
			// single line
			dialogStr = source;
		}
		return dialogStr;
	}
}


/* BUILT-IN FUNCTIONS */ // TODO: better way to encapsulate these?
function deprecatedFunc(environment,parameters,onReturn) {
	console.log("BITSY SCRIPT WARNING: Tried to use deprecated function");
	onReturn(null);
}

// TODO : vNext
// function returnFunc(environment,parameters,onReturn) {
// 	var ret = { isReturn: true, result: null };
// 	if (parameters.length > 0 && parameters[0] != undefined && parameters[0] != null) {
// 		ret.result = parameters[0];
// 	}
// 	onReturn(ret);
// }

// TODO : vNext
// // TODO : this is kind of hacky
// // - needs to work with names too
// function changeAvatarFunc(environment,parameters,onReturn) {
// 	if( parameters[0] != undefined && parameters[0] != null ) {
// 		sprite["A"].drw = "SPR_" + parameters[0];
// 	}
// 	onReturn(null);
// }

function printFunc(environment,parameters,onReturn) {
	// console.log("PRINT FUNC");
	// console.log(parameters);
	if( parameters[0] != undefined && parameters[0] != null ) {
		// console.log(parameters[0]);
		// console.log(parameters[0].toString());
		// var textStr = parameters[0].toString();
		var textStr = "" + parameters[0];
		// console.log(textStr);
		var onFinishHandler = function() {
			// console.log("FINISHED PRINTING ---- SCRIPT");
			onReturn(null);
		}; // called when dialog is finished printing
		environment.GetDialogBuffer().AddText( textStr, onFinishHandler );
	}
	else {
		onReturn(null);
	}
}

function linebreakFunc(environment,parameters,onReturn) {
	// console.log("LINEBREAK FUNC");
	environment.GetDialogBuffer().AddLinebreak();
	onReturn(null);
}

function printDrawingFunc(environment,parameters,onReturn) {
	var drawingId = parameters[0];
	environment.GetDialogBuffer().AddDrawing( drawingId, function() {
		onReturn(null);
	});
}

function printSpriteFunc(environment,parameters,onReturn) {
	var spriteId = parameters[0];
	if(names.sprite.has(spriteId)) spriteId = names.sprite.get(spriteId); // id is actually a name
	var drawingId = sprite[spriteId].drw;
	printDrawingFunc(environment, [drawingId], onReturn);
}

function printTileFunc(environment,parameters,onReturn) {
	var tileId = parameters[0];
	if(names.tile.has(tileId)) tileId = names.tile.get(tileId); // id is actually a name
	var drawingId = tile[tileId].drw;
	printDrawingFunc(environment, [drawingId], onReturn);
}

function printItemFunc(environment,parameters,onReturn) {
	var itemId = parameters[0];
	if(names.item.has(itemId)) itemId = names.item.get(itemId); // id is actually a name
	var drawingId = item[itemId].drw;
	printDrawingFunc(environment, [drawingId], onReturn);
}

function printFontFunc(environment, parameters, onReturn) {
	var allCharacters = "";
	var font = fontManager.Get( fontName );
	var codeList = font.allCharCodes();
	for (var i = 0; i < codeList.length; i++) {
		allCharacters += String.fromCharCode(codeList[i]) + " ";
	}
	printFunc(environment, [allCharacters], onReturn);
}

function itemFunc(environment,parameters,onReturn) {
	var itemId = parameters[0];
	if(names.item.has(itemId)) itemId = names.item.get(itemId); // id is actually a name
	var itemCount = player().inventory[itemId] ? player().inventory[itemId] : 0; // TODO : ultimately the environment should include a reference to the game state
	// console.log("ITEM FUNC " + itemId + " " + itemCount);
	onReturn(itemCount);
}

function addOrRemoveTextEffect(environment,name) {
	if( environment.GetDialogBuffer().HasTextEffect(name) )
		environment.GetDialogBuffer().RemoveTextEffect(name);
	else
		environment.GetDialogBuffer().AddTextEffect(name);
}

function rainbowFunc(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"rbw");
	onReturn(null);
}

// TODO : should the colors use a parameter instead of special names?
function color1Func(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"clr1");
	onReturn(null);
}

function color2Func(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"clr2");
	onReturn(null);
}

function color3Func(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"clr3");
	onReturn(null);
}

function wavyFunc(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"wvy");
	onReturn(null);
}

function shakyFunc(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"shk");
	onReturn(null);
}

/* BUILT-IN OPERATORS */
function setExp(environment,left,right,onReturn) {
	// console.log("SET " + left.name);

	if(left.type != "variable") {
		// not a variable! return null and hope for the best D:
		onReturn( null );
		return;
	}

	right.Eval(environment,function(rVal) {
		environment.SetVariable( left.name, rVal );
		// console.log("VAL " + environment.GetVariable( left.name ) );
		left.Eval(environment,function(lVal) {
			onReturn( lVal );
		});
	});
}
function equalExp(environment,left,right,onReturn) {
	// console.log("EVAL EQUAL");
	// console.log(left);
	// console.log(right);
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal === rVal );
		});
	});
}
function greaterExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal > rVal );
		});
	});
}
function lessExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal < rVal );
		});
	});
}
function greaterEqExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal >= rVal );
		});
	});
}
function lessEqExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal <= rVal );
		});
	});
}
function multExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal * rVal );
		});
	});
}
function divExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal / rVal );
		});
	});
}
function addExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal + rVal );
		});
	});
}
function subExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal - rVal );
		});
	});
}

/* ENVIRONMENT */
var Environment = function() {
	var dialogBuffer = null;
	this.SetDialogBuffer = function(buffer) { dialogBuffer = buffer; };
	this.GetDialogBuffer = function() { return dialogBuffer; };

	var functionMap = new Map();
	functionMap.set("print", printFunc);
	functionMap.set("say", printFunc);
	functionMap.set("br", linebreakFunc);
	functionMap.set("item", itemFunc);
	functionMap.set("rbw", rainbowFunc);
	functionMap.set("clr1", color1Func);
	functionMap.set("clr2", color2Func);
	functionMap.set("clr3", color3Func);
	functionMap.set("wvy", wavyFunc);
	functionMap.set("shk", shakyFunc);
	functionMap.set("printSprite", printSpriteFunc);
	functionMap.set("printTile", printTileFunc);
	functionMap.set("printItem", printItemFunc);
	functionMap.set("debugOnlyPrintFont", printFontFunc); // DEBUG ONLY

	// TODO : vNext
	// functionMap.set("changeAvatar", changeAvatarFunc);
	// functionMap.set("return", returnFunc);

	this.HasFunction = function(name) { return functionMap.has(name); };
	this.EvalFunction = function(name,parameters,onReturn) {
		// console.log(functionMap);
		// console.log(name);
		functionMap.get( name )( this, parameters, onReturn );
	}

	var variableMap = new Map();

	this.HasVariable = function(name) { return variableMap.has(name); };
	this.GetVariable = function(name) { return variableMap.get(name); };
	this.SetVariable = function(name,value,useHandler) {
		// console.log("SET VARIABLE " + name + " = " + value);
		if(useHandler === undefined) useHandler = true;
		variableMap.set(name, value);
		if(onVariableChangeHandler != null && useHandler)
			onVariableChangeHandler(name);
	};
	this.DeleteVariable = function(name,useHandler) {
		if(useHandler === undefined) useHandler = true;
		if(variableMap.has(name)) {
			variableMap.delete(name);
			if(onVariableChangeHandler != null && useHandler)
				onVariableChangeHandler(name);
		}
	};

	var operatorMap = new Map();
	operatorMap.set("=", setExp);
	operatorMap.set("==", equalExp);
	operatorMap.set(">", greaterExp);
	operatorMap.set("<", lessExp);
	operatorMap.set(">=", greaterEqExp);
	operatorMap.set("<=", lessEqExp);
	operatorMap.set("*", multExp);
	operatorMap.set("/", divExp);
	operatorMap.set("+", addExp);
	operatorMap.set("-", subExp);

	this.HasOperator = function(sym) { return operatorMap.get(sym); };
	this.EvalOperator = function(sym,left,right,onReturn) {
		operatorMap.get( sym )( this, left, right, onReturn );
	}

	var scriptMap = new Map();
	this.HasScript = function(name) { return scriptMap.has(name); };
	this.GetScript = function(name) { return scriptMap.get(name); };
	this.SetScript = function(name,script) { scriptMap.set(name, script); };

	var onVariableChangeHandler = null;
	this.SetOnVariableChangeHandler = function(onVariableChange) {
		onVariableChangeHandler = onVariableChange;
	}
	this.GetVariableNames = function() {
		return Array.from( variableMap.keys() );
	}
}

function leadingWhitespace(depth) {
	var str = "";
	for(var i = 0; i < depth; i++) {
		str += "  "; // two spaces per indent
	}
	// console.log("WHITESPACE " + depth + " ::" + str + "::");
	return str;
}

/* NODES */
var TreeRelationship = function() {
	this.parent = null;
	this.children = [];
	this.AddChild = function(node) {
		this.children.push( node );
		node.parent = this;
	};

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit( this, depth );
		for( var i = 0; i < this.children.length; i++ ) {
			this.children[i].VisitAll( visitor, depth + 1 );
		}
	};
}

function isReturnObject(val) {
	return typeof val === "object" && val != null
				&& val.isReturn != undefined && val.isReturn != null
				&& val.isReturn;
}

var BlockMode = {
	Code : "code",
	Dialog : "dialog"
};

var BlockNode = function(mode, doIndentFirstLine) {
	Object.assign( this, new TreeRelationship() );
	// Object.assign( this, new Runnable() );
	this.type = "block";
	this.mode = mode;

	this.Eval = function(environment,onReturn) {
		// console.log("EVAL BLOCK " + this.children.length);

		if( this.onEnter != null ) {
			this.onEnter();
		}

		var lastVal = null;
		var i = 0;

		function evalChildren(children,done) {
			if (i < children.length) {
				// console.log(">> CHILD " + i);
				children[i].Eval( environment, function(val) {
					// console.log("<< CHILD " + i);

					if (isReturnObject(val)) { // early return
						lastVal = val;
						done();
					}
					else {
						lastVal = val;
						i++;
						evalChildren(children,done);
					}
				} );
			}
			else {
				done();
			}
		};

		var self = this;
		evalChildren( this.children, function() {
			if( self.onExit != null ) {
				self.onExit();
			}
			onReturn(lastVal);
		} );
	}

	if(doIndentFirstLine === undefined) doIndentFirstLine = true; // This is just for serialization

	this.Serialize = function(depth) {
		if(depth === undefined) depth = 0;

		// console.log("SERIALIZE BLOCK!!!");
		// console.log(depth);
		// console.log(doIndentFirstLine);

		var str = "";
		var lastNode = null;
		if (this.mode === BlockMode.Code) str += "{"; // todo: increase scope of Sym?
		for (var i = 0; i < this.children.length; i++) {

			var curNode = this.children[i];

			if(curNode.type === "block" && lastNode && lastNode.type === "block" && !isBlockWithNoNewline(curNode) && !isBlockWithNoNewline(lastNode))
				str += "\n";

			var shouldIndentFirstLine = (i == 0 && doIndentFirstLine);
			var shouldIndentAfterLinebreak = (lastNode && lastNode.type === "function" && lastNode.name === "br");
			if(this.mode === BlockMode.Dialog && (shouldIndentFirstLine || shouldIndentAfterLinebreak))
				str += leadingWhitespace(depth);
			str += curNode.Serialize(depth);
			lastNode = curNode;
		}
		if (this.mode === BlockMode.Code) str += "}";
		return str;
	}

	this.ToString = function() {
		return this.type + " " + this.mode;
	};
}

function isBlockWithNoNewline(node) {
	return isTextEffectBlock(node) || isMultilineListBlock(node);
}

function isTextEffectBlock(node) {
	if(node.type === "block") {
		if(node.children.length > 0 && node.children[0].type === "function") {
			var func = node.children[0];
			if(func.name === "clr1" || func.name === "clr2" || func.name === "clr3" || func.name === "wvy" || func.name === "shk" || func.name === "rbw") {
				return true;
			}
		}
	}
	return false;
}

function isMultilineListBlock(node) {
	if(node.type === "block") {
		if(node.children.length > 0) {
			var child = node.children[0];
			if(child.type === "sequence" || child.type === "cycle" || child.type === "shuffle" || child.type === "if") {
				return true;
			}
		}
	}
	return false;
}

var FuncNode = function(name,arguments) {
	Object.assign( this, new TreeRelationship() );
	// Object.assign( this, new Runnable() );
	this.type = "function";
	this.name = name;
	this.arguments = arguments;

	this.Eval = function(environment,onReturn) {

		if( this.onEnter != null ) this.onEnter();

		// console.log("FUNC");
		// console.log(this.arguments);
		var argumentValues = [];
		var i = 0;
		function evalArgs(arguments,done) {
			if(i < arguments.length) {
				// Evaluate each argument
				arguments[i].Eval( environment, function(val) {
					argumentValues.push( val );
					i++;
					evalArgs(arguments,done);
				} );
			}
			else {
				done();
			}
		};
		var self = this; // hack to deal with scope
		evalArgs( this.arguments, function() {
			// Then evaluate the function
			// console.log("ARGS");
			// console.log(argumentValues);

			if( self.onExit != null ) self.onExit();

			environment.EvalFunction( self.name, argumentValues, onReturn );
		} );
	}

	this.Serialize = function(depth) {
		var isDialogBlock = this.parent.mode && this.parent.mode === BlockMode.Dialog;
		if(isDialogBlock && this.name === "print") {
			// TODO this could cause problems with "real" print functions
			return this.arguments[0].value; // first argument should be the text of the {print} func
		}
		else if(isDialogBlock && this.name === "br") {
			return "\n";
		}
		else {
			var str = "";
			str += this.name;
			for(var i = 0; i < this.arguments.length; i++) {
				str += " ";
				str += this.arguments[i].Serialize(depth);
			}
			return str;
		}
	}

	this.ToString = function() {
		return this.type + " " + this.name;
	};
}

var LiteralNode = function(value) {
	Object.assign( this, new TreeRelationship() );
	// Object.assign( this, new Runnable() );
	this.type = "literal";
	this.value = value;

	this.Eval = function(environment,onReturn) {
		onReturn(this.value);
	}

	this.Serialize = function(depth) {
		var str = "";

		if(this.value === null)
			return str;

		if(typeof this.value === "string") str += '"';
		str += this.value;
		if(typeof this.value === "string") str += '"';

		return str;
	}

	this.ToString = function() {
		return this.type + " " + this.value;
	};
}

var VarNode = function(name) {
	Object.assign( this, new TreeRelationship() );
	// Object.assign( this, new Runnable() );
	this.type = "variable";
	this.name = name;

	this.Eval = function(environment,onReturn) {
		// console.log("EVAL " + this.name + " " + environment.HasVariable(this.name) + " " + environment.GetVariable(this.name));
		if( environment.HasVariable(this.name) )
			onReturn( environment.GetVariable( this.name ) );
		else
			onReturn(null); // not a valid variable -- return null and hope that's ok
	} // TODO: might want to store nodes in the variableMap instead of values???

	this.Serialize = function(depth) {
		var str = "" + this.name;
		return str;
	}

	this.ToString = function() {
		return this.type + " " + this.name;
	};
}

var ExpNode = function(operator, left, right) {
	Object.assign( this, new TreeRelationship() );
	this.type = "operator";
	this.operator = operator;
	this.left = left;
	this.right = right;

	this.Eval = function(environment,onReturn) {
		// console.log("EVAL " + this.operator);
		var self = this; // hack to deal with scope
		environment.EvalOperator( this.operator, this.left, this.right, 
			function(val){
				// console.log("EVAL EXP " + self.operator + " " + val);
				onReturn(val);
			} );
		// NOTE : sadly this pushes a lot of complexity down onto the actual operator methods
	}

	this.Serialize = function(depth) {
		var isNegativeNumber = this.operator === "-" && this.left.type === "literal" && this.left.value === null;

		if(!isNegativeNumber) {
			var str = "";
			str += this.left.Serialize(depth);
			str += " " + this.operator + " ";
			str += this.right.Serialize(depth);
			return str;
		}
		else {
			return this.operator + this.right.Serialize(depth); // hacky but seems to work
		}
	}

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit( this, depth );
		if(this.left != null)
			this.left.VisitAll( visitor, depth + 1 );
		if(this.right != null)
			this.right.VisitAll( visitor, depth + 1 );
	};

	this.ToString = function() {
		return this.type + " " + this.operator;
	};
}

var SequenceBase = function() {
	this.Serialize = function(depth) {
		var str = "";
		str += this.type + "\n";
		for (var i = 0; i < this.options.length; i++) {
			// console.log("SERIALIZE SEQUENCE ");
			// console.log(depth);
			str += leadingWhitespace(depth + 1) + Sym.List + " " + this.options[i].Serialize(depth + 2) + "\n";
		}
		str += leadingWhitespace(depth);
		return str;
	}

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit( this, depth );
		for( var i = 0; i < this.options.length; i++ ) {
			this.options[i].VisitAll( visitor, depth + 1 );
		}
	};

	this.ToString = function() {
		return this.type;
	};
}

var SequenceNode = function(options) {
	Object.assign( this, new TreeRelationship() );
	Object.assign( this, new SequenceBase() );
	this.type = "sequence";
	this.options = options;

	var index = 0;
	this.Eval = function(environment,onReturn) {
		// console.log("SEQUENCE " + index);
		this.options[index].Eval( environment, onReturn );

		var next = index + 1;
		if(next < this.options.length)
			index = next;
	}
}

var CycleNode = function(options) {
	Object.assign( this, new TreeRelationship() );
	Object.assign( this, new SequenceBase() );
	this.type = "cycle";
	this.options = options;

	var index = 0;
	this.Eval = function(environment,onReturn) {
		// console.log("CYCLE " + index);
		this.options[index].Eval( environment, onReturn );

		var next = index + 1;
		if(next < this.options.length)
			index = next;
		else
			index = 0;
	}
}

var ShuffleNode = function(options) {
	Object.assign( this, new TreeRelationship() );
	Object.assign( this, new SequenceBase() );
	this.type = "shuffle";
	this.options = options;

	var optionsShuffled = [];
	function shuffle(options) {
		optionsShuffled = [];
		var optionsUnshuffled = options.slice();
		while(optionsUnshuffled.length > 0) {
			var i = Math.floor( Math.random() * optionsUnshuffled.length );
			optionsShuffled.push( optionsUnshuffled.splice(i,1)[0] );
		}
	}
	shuffle(this.options);

	var index = 0;
	this.Eval = function(environment,onReturn) {
		// OLD RANDOM VERSION
		// var index = Math.floor(Math.random() * this.options.length);
		// this.options[index].Eval( environment, onReturn );

		optionsShuffled[index].Eval( environment, onReturn );
		
		index++;
		if (index >= this.options.length) {
			shuffle(this.options);
			index = 0;
		}
	}
}

var IfNode = function(conditions, results, isSingleLine) {
	Object.assign( this, new TreeRelationship() );
	this.type = "if";
	this.conditions = conditions;
	this.results = results;

	this.Eval = function(environment,onReturn) {
		// console.log("EVAL IF");
		var i = 0;
		var self = this;
		function TestCondition() {
			// console.log("EVAL " + i);
			self.conditions[i].Eval(environment, function(val) {
				// console.log(val);
				if(val == true) {
					self.results[i].Eval(environment, onReturn);
				}
				else if(i+1 < self.conditions.length) {
					i++;
					TestCondition(); // test next condition
				}
				else {
					onReturn(null); // out of conditions and none were true
				}
			});
		};
		TestCondition();
	}

	if(isSingleLine === undefined) isSingleLine = false; // This is just for serialization

	this.Serialize = function(depth) {
		var str = "";
		if(isSingleLine) {
			str += this.conditions[0].Serialize() + " ? " + this.results[0].Serialize();
			if(this.conditions.length > 1 && this.conditions[1].type === "else")
				str += " : " + this.results[1].Serialize();
		}
		else {
			str += "\n";
			for (var i = 0; i < this.conditions.length; i++) {
				str += leadingWhitespace(depth + 1) + Sym.List + " " + this.conditions[i].Serialize(depth) + " ?\n";
				str += this.results[i].Serialize(depth + 2) + "\n";
			}
			str += leadingWhitespace(depth);
		}
		return str;
	}

	this.IsSingleLine = function() {
		return isSingleLine;
	}

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit( this, depth );
		for( var i = 0; i < this.conditions.length; i++ ) {
			this.conditions[i].VisitAll( visitor, depth + 1 );
		}
		for( var i = 0; i < this.results.length; i++ ) {
			this.results[i].VisitAll( visitor, depth + 1 );
		}
	};

	this.ToString = function() {
		return this.type + " " + this.mode;
	};
}

var ElseNode = function() {
	Object.assign( this, new TreeRelationship() );
	this.type = "else";

	this.Eval = function(environment,onReturn) {
		onReturn(true);
	}

	this.Serialize = function() {
		return "else";
	}

	this.ToString = function() {
		return this.type + " " + this.mode;
	};
}

var Sym = {
	// DialogOpen : "/\"",
	// DialogClose : "\"/",
	DialogOpen : '"""',
	DialogClose : '"""',
	CodeOpen : "{",
	CodeClose : "}",
	Linebreak : "\n", // just call it "break" ?
	Separator : ":",
	List : "-",
	String : '"'
};

var Parser = function(env) {
	var environment = env;

	this.Parse = function(scriptStr) {
		// console.log("NEW PARSE!!!!!!");

		// TODO : make this work for single-line, no dialog block scripts

		var state = new ParserState( new BlockNode(BlockMode.Dialog), scriptStr );

		if( state.MatchAhead(Sym.DialogOpen) ) {
			// multi-line dialog block
			var dialogStr = state.ConsumeBlock( Sym.DialogOpen, Sym.DialogClose );
			state = new ParserState( new BlockNode(BlockMode.Dialog), dialogStr );
			state = ParseDialog( state );
		}
		// else if( state.MatchAhead(Sym.CodeOpen) ) { // NOTE: This causes problems when you lead with a code block
		// 	// code-block: should this ever happen?
		// 	state = ParseCodeBlock( state );
		// }
		else {
			// single-line dialog block
			state = ParseDialog( state );
		}

		// console.log( state.rootNode );
		return state.rootNode;
	};

	var ParserState = function( rootNode, str ) {
		this.rootNode = rootNode;
		this.curNode = this.rootNode;

		var sourceStr = str;
		var i = 0;
		this.Index = function() { return i; };
		this.Count = function() { return sourceStr.length; };
		this.Done = function() { return i >= sourceStr.length; };
		this.Char = function() { return sourceStr[i]; };
		this.Step = function(n) { if(n===undefined) n=1; i += n; };
		this.MatchAhead = function(str) {
			// console.log(str);
			str = "" + str; // hack to turn single chars into strings
			// console.log(str);
			// console.log(str.length);
			for(var j = 0; j < str.length; j++) {
				if( i + j >= sourceStr.length )
					return false;
				else if( str[j] != sourceStr[i+j] )
					return false;
			}
			return true;
		}
		this.Peak = function(end) {
			var str = "";
			var j = i;
			// console.log(j);
			while(j < sourceStr.length && end.indexOf( sourceStr[j] ) == -1 ) {
				str += sourceStr[j];
				j++;
			}
			// console.log("PEAK ::" + str + "::");
			return str;
		}
		this.ConsumeBlock = function( open, close ) {
			var startIndex = i;

			var matchCount = 0;
			if( this.MatchAhead( open ) ) {
				matchCount++;
				this.Step( open.length );
			}

			while( matchCount > 0 && !this.Done() ) {
				if( this.MatchAhead( close ) ) {
					matchCount--;
					this.Step( close.length );
				}
				else if( this.MatchAhead( open ) ) {
					matchCount++;
					this.Step( open.length );
				}
				else {
					this.Step();
				}
			}

			// console.log("!!! " + startIndex + " " + i);

			return sourceStr.slice( startIndex + open.length, i - close.length );
		}
		this.Print = function() { console.log(sourceStr); };
		this.Source = function() { return sourceStr; };
	};

	function ParseDialog(state) {
		// console.log("PARSE DIALOG");
		state.Print();

		// for linebreak logic: add linebreaks after lines with dialog or empty lines (if it's not the very first line)
		var hasBlock = false;
		var hasDialog = false;
		var isFirstLine = true;

		// console.log("---- PARSE DIALOG ----");

		var text = "";
		var addTextNode = function() {
			// console.log("TEXT " + text.length);
			if (text.length > 0) {
				// console.log("TEXT " + text);
				// console.log("text!!");
				// console.log([text]);

				state.curNode.AddChild( new FuncNode( "print", [new LiteralNode(text)] ) );
				text = "";

				hasDialog = true;
			}
		}

		while ( !state.Done() ) {

			if( state.MatchAhead(Sym.CodeOpen) ) {
				addTextNode();
				state = ParseCodeBlock( state );

				// console.log("CODE");

				var len = state.curNode.children.length;
				if(len > 0 && state.curNode.children[len-1].type === "block") {
					var block = state.curNode.children[len-1];
					if(isMultilineListBlock(block))
						hasDialog = true; // hack to get correct newline behavior for multiline blocks
				}

				hasBlock = true;
			}
			// NOTE: nested dialog blocks disabled for now
			// else if( state.MatchAhead(Sym.DialogOpen) ) {
			// 	addTextNode();
			// 	state = ParseDialogBlock( state ); // These can be nested (should they though???)

			// 	hasBlock = true;
			// }
			else {
				if ( state.MatchAhead(Sym.Linebreak) ) {
					addTextNode();

					/*
					NOTES:
					linebreaks SHOULD happen on
					- lines with text (including the first or last line)
					- empty lines (that are NOT the first or last line)
					linebreaks should NOT happen on
					- lines with only CODE blocks
					- empty FIRST or LAST lines

					also, apparently:
					- NEVER line break on the last line
					*/
					var isLastLine = (state.Index() + 1) == state.Count();
					// console.log("block " + hasBlock);
					// console.log("dialog " + hasDialog);
					var isEmptyLine = !hasBlock && !hasDialog;
					// console.log("empty " + isEmptyLine);
					var isValidEmptyLine = isEmptyLine && !(isFirstLine || isLastLine);
					// console.log("valid empty " + isValidEmptyLine);
					var shouldAddLinebreak = (hasDialog || isValidEmptyLine) && !isLastLine; // last clause is a hack (but it works - why?)
					// console.log("LINEBREAK? " + shouldAddLinebreak);
					if( shouldAddLinebreak ) {
						// console.log("NEWLINE");
						// console.log("empty? " + isEmptyLine);
						// console.log("dialog? " + hasDialog);
						state.curNode.AddChild( new FuncNode( "br", [] ) ); // use function or character?
					}

					// linebreak logic
					isFirstLine = false;
					hasBlock = false;
					hasDialog = false;

					text = "";
				}
				else {
					text += state.Char();
				}
				state.Step();
			}

		}
		addTextNode();

		// console.log("---- PARSE DIALOG ----");

		// console.log(state);
		return state;
	}

	function ParseDialogBlock(state) {
		var dialogStr = state.ConsumeBlock( Sym.DialogOpen, Sym.DialogClose );

		var dialogState = new ParserState( new BlockNode(BlockMode.Dialog), dialogStr );
		dialogState = ParseDialog( dialogState );

		state.curNode.AddChild( dialogState.rootNode );

		return state;
	}

	function ParseIf(state) {
		var conditionStrings = [];
		var resultStrings = [];
		var curIndex = -1;
		var isNewline = true;
		var isConditionDone = false;
		var codeBlockCount = 0;

		while( !state.Done() ) {
			if(state.Char() === Sym.CodeOpen)
				codeBlockCount++;
			else if(state.Char() === Sym.CodeClose)
				codeBlockCount--;

			var isWhitespace = (state.Char() === " " || state.Char() === "\t");
			var isSkippableWhitespace = isNewline && isWhitespace;
			var isNewListItem = isNewline && (codeBlockCount <= 0) && (state.Char() === Sym.List);

			if(isNewListItem) {
				curIndex++;
				isConditionDone = false;
				conditionStrings[curIndex] = "";
				resultStrings[curIndex] = "";
			}
			else if(curIndex > -1) {
				if(!isConditionDone) {
					if(state.Char() === "?" || state.Char() === "\n") { // TODO: use Sym
						// end of condition
						isConditionDone = true;
					}
					else {
						// read in condition
						conditionStrings[curIndex] += state.Char();
					}
				}
				else {
					// read in result
					if(!isSkippableWhitespace)
						resultStrings[curIndex] += state.Char();
				}
			}

			isNewline = (state.Char() === Sym.Linebreak) || isSkippableWhitespace || isNewListItem;

			state.Step();
		}

		// console.log("PARSE IF:");
		// console.log(conditionStrings);
		// console.log(resultStrings);

		var conditions = [];
		for(var i = 0; i < conditionStrings.length; i++) {
			var str = conditionStrings[i].trim();
			if(str === "else") {
				conditions.push( new ElseNode() );
			}
			else {
				var exp = CreateExpression( str );
				conditions.push( exp );
			}
		}

		var results = [];
		for(var i = 0; i < resultStrings.length; i++) {
			var str = resultStrings[i];
			var dialogBlockState = new ParserState( new BlockNode(BlockMode.Dialog), str );
			dialogBlockState = ParseDialog( dialogBlockState );
			var dialogBlock = dialogBlockState.rootNode;
			results.push( dialogBlock );
		}

		state.curNode.AddChild( new IfNode( conditions, results ) );

		return state;
	}

	function IsSequence(str) {
		// console.log("IsSequence? " + str);
		return str === "sequence" || str === "cycle" || str === "shuffle";
	}

	// TODO: don't forget about eating whitespace
	function ParseSequence(state, sequenceType) {
		// console.log("SEQUENCE " + sequenceType);
		state.Print();

		var isNewline = false;
		var itemStrings = [];
		var curItemIndex = -1; // -1 indicates not reading an item yet
		var codeBlockCount = 0;

		while( !state.Done() ) {
			if(state.Char() === Sym.CodeOpen)
				codeBlockCount++;
			else if(state.Char() === Sym.CodeClose)
				codeBlockCount--;

			var isWhitespace = (state.Char() === " " || state.Char() === "\t");
			var isSkippableWhitespace = isNewline && isWhitespace;
			var isNewListItem = isNewline && (codeBlockCount <= 0) && (state.Char() === Sym.List);

			if(isNewListItem) {
				// console.log("found next list item");
				curItemIndex++;
				itemStrings[curItemIndex] = "";
			}
			else if(curItemIndex > -1) {
				if(!isSkippableWhitespace)
					itemStrings[curItemIndex] += state.Char();
			}

			isNewline = (state.Char() === Sym.Linebreak) || isSkippableWhitespace || isNewListItem;

			// console.log(state.Char());
			state.Step();
		}
		// console.log(itemStrings);
		// console.log("SEQUENCE DONE");

		var options = [];
		for(var i = 0; i < itemStrings.length; i++) {
			var str = itemStrings[i];
			var dialogBlockState = new ParserState( new BlockNode( BlockMode.Dialog, false /* doIndentFirstLine */ ), str );
			dialogBlockState = ParseDialog( dialogBlockState );
			var dialogBlock = dialogBlockState.rootNode;
			options.push( dialogBlock );
		}

		// console.log(options);

		if(sequenceType === "sequence")
			state.curNode.AddChild( new SequenceNode( options ) );
		else if(sequenceType === "cycle")
			state.curNode.AddChild( new CycleNode( options ) );
		else if(sequenceType === "shuffle")
			state.curNode.AddChild( new ShuffleNode( options ) );

		return state;
	}

	function ParseFunction(state, funcName) {
		console.log("~~~ PARSE FUNCTION " + funcName);

		var args = [];

		var curSymbol = "";
		function OnSymbolEnd() {
			curSymbol = curSymbol.trim();
			// console.log("PARAMTER " + curSymbol);
			args.push( StringToValue(curSymbol) );
			// console.log(args);
			curSymbol = "";
		}

		while( !( state.Char() === "\n" || state.Done() ) ) {
			if( state.MatchAhead(Sym.CodeOpen) ) {
				var codeBlockState = new ParserState( new BlockNode(BlockMode.Code), state.ConsumeBlock( Sym.CodeOpen, Sym.CodeClose ) );
				codeBlockState = ParseCode( codeBlockState );
				var codeBlock = codeBlockState.rootNode;
				args.push( codeBlock );
				curSymbol = "";
			}
			else if( state.MatchAhead(Sym.String) ) {
				/* STRING LITERAL */
				var str = state.ConsumeBlock(Sym.String, Sym.String);
				// console.log("STRING " + str);
				args.push( new LiteralNode(str) );
				curSymbol = "";
			}
			else if(state.Char() === " " && curSymbol.length > 0) {
				OnSymbolEnd();
			}
			else {
				curSymbol += state.Char();
			}
			state.Step();
		}

		if(curSymbol.length > 0) {
			OnSymbolEnd();
		}

		state.curNode.AddChild( new FuncNode( funcName, args ) );

		return state;
	}

	function IsValidVariableName(str) {
		var reg = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
		var isValid = reg.test(str);
		// console.log("VALID variable??? " + isValid);
		return isValid;
	}

	function StringToValue(valStr) {
		if(valStr[0] === Sym.CodeOpen) {
			// CODE BLOCK!!!
			var codeStr = (new ParserState( null, valStr )).ConsumeBlock(Sym.CodeOpen, Sym.CodeClose); //hacky
			var codeBlockState = new ParserState( new BlockNode( BlockMode.Code ), codeStr );
			codeBlockState = ParseCode( codeBlockState );
			return codeBlockState.rootNode;
		}
		else if(valStr[0] === Sym.String) {
			// STRING!!
			// console.log("STRING");
			var str = "";
			var i = 1;
			while (i < valStr.length && valStr[i] != Sym.String) {
				str += valStr[i];
				i++;
			}
			// console.log(str);
			return new LiteralNode( str );
		}
		else if(valStr === "true") {
			// BOOL
			return new LiteralNode( true );
		}
		else if(valStr === "false") {
			// BOOL
			return new LiteralNode( false );
		}
		else if( !isNaN(parseFloat(valStr)) ) {
			// NUMBER!!
			// console.log("NUMBER!!! " + valStr);
			return new LiteralNode( parseFloat(valStr) );
		}
		else if(IsValidVariableName(valStr)) {
			// VARIABLE!!
			// console.log("VARIABLE");
			return new VarNode(valStr); // TODO : check for valid potential variables
		}
		else {
			// uh oh
			return new LiteralNode(null);
		}
	}

	var setSymbol = "=";
	var ifSymbol = "?";
	var elseSymbol = ":";
	var operatorSymbols = ["==", ">=", "<=", ">", "<", "-", "+", "/", "*"]; // operators need to be in reverse order of precedence
	function CreateExpression(expStr) {
		console.log("CREATE EXPRESSION --- " + expStr);

		expStr = expStr.trim();

		function IsInsideString(index) {
			var inString = false;
			for(var i = 0; i < expStr.length; i++) {
				if(expStr[i] === Sym.String)
					inString = !inString;

				if(index === i)
					return inString;
			}
			return false;
		}

		function IsInsideCode(index) {
			var count = 0;
			for(var i = 0; i < expStr.length; i++) {
				if(expStr[i] === Sym.CodeOpen)
					count++;
				else if(expStr[i] === Sym.CodeClose)
					count--;

				if(index === i)
					return count > 0;
			}
			return false;
		}

		var operator = null;

		// set is special because other operator can look like it, and it has to go first in the order of operations
		var setIndex = expStr.indexOf(setSymbol);
		if( setIndex > -1 && !IsInsideString(setIndex) && !IsInsideCode(setIndex) ) { // it might be a set operator
			if( expStr[setIndex+1] != "=" && expStr[setIndex-1] != ">" && expStr[setIndex-1] != "<" ) {
				// ok it actually IS a set operator and not ==, >=, or <=
				operator = setSymbol;
				var variableName = expStr.substring(0,setIndex).trim(); // TODO : valid variable name testing
				var left = IsValidVariableName(variableName) ? new VarNode( variableName ) : new LiteralNode(null);
				var right = CreateExpression( expStr.substring(setIndex+setSymbol.length) );
				var exp = new ExpNode( operator, left, right );
				return exp;
			}
		}

		// special if "expression" for single-line if statements
		var ifIndex = expStr.indexOf(ifSymbol);
		if( ifIndex > -1 && !IsInsideString(ifIndex) && !IsInsideCode(ifIndex) ) {
			operator = ifSymbol;
			var conditionStr = expStr.substring(0,ifIndex).trim();
			var conditions = [ CreateExpression(conditionStr) ];

			var resultStr = expStr.substring(ifIndex+ifSymbol.length);
			var results = [];
			function AddResult(str) {
				var dialogBlockState = new ParserState( new BlockNode(BlockMode.Dialog), str );
				dialogBlockState = ParseDialog( dialogBlockState );
				var dialogBlock = dialogBlockState.rootNode;
				results.push( dialogBlock );
			}

			var elseIndex = resultStr.indexOf(elseSymbol); // does this need to test for strings?
			if(elseIndex > -1) {
				conditions.push( new ElseNode() );

				var elseStr = resultStr.substring(elseIndex+elseSymbol.length);
				var resultStr = resultStr.substring(0,elseIndex);

				AddResult( resultStr.trim() );
				AddResult( elseStr.trim() );
			}
			else {
				AddResult( resultStr.trim() );
			}

			return new IfNode( conditions, results, true /*isSingleLine*/ );
		}

		for( var i = 0; (operator == null) && (i < operatorSymbols.length); i++ ) {
			var opSym = operatorSymbols[i];
			var opIndex = expStr.indexOf( opSym );
			if( opIndex > -1 && !IsInsideString(opIndex) && !IsInsideCode(opIndex) ) {
				operator = opSym;
				var left = CreateExpression( expStr.substring(0,opIndex) );
				var right = CreateExpression( expStr.substring(opIndex+opSym.length) );
				var exp = new ExpNode( operator, left, right );
				return exp;
			}
		}

		if( operator == null ) {
			return StringToValue(expStr);
		}
	}
	this.CreateExpression = CreateExpression;

	function IsWhitespace(str) {
		return ( str === " " || str === "\t" || str === "\n" );
	}

	function IsExpression(str) {
		var tempState = new ParserState(null, str); // hacky
		var nonWhitespaceCount = 0;

		while (!tempState.Done()) {
			if( IsWhitespace(tempState.Char()) ) {
				tempState.Step(); // consume whitespace
			}
			else if( tempState.MatchAhead(Sym.CodeOpen) ) {
				tempState.ConsumeBlock( Sym.CodeOpen, Sym.CodeClose );
			}
			else {
				nonWhitespaceCount++;
				tempState.Step();
			}
		}

		var isExpression = nonWhitespaceCount > 0;
		return isExpression;
	}

	function ParseExpression(state) {
		var line = state.Source(); // state.Peak( [Sym.Linebreak] ); // TODO : remove the linebreak thing
		// console.log("EXPRESSION " + line);
		var exp = CreateExpression( line );
		// console.log(exp);
		state.curNode.AddChild( exp );
		state.Step( line.length );
		return state;
	}

	function ParseCode(state) {
		console.log("PARSE CODE --- " + state.Source());

		// skip leading whitespace
		while (IsWhitespace(state.Char())) {
			state.Step();
		}

		if( state.Char() === Sym.List && (state.Peak([]).indexOf("?") > -1) ) { // TODO : symbols? matchahead?
			// console.log("PEAK IF " + state.Peak( ["?"] ));
			state = ParseIf( state );
		}
		else if( environment.HasFunction( state.Peak( [" "] ) ) ) { // TODO --- what about newlines???
			var funcName = state.Peak( [" "] );
			state.Step( funcName.length );
			state = ParseFunction( state, funcName );
		}
		else if( IsSequence( state.Peak( [" ", Sym.Linebreak] ) ) ) {
			var sequenceType = state.Peak( [" ", Sym.Linebreak] );
			state.Step( sequenceType.length );
			state = ParseSequence( state, sequenceType );
		}
		else if (IsExpression(state.Source())) {
			state = ParseExpression(state);
		}
		else {
			// multi-line code block
			while (!state.Done()) {
				if( state.MatchAhead(Sym.CodeOpen) ) {
					state = ParseCodeBlock( state );
				}
				else {
					state.Step();
				}
			}
		}

		// just go to the end now
		while (!state.Done()) {
			state.Step();
		}

		return state;
	}

	function ParseCodeBlock(state) {
		var codeStr = state.ConsumeBlock( Sym.CodeOpen, Sym.CodeClose );

		// console.log("PARSE CODE");
		// console.log(codeStr);

		var codeState = new ParserState( new BlockNode(BlockMode.Code), codeStr );
		codeState = ParseCode( codeState );
		
		state.curNode.AddChild( codeState.rootNode );

		return state;
	}

}

} // Script()
</script>

<script>
function Dialog() {

this.CreateRenderer = function() {
	return new DialogRenderer();
};

this.CreateBuffer = function() {
	return new DialogBuffer();
};

var DialogRenderer = function() {

	// TODO : refactor this eventually? remove everything from struct.. avoid the defaults?
	var textboxInfo = {
		img : null,
		width : 104,
		height : 8+4+2+5, //8 for text, 4 for top-bottom padding, 2 for line padding, 5 for arrow
		top : 12,
		left : 12,
		bottom : 12, //for drawing it from the bottom
		font_scale : 0.5, // we draw font at half-size compared to everything else
		padding_vert : 2,
		padding_horz : 4,
		arrow_height : 5,
	};

	var font = null;
	this.SetFont = function(f) {
		font = f;
		textboxInfo.height = (textboxInfo.padding_vert * 3) + (relativeFontHeight() * 2) + textboxInfo.arrow_height;
		textboxInfo.img = context.createImageData(textboxInfo.width*scale, textboxInfo.height*scale);
	}

	function textScale() {
		return scale * textboxInfo.font_scale;
	}

	function relativeFontWidth() {
		return Math.ceil( font.getWidth() * textboxInfo.font_scale );
	}

	function relativeFontHeight() {
		return Math.ceil( font.getHeight() * textboxInfo.font_scale );
	}

	var context = null;
	this.AttachContext = function(c) {
		context = c;
	};

	this.ClearTextbox = function() {
		if(context == null) return;

		//create new image none exists
		if(textboxInfo.img == null)
			textboxInfo.img = context.createImageData(textboxInfo.width*scale, textboxInfo.height*scale);

		// fill text box with black
		for (var i=0;i<textboxInfo.img.data.length;i+=4)
		{
			textboxInfo.img.data[i+0]=0;
			textboxInfo.img.data[i+1]=0;
			textboxInfo.img.data[i+2]=0;
			textboxInfo.img.data[i+3]=255;
		}
	};

	var isCentered = false;
	this.SetCentered = function(centered) {
		isCentered = centered;
	};

	this.DrawTextbox = function() {
		if(context == null) return;
		if (isCentered) {
			context.putImageData(textboxInfo.img, textboxInfo.left*scale, ((height/2)-(textboxInfo.height/2))*scale);
		}
		else if (player().y < mapsize/2) {
			//bottom
			context.putImageData(textboxInfo.img, textboxInfo.left*scale, (height-textboxInfo.bottom-textboxInfo.height)*scale);
		}
		else {
			//top
			context.putImageData(textboxInfo.img, textboxInfo.left*scale, textboxInfo.top*scale);
		}
	};

	var arrowdata = [
		1,1,1,1,1,
		0,1,1,1,0,
		0,0,1,0,0
	];
	this.DrawNextArrow = function() {
		// console.log("draw arrow!");
		var top = (textboxInfo.height-5) * scale;
		var left = (textboxInfo.width-(5+4)) * scale;
		if (textDirection === TextDirection.RightToLeft) { // RTL hack
			left = 4 * scale;
		}

		for (var y = 0; y < 3; y++) {
			for (var x = 0; x < 5; x++) {
				var i = (y * 5) + x;
				if (arrowdata[i] == 1) {
					//scaling nonsense
					for (var sy = 0; sy < scale; sy++) {
						for (var sx = 0; sx < scale; sx++) {
							var pxl = 4 * ( ((top+(y*scale)+sy) * (textboxInfo.width*scale)) + (left+(x*scale)+sx) );
							textboxInfo.img.data[pxl+0] = 255;
							textboxInfo.img.data[pxl+1] = 255;
							textboxInfo.img.data[pxl+2] = 255;
							textboxInfo.img.data[pxl+3] = 255;
						}
					}
				}
			}
		}
	};

	var text_scale = 2; //using a different scaling factor for text feels like cheating... but it looks better
	this.DrawChar = function(char, row, col, leftPos) {
		char.offset = {
			x: char.base_offset.x,
			y: char.base_offset.y
		}; // compute render offset *every* frame

		char.SetPosition(row,col);
		char.ApplyEffects(effectTime);

		var charData = char.bitmap;

		var top = (4 * scale) + (row * 2 * scale) + (row * font.getHeight() * text_scale) + Math.floor( char.offset.y );
		var left = (4 * scale) + (leftPos * text_scale) + Math.floor( char.offset.x );

		var debug_r = Math.random() * 255;

		for (var y = 0; y < char.height; y++) {
			for (var x = 0; x < char.width; x++) {

				var i = (y * char.width) + x;
				if ( charData[i] == 1 ) {

					//scaling nonsense
					for (var sy = 0; sy < text_scale; sy++) {
						for (var sx = 0; sx < text_scale; sx++) {
							var pxl = 4 * ( ((top+(y*text_scale)+sy) * (textboxInfo.width*scale)) + (left+(x*text_scale)+sx) );
							textboxInfo.img.data[pxl+0] = char.color.r;
							textboxInfo.img.data[pxl+1] = char.color.g;
							textboxInfo.img.data[pxl+2] = char.color.b;
							textboxInfo.img.data[pxl+3] = char.color.a;
						}
					}
				}
				// else {
				// 	// DEBUG

				// 	//scaling nonsense
				// 	for (var sy = 0; sy < text_scale; sy++) {
				// 		for (var sx = 0; sx < text_scale; sx++) {
				// 			var pxl = 4 * ( ((top+(y*text_scale)+sy) * (textboxInfo.width*scale)) + (left+(x*text_scale)+sx) );
				// 			textboxInfo.img.data[pxl+0] = debug_r;
				// 			textboxInfo.img.data[pxl+1] = 0;
				// 			textboxInfo.img.data[pxl+2] = 0;
				// 			textboxInfo.img.data[pxl+3] = 255;
				// 		}
				// 	}
				// }

			}
		}
		
		// call printHandler for character
		char.OnPrint();
	};

	var effectTime = 0; // TODO this variable should live somewhere better
	this.Draw = function(buffer,dt) {
		effectTime += dt;

		this.ClearTextbox();

		buffer.ForEachActiveChar( this.DrawChar );

		if( buffer.CanContinue() )
			this.DrawNextArrow();

		this.DrawTextbox();

		if( buffer.DidPageFinishThisFrame() && onPageFinish != null )
			onPageFinish();
	};

	/* this is a hook for GIF rendering */
	var onPageFinish = null;
	this.SetPageFinishHandler = function(handler) {
		onPageFinish = handler;
	};

	this.Reset = function() {
		effectTime = 0;
		// TODO - anything else?
	}

	// this.CharsPerRow = function() {
	// 	return textboxInfo.charsPerRow;
	// }
}


var DialogBuffer = function() {
	var buffer = [[[]]]; // holds dialog in an array buffer
	var pageIndex = 0;
	var rowIndex = 0;
	var charIndex = 0;
	var nextCharTimer = 0;
	var nextCharMaxTime = 50; // in milliseconds
	var isDialogReadyToContinue = false;
	var activeTextEffects = [];
	var font = null;
	var arabicHandler = new ArabicHandler();
	var onDialogEndCallbacks = [];

	this.SetFont = function(f) {
		font = f;
	}

	this.CurPage = function() { return buffer[ pageIndex ]; };
	this.CurRow = function() { return this.CurPage()[ rowIndex ]; };
	this.CurChar = function() { return this.CurRow()[ charIndex ]; };
	this.CurPageCount = function() { return buffer.length; };
	this.CurRowCount = function() { return this.CurPage().length; };
	this.CurCharCount = function() { return this.CurRow().length; };

	this.ForEachActiveChar = function(handler) { // Iterates over visible characters on the active page
		var rowCount = rowIndex + 1;
		for (var i = 0; i < rowCount; i++) {
			var row = this.CurPage()[i];
			var charCount = (i == rowIndex) ? charIndex+1 : row.length;
			// console.log(charCount);

			var leftPos = 0;
			if (textDirection === TextDirection.RightToLeft) {
				leftPos = 24 * 8; // hack -- I think this is correct?
			}

			for(var j = 0; j < charCount; j++) {
				var char = row[j];
				if(char) {
					if (textDirection === TextDirection.RightToLeft) {
						leftPos -= char.spacing;
					}
					// console.log(j + " " + leftPos);

					// handler( char, i /*rowIndex*/, j /*colIndex*/ );
					handler(char, i /*rowIndex*/, j /*colIndex*/, leftPos)

					if (textDirection === TextDirection.LeftToRight) {
						leftPos += char.spacing;
					}
				}
			}
		}
	}

	this.Reset = function() {
		buffer = [[[]]];
		pageIndex = 0;
		rowIndex = 0;
		charIndex = 0;
		isDialogReadyToContinue = false;

		activeTextEffects = [];

		onDialogEndCallbacks = [];

		isActive = false;
	};

	this.DoNextChar = function() {
		// console.log("DO NEXT CHAR");

		nextCharTimer = 0; //reset timer

		//time to update characters
		if (charIndex + 1 < this.CurCharCount()) {
			//add char to current row
			charIndex++;
		}
		else if (rowIndex + 1 < this.CurRowCount()) {
			//start next row
			rowIndex++;
			charIndex = 0;
		}
		else {
			//the page is full!
			isDialogReadyToContinue = true;
			didPageFinishThisFrame = true;

			// console.log("WAITING FOR INPUT");
		}

		// console.log(this.CurChar());
		if(this.CurChar() != null)
			this.CurChar().OnPrint(); // make sure we hit the callback before we run out of text
	};

	this.Update = function(dt) {
		didPageFinishThisFrame = false;
		didFlipPageThisFrame = false;
		// this.Draw(dt); // TODO move into a renderer object
		if (isDialogReadyToContinue) {
			return; //waiting for dialog to be advanced by player
		}

		nextCharTimer += dt; //tick timer

		if (nextCharTimer > nextCharMaxTime) {
			this.DoNextChar();
		}
	};

	this.Skip = function() {
		console.log("SKIPPP");
		didPageFinishThisFrame = false;
		didFlipPageThisFrame = false;
		// add new characters until you get to the end of the current line of dialog
		while (rowIndex < this.CurRowCount()) {
			this.DoNextChar();

			if(isDialogReadyToContinue) {
				//make sure to push the rowIndex past the end to break out of the loop
				rowIndex++;
				charIndex = 0;
			}
		}
		rowIndex = this.CurRowCount()-1;
		charIndex = this.CurCharCount()-1;
	};

	this.FlipPage = function() {
		didFlipPageThisFrame = true;
		isDialogReadyToContinue = false;
		pageIndex++;
		rowIndex = 0;
		charIndex = 0;
	}

	this.EndDialog = function() {
		isActive = false; // no more text to show... this should be a sign to stop rendering dialog

		for (var i = 0; i < onDialogEndCallbacks.length; i++) {
			onDialogEndCallbacks[i]();
		}
	}

	this.Continue = function() {
		console.log("CONTINUE");
		if (pageIndex + 1 < this.CurPageCount()) {
			//start next page
			this.FlipPage();
			return true; /* hasMoreDialog */
		}
		else {
			//end dialog mode
			this.EndDialog();
			return false; /* hasMoreDialog */
		}
	};

	var isActive = false;
	this.IsActive = function() { return isActive; };

	this.OnDialogEnd = function(callback) {
		if (!isActive) {
			callback();
		}
		else {
			onDialogEndCallbacks.push(callback);
		}
	}

	this.CanContinue = function() { return isDialogReadyToContinue; };

	function DialogChar(effectList) {
		this.effectList = effectList.slice(); // clone effect list (since it can change between chars)

		this.color = { r:255, g:255, b:255, a:255 };
		this.offset = { x:0, y:0 }; // in pixels (screen pixels?)

		this.col = 0;
		this.row = 0;

		this.SetPosition = function(row,col) {
			// console.log("SET POS");
			// console.log(this);
			this.row = row;
			this.col = col;
		}

		this.ApplyEffects = function(time) {
			// console.log("APPLY EFFECTS! " + time);
			for(var i = 0; i < this.effectList.length; i++) {
				var effectName = this.effectList[i];
				// console.log("FX " + effectName);
				TextEffects[ effectName ].DoEffect( this, time );
			}
		}

		var printHandler = null; // optional function to be called once on printing character
		this.SetPrintHandler = function(handler) {
			printHandler = handler;
		}
		this.OnPrint = function() {
			if (printHandler != null) {
				console.log("PRINT HANDLER ---- DIALOG BUFFER");
				printHandler();
				printHandler = null; // only call handler once (hacky)
			}
		}

		this.bitmap = [];
		this.width = 0;
		this.height = 0;
		this.base_offset = { // hacky name
 			x: 0,
			y: 0
		};
		this.spacing = 0;
	}

	function DialogFontChar(font, char, effectList) {
		Object.assign(this, new DialogChar(effectList));

		var charData = font.getChar(char);
		this.bitmap = charData.data;
		this.width = charData.width;
		this.height = charData.height;
		this.base_offset.x = charData.offset.x;
		this.base_offset.y = charData.offset.y;
		this.spacing = charData.spacing;
	}

	function DialogDrawingChar(drawingId, effectList) {
		Object.assign(this, new DialogChar(effectList));

		var imageData = renderer.GetImageSource(drawingId)[0];
		var imageDataFlat = [];
		for (var i = 0; i < imageData.length; i++) {
			// console.log(imageData[i]);
			imageDataFlat = imageDataFlat.concat(imageData[i]);
		}

		this.bitmap = imageDataFlat;
		this.width = 8;
		this.height = 8;
		this.spacing = 8;
	}

	function AddWordToCharArray(charArray,word,effectList) {
		for(var i = 0; i < word.length; i++) {
			charArray.push( new DialogFontChar( font, word[i], effectList ) );
		}
		return charArray;
	}

	function GetCharArrayWidth(charArray) {
		var width = 0;
		for(var i = 0; i < charArray.length; i++) {
			width += charArray[i].spacing;
		}
		return width;
	}

	function GetStringWidth(str) {
		var width = 0;
		for (var i = 0; i < str.length; i++) {
			var charData = font.getChar(str[i]);
			width += charData.spacing;
		}
		return width;
	}

	var pixelsPerRow = 192; // hard-coded fun times!!!

	this.AddDrawing = function(drawingId, onFinishHandler) {
		// console.log("DRAWING ID " + drawingId);

		var curPageIndex = buffer.length - 1;
		var curRowIndex = buffer[curPageIndex].length - 1;
		var curRowArr = buffer[curPageIndex][curRowIndex];

		var drawingChar = new DialogDrawingChar(drawingId, activeTextEffects)
		drawingChar.SetPrintHandler( onFinishHandler );

		var rowLength = GetCharArrayWidth(curRowArr);

		// TODO : clean up copy-pasted code here :/
		if (rowLength + drawingChar.spacing  <= pixelsPerRow || rowLength <= 0)
		{
			//stay on same row
			curRowArr.push( drawingChar );
		}
		else if (curRowIndex == 0)
		{
			//start next row
			buffer[ curPageIndex ][ curRowIndex ] = curRowArr;
			buffer[ curPageIndex ].push( [] );
			curRowIndex++;
			curRowArr = buffer[ curPageIndex ][ curRowIndex ];
			curRowArr.push( drawingChar );
		}
		else {
			//start next page
			buffer[ curPageIndex ][ curRowIndex ] = curRowArr;
			buffer.push( [] );
			curPageIndex++;
			buffer[ curPageIndex ].push( [] );
			curRowIndex = 0;
			curRowArr = buffer[ curPageIndex ][ curRowIndex ];
			curRowArr.push( drawingChar );
		}

		isActive = true; // this feels like a bad way to do this???
	}

	// TODO : convert this into something that takes DialogChar arrays
	this.AddText = function(textStr,onFinishHandler) {
		// console.log("ADD TEXT " + textStr);

		//process dialog so it's easier to display
		var words = textStr.split(" ");

		// var curPageIndex = this.CurPageCount() - 1;
		// var curRowIndex = this.CurRowCount() - 1;
		// var curRowArr = this.CurRow();

		var curPageIndex = buffer.length - 1;
		var curRowIndex = buffer[curPageIndex].length - 1;
		var curRowArr = buffer[curPageIndex][curRowIndex];

		for (var i = 0; i < words.length; i++) {
			var word = words[i];
			if (arabicHandler.ContainsArabicCharacters(word)) {
				word = arabicHandler.ShapeArabicCharacters(word);
			}

			var wordWithPrecedingSpace = ((i == 0) ? "" : " ") + word;
			var wordLength = GetStringWidth( wordWithPrecedingSpace );

			var rowLength = GetCharArrayWidth(curRowArr);

			if (rowLength + wordLength <= pixelsPerRow || rowLength <= 0) {
				//stay on same row
				curRowArr = AddWordToCharArray( curRowArr, wordWithPrecedingSpace, activeTextEffects );
			}
			else if (curRowIndex == 0) {
				//start next row
				buffer[ curPageIndex ][ curRowIndex ] = curRowArr;
				buffer[ curPageIndex ].push( [] );
				curRowIndex++;
				curRowArr = buffer[ curPageIndex ][ curRowIndex ];
				curRowArr = AddWordToCharArray( curRowArr, word, activeTextEffects );
			}
			else {
				//start next page
				buffer[ curPageIndex ][ curRowIndex ] = curRowArr;
				buffer.push( [] );
				curPageIndex++;
				buffer[ curPageIndex ].push( [] );
				curRowIndex = 0;
				curRowArr = buffer[ curPageIndex ][ curRowIndex ];
				curRowArr = AddWordToCharArray( curRowArr, word, activeTextEffects );
			}
		}

		//destroy any empty stuff
		var lastPage = buffer[ buffer.length-1 ];
		var lastRow = lastPage[ lastPage.length-1 ];
		if( lastRow.length == 0 )
			lastPage.splice( lastPage.length-1, 1 );
		if( lastPage.length == 0 )
			buffer.splice( buffer.length-1, 1 );

		//finish up 
		lastPage = buffer[ buffer.length-1 ];
		lastRow = lastPage[ lastPage.length-1 ];
		if( lastRow.length > 0 ) {
			var lastChar = lastRow[ lastRow.length-1 ];
			lastChar.SetPrintHandler( onFinishHandler );
		}

		console.log(buffer);

		isActive = true;
	};

	this.AddLinebreak = function() {
		var lastPage = buffer[ buffer.length-1 ];
		if( lastPage.length <= 1 ) {
			console.log("LINEBREAK - NEW ROW ");
			// add new row
			lastPage.push( [] );
		}
		else {
			// add new page
			buffer.push( [[]] );
		}
		console.log(buffer);

		isActive = true;
	}

	/* new text effects */
	this.HasTextEffect = function(name) {
		return activeTextEffects.indexOf( name ) > -1;
	}
	this.AddTextEffect = function(name) {
		activeTextEffects.push( name );
	}
	this.RemoveTextEffect = function(name) {
		activeTextEffects.splice( activeTextEffects.indexOf( name ), 1 );
	}

	/* this is a hook for GIF rendering */
	var didPageFinishThisFrame = false;
	this.DidPageFinishThisFrame = function(){ return didPageFinishThisFrame; };

	var didFlipPageThisFrame = false;
	this.DidFlipPageThisFrame = function(){ return didFlipPageThisFrame; };

	// this.SetCharsPerRow = function(num){ charsPerRow = num; }; // hacky
};

/* ARABIC */
var ArabicHandler = function() {

	var arabicCharStart = 0x0621;
	var arabicCharEnd = 0x064E;

	var CharacterForm = {
		Isolated : 0,
		Final : 1,
		Initial : 2,
		Middle : 3
	};

	// map glyphs to their character forms
	var glyphForms = {
		/*		 Isolated, Final, Initial, Middle Forms	*/
		0x0621: [0xFE80,0xFE80,0xFE80,0xFE80], /*  HAMZA  */ 
		0x0622: [0xFE81,0xFE82,0xFE81,0xFE82], /*  ALEF WITH MADDA ABOVE  */ 
		0x0623: [0xFE83,0xFE84,0xFE83,0xFE84], /*  ALEF WITH HAMZA ABOVE  */ 
		0x0624: [0xFE85,0xFE86,0xFE85,0xFE86], /*  WAW WITH HAMZA ABOVE  */ 
		0x0625: [0xFE87,0xFE88,0xFE87,0xFE88], /*  ALEF WITH HAMZA BELOW  */ 
		0x0626: [0xFE89,0xFE8A,0xFE8B,0xFE8C], /*  YEH WITH HAMZA ABOVE  */ 
		0x0627: [0xFE8D,0xFE8E,0xFE8D,0xFE8E], /*  ALEF  */ 
		0x0628: [0xFE8F,0xFE90,0xFE91,0xFE92], /*  BEH  */ 
		0x0629: [0xFE93,0xFE94,0xFE93,0xFE94], /*  TEH MARBUTA  */ 
		0x062A: [0xFE95,0xFE96,0xFE97,0xFE98], /*  TEH  */ 
		0x062B: [0xFE99,0xFE9A,0xFE9B,0xFE9C], /*  THEH  */ 
		0x062C: [0xFE9D,0xFE9E,0xFE9F,0xFEA0], /*  JEEM  */ 
		0x062D: [0xFEA1,0xFEA2,0xFEA3,0xFEA4], /*  HAH  */ 
		0x062E: [0xFEA5,0xFEA6,0xFEA7,0xFEA8], /*  KHAH  */ 
		0x062F: [0xFEA9,0xFEAA,0xFEA9,0xFEAA], /*  DAL  */ 
		0x0630: [0xFEAB,0xFEAC,0xFEAB,0xFEAC], /*  THAL */ 
		0x0631: [0xFEAD,0xFEAE,0xFEAD,0xFEAE], /*  RAA  */ 
		0x0632: [0xFEAF,0xFEB0,0xFEAF,0xFEB0], /*  ZAIN  */ 
		0x0633: [0xFEB1,0xFEB2,0xFEB3,0xFEB4], /*  SEEN  */ 
		0x0634: [0xFEB5,0xFEB6,0xFEB7,0xFEB8], /*  SHEEN  */ 
		0x0635: [0xFEB9,0xFEBA,0xFEBB,0xFEBC], /*  SAD  */ 
		0x0636: [0xFEBD,0xFEBE,0xFEBF,0xFEC0], /*  DAD  */ 
		0x0637: [0xFEC1,0xFEC2,0xFEC3,0xFEC4], /*  TAH  */ 
		0x0638: [0xFEC5,0xFEC6,0xFEC7,0xFEC8], /*  ZAH  */ 
		0x0639: [0xFEC9,0xFECA,0xFECB,0xFECC], /*  AIN  */ 
		0x063A: [0xFECD,0xFECE,0xFECF,0xFED0], /*  GHAIN  */ 
		0x063B: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063C: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063D: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063E: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063F: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x0640: [0x0640,0x0640,0x0640,0x0640], /*  TATWEEL  */ 
		0x0641: [0xFED1,0xFED2,0xFED3,0xFED4], /*  FAA  */ 
		0x0642: [0xFED5,0xFED6,0xFED7,0xFED8], /*  QAF  */ 
		0x0643: [0xFED9,0xFEDA,0xFEDB,0xFEDC], /*  KAF  */ 
		0x0644: [0xFEDD,0xFEDE,0xFEDF,0xFEE0], /*  LAM  */ 
		0x0645: [0xFEE1,0xFEE2,0xFEE3,0xFEE4], /*  MEEM  */ 
		0x0646: [0xFEE5,0xFEE6,0xFEE7,0xFEE8], /*  NOON  */ 
		0x0647: [0xFEE9,0xFEEA,0xFEEB,0xFEEC], /*  HEH  */ 
		0x0648: [0xFEED,0xFEEE,0xFEED,0xFEEE], /*  WAW  */ 
		0x0649: [0xFEEF,0xFEF0,0xFBE8,0xFBE9], /*  ALEF MAKSURA  */ 
		0x064A: [0xFEF1,0xFEF2,0xFEF3,0xFEF4], /*  YEH  */ 
		0x064B: [0xFEF5,0xFEF6,0xFEF5,0xFEF6], /*  LAM ALEF MADD*/
		0x064C: [0xFEF7,0xFEF8,0xFEF7,0xFEF8], /*  LAM ALEF HAMZA ABOVE*/
		0x064D: [0xFEF9,0xFEFa,0xFEF9,0xFEFa], /*  LAM ALEF HAMZA BELOW*/
		0x064E: [0xFEFb,0xFEFc,0xFEFb,0xFEFc], /*  LAM ALEF */
	};

	var disconnectedCharacters = [0x0621,0x0622,0x0623,0x0624,0x0625,0x0627,0x062f,0x0630,0x0631,0x0632,0x0648,0x0649,0x064b,0x064c,0x064d,0x064e];

	function IsArabicCharacter(char) {
		var code = char.charCodeAt(0);
		return (code >= arabicCharStart && code <= arabicCharEnd);
	}

	function ContainsArabicCharacters(word) {
		for (var i = 0; i < word.length; i++) {
			if (IsArabicCharacter(word[i])) {
				return true;
			}
		}
		return false;
	}

	function IsDisconnectedCharacter(char) {
		var code = char.charCodeAt(0);
		return disconnectedCharacters.indexOf(code) != -1;
	}

	function ShapeArabicCharacters(word) {
		var shapedWord = "";

		for (var i = 0; i < word.length; i++) {
			if (!IsArabicCharacter(word[i])) {
				shapedWord += word[i];
				continue;
			}

			var connectedToPreviousChar = i-1 >= 0 && IsArabicCharacter(word[i-1]) && !IsDisconnectedCharacter(word[i-1]);

			var connectedToNextChar = i+1 < word.length && IsArabicCharacter(word[i+1]) && !IsDisconnectedCharacter(word[i]);

			var form;
			if (!connectedToPreviousChar && !connectedToNextChar) {
				form = CharacterForm.Isolated;
			}
			else if (connectedToPreviousChar && !connectedToNextChar) {
				form = CharacterForm.Final;
			}
			else if (!connectedToPreviousChar && connectedToNextChar) {
				form = CharacterForm.Initial;
			}
			else if (connectedToPreviousChar && connectedToNextChar) {
				form = CharacterForm.Middle;
			}

			var code = word[i].charCodeAt(0);

			// handle lam alef special case
			if (code == 0x0644 && connectedToNextChar) {
				var nextCode = word[i+1].charCodeAt(0);
				var specialCode = null;
				if (nextCode == 0x0622) {
					// alef madd
					specialCode = glyphForms[0x064b][form];
				}
				else if (nextCode == 0x0623) {
					// hamza above
					specialCode = glyphForms[0x064c][form];
				}
				else if (nextCode == 0x0625) {
					// hamza below
					specialCode = glyphForms[0x064d][form];
				}
				else if (nextCode == 0x0627) {
					// alef
					specialCode = glyphForms[0x064e][form];
				}

				if (specialCode != null) {
					shapedWord += String.fromCharCode(specialCode);
					i++; // skip a step
					continue;
				}
			}

			// hacky?
			if (form === CharacterForm.Isolated) {
				shapedWord += word[i];
				continue;
			}

			var shapedCode = glyphForms[code][form];
			shapedWord += String.fromCharCode(shapedCode);
		}

		return shapedWord;
	}

	this.ContainsArabicCharacters = ContainsArabicCharacters;
	this.ShapeArabicCharacters = ShapeArabicCharacters;
}

/* NEW TEXT EFFECTS */
var TextEffects = new Map();

var RainbowEffect = function() { // TODO - should it be an object or just a method?
	this.DoEffect = function(char,time) {
		// console.log("RAINBOW!!!");
		// console.log(char);
		// console.log(char.color);
		// console.log(char.col);

		var h = Math.abs( Math.sin( (time / 600) - (char.col / 8) ) );
		var rgb = hslToRgb( h, 1, 0.5 );
		char.color.r = rgb[0];
		char.color.g = rgb[1];
		char.color.b = rgb[2];
		char.color.a = 255;
	}
};
TextEffects["rbw"] = new RainbowEffect();

var ColorEffect = function(index) {
	this.DoEffect = function(char) {
		var pal = getPal( curPal() );
		var color = pal[ parseInt( index ) ];
		// console.log(color);
		char.color.r = color[0];
		char.color.g = color[1];
		char.color.b = color[2];
		char.color.a = 255;
	}
};
TextEffects["clr1"] = new ColorEffect(0);
TextEffects["clr2"] = new ColorEffect(1); // TODO : should I use parameters instead of special names?
TextEffects["clr3"] = new ColorEffect(2);

var WavyEffect = function() {
	this.DoEffect = function(char,time) {
		char.offset.y += Math.sin( (time / 250) - (char.col / 2) ) * 4;
	}
};
TextEffects["wvy"] = new WavyEffect();

var ShakyEffect = function() {
	function disturb(func,time,offset,mult1,mult2) {
		return func( (time * mult1) - (offset * mult2) );
	}

	this.DoEffect = function(char,time) {
		char.offset.y += 3
						* disturb(Math.sin,time,char.col,0.1,0.5)
						* disturb(Math.cos,time,char.col,0.3,0.2)
						* disturb(Math.sin,time,char.row,2.0,1.0);
		char.offset.x += 3
						* disturb(Math.cos,time,char.row,0.1,1.0)
						* disturb(Math.sin,time,char.col,3.0,0.7)
						* disturb(Math.cos,time,char.col,0.2,0.3);
	}
};
TextEffects["shk"] = new ShakyEffect();

} // Dialog()
</script>

<script>
/*
TODO
- reset renderer function
- react to changes in: drawings, palettes
- possible future plan: limit size of cache (remove old images)
- change image store path from (pal > col > draw) to (draw > pal > col)
- get rid of old getSpriteImage (etc) methods
- get editor working again [in progress]
- move debug timer class into core (seems useful)
*/

function Renderer(tilesize, scale) {

console.log("!!!!! NEW RENDERER");

var imageStore = { // TODO : rename to imageCache
	source: {},
	render: {}
};

var palettes = null; // TODO : need null checks?
var context = null;

function setPalettes(paletteObj) {
	palettes = paletteObj;

	// TODO : should this really clear out the render cache?
	imageStore.render = {};
}

function getPaletteColor(paletteId, colorIndex) {
	if (palettes[paletteId] === undefined) {
		paletteId = "default";
	}

	var palette = palettes[paletteId];

	if (colorIndex > palette.colors.length) { // do I need this failure case? (seems un-reliable)
		colorIndex = 0;
	}

	var color = palette.colors[colorIndex];

	return {
		r : color[0],
		g : color[1],
		b : color[2]
	};
}

var debugRenderCount = 0;

// TODO : change image store path from (pal > col > draw) to (draw > pal > col)
function renderImage(drawing, paletteId) {
	// debugRenderCount++;
	// console.log("RENDER COUNT " + debugRenderCount);

	var col = drawing.col;
	var colStr = "" + col;
	var pal = paletteId;
	var drwId = drawing.drw;
	var imgSrc = imageStore.source[ drawing.drw ];

	// initialize render cache entry
	if (imageStore.render[drwId] === undefined || imageStore.render[drwId] === null) {
		imageStore.render[drwId] = {};
	}

	if (imageStore.render[drwId][pal] === undefined || imageStore.render[drwId][pal] === null) {
		imageStore.render[drwId][pal] = {};
	}

	// create array of ImageData frames
	imageStore.render[drwId][pal][colStr] = [];

	for (var i = 0; i < imgSrc.length; i++) {
		var frameSrc = imgSrc[i];
		var frameData = imageDataFromImageSource( frameSrc, pal, col );
		imageStore.render[drwId][pal][colStr].push(frameData);
	}
}

function imageDataFromImageSource(imageSource, pal, col) {
	//console.log(imageSource);

	var img = context.createImageData(tilesize*scale,tilesize*scale);

	var backgroundColor = getPaletteColor(pal,0);
	var foregroundColor = getPaletteColor(pal,col);

	for (var y = 0; y < tilesize; y++) {
		for (var x = 0; x < tilesize; x++) {
			var px = imageSource[y][x];
			for (var sy = 0; sy < scale; sy++) {
				for (var sx = 0; sx < scale; sx++) {
					var pxl = (((y * scale) + sy) * tilesize * scale * 4) + (((x*scale) + sx) * 4);
					if ( px === 1 ) {
						img.data[pxl + 0] = foregroundColor.r;
						img.data[pxl + 1] = foregroundColor.g;
						img.data[pxl + 2] = foregroundColor.b;
						img.data[pxl + 3] = 255;
					}
					else { //ch === 0
						img.data[pxl + 0] = backgroundColor.r;
						img.data[pxl + 1] = backgroundColor.g;
						img.data[pxl + 2] = backgroundColor.b;
						img.data[pxl + 3] = 255;
					}
				}
			}
		}
	}

	// convert to canvas: chrome has poor performance when working directly with image data
	var imageCanvas = document.createElement("canvas");
	imageCanvas.width = img.width;
	imageCanvas.height = img.height;
	var imageContext = imageCanvas.getContext("2d");
	imageContext.putImageData(img,0,0);

	return imageCanvas;
}

// TODO : move into core
function undefinedOrNull(x) {
	return x === undefined || x === null;
}

function isImageRendered(drawing, paletteId) {
	var col = drawing.col;
	var colStr = "" + col;
	var pal = paletteId;
	var drwId = drawing.drw;

	if (undefinedOrNull(imageStore.render[drwId]) ||
		undefinedOrNull(imageStore.render[drwId][pal]) ||
		undefinedOrNull(imageStore.render[drwId][pal][colStr])) {
			return false;
	}
	else {
		return true;
	}
}

function getImageSet(drawing, paletteId) {
	return imageStore.render[drawing.drw][paletteId][drawing.col];
}

function getImageFrame(drawing, paletteId, frameOverride) {
	var frameIndex = 0;
	if (drawing.animation.isAnimated) {
		if (frameOverride != undefined && frameOverride != null) {
			frameIndex = frameOverride;
		}
		else {
			frameIndex = drawing.animation.frameIndex;
		}
	}

	return getImageSet(drawing, paletteId)[frameIndex];
}

function getOrRenderImage(drawing, paletteId, frameOverride) {
	if (!isImageRendered(drawing, paletteId)) {
		renderImage(drawing, paletteId);
	}

	return getImageFrame(drawing, paletteId, frameOverride);
}

/* PUBLIC INTERFACE */
this.GetImage = getOrRenderImage;

this.SetPalettes = setPalettes;

this.SetImageSource = function(drawingId, imageSourceData) {
	imageStore.source[drawingId] = imageSourceData;
	imageStore.render[drawingId] = {}; // reset render cache for this image
}

this.GetImageSource = function(drawingId) {
	return imageStore.source[drawingId];
}

this.GetFrameCount = function(drawingId) {
	return imageStore.source[drawingId].length;
}

this.AttachContext = function(ctx) {
	context = ctx;
}

} // Renderer()
</script>

<script>
var xhr; // TODO : remove
var canvas;
var context; // TODO : remove if safe?
var ctx;

var title = "";
var room = {};
var tile = {};
var sprite = {};
var item = {};
var dialog = {};
var palette = { //start off with a default palette
		"default" : {
			name : "default",
			colors : [[0,0,0],[255,255,255],[255,255,255]]
		}
	};
var ending = {};
var variable = {}; // these are starting variable values -- they don't update (or I don't think they will)
var playerId = "A";

var defaultFontName = "ascii_small";
var fontName = defaultFontName;
var TextDirection = {
	LeftToRight : "LTR",
	RightToLeft : "RTL"
};
var textDirection = TextDirection.LeftToRight;

var names = {
	room : new Map(),
	tile : new Map(), // Note: Not currently enabled in the UI
	sprite : new Map(),
	item : new Map(),
	/*dialog : new Map()*/ // TODO
	/*ending : new Map()*/ // TODO
};
function updateNamesFromCurData() {
	names.room = new Map();
	for(id in room) {
		if(room[id].name != undefined && room[id].name != null) {
			names.room.set( room[id].name, id );
		}
	}
	names.tile = new Map();
	for(id in tile) {
		if(tile[id].name != undefined && tile[id].name != null) {
			names.tile.set( tile[id].name, id );
		}
	}
	names.sprite = new Map();
	for(id in sprite) {
		if(sprite[id].name != undefined && sprite[id].name != null) {
			names.sprite.set( sprite[id].name, id );
		}
	}
	names.item = new Map();
	for(id in item) {
		if(item[id].name != undefined && item[id].name != null) {
			names.item.set( item[id].name, id );
		}
	}
}

var spriteStartLocations = {};

/* VERSION */
var version = {
	major: 6, // major changes
	minor: 4 // smaller changes
};
function getEngineVersion() {
	return version.major + "." + version.minor;
}

/* FLAGS */
var flags;
function resetFlags() {
	flags = {
		ROOM_FORMAT : 0 // 0 = non-comma separated, 1 = comma separated
	};
}
resetFlags(); //init flags on load script

// SUPER hacky location... :/
var editorDevFlags = {
	// NONE right now!
};

function clearGameData() {
	title = "";
	room = {};
	tile = {};
	sprite = {};
	item = {};
	dialog = {};
	palette = { //start off with a default palette
		"default" : {
			name : "default",
			colors : [[0,0,0],[255,255,255],[255,255,255]]
		}
	};
	ending = {};
	isEnding = false; //todo - correct place for this?
	variable = {};

	// TODO RENDERER : clear data?

	spriteStartLocations = {};

	names = {
		room : new Map(),
		tile : new Map(),
		sprite : new Map(),
		item : new Map()
	};

	fontName = defaultFontName; // TODO : reset font manager too?
	textDirection = TextDirection.LeftToRight;
}

var width = 128;
var height = 128;
var scale = 4; //this is stupid but necessary
var tilesize = 8;
var mapsize = 16;

var curRoom = "0";

var key = {
	left : 37,
	right : 39,
	up : 38,
	down : 40,
	space : 32,
	enter : 13,
	w : 87,
	a : 65,
	s : 83,
	d : 68,
	r : 82,
	shift : 16,
	ctrl : 17,
	alt : 18,
	cmd : 224
};

var prevTime = 0;
var deltaTime = 0;

//methods used to trigger gif recording
var didPlayerMoveThisFrame = false;
var onPlayerMoved = null;
// var didDialogUpdateThisFrame = false;
var onDialogUpdate = null;

//inventory update UI handles
var onInventoryChanged = null;
var onVariableChanged = null;
var onGameReset = null;

var isPlayerEmbeddedInEditor = false;

var renderer = new Renderer(tilesize, scale);

function getGameNameFromURL() {
	var game = window.location.hash.substring(1);
	// console.log("game name --- " + game);
	return game;
}

function attachCanvas(c) {
	canvas = c;
	canvas.width = width * scale;
	canvas.height = width * scale;
	ctx = canvas.getContext("2d");
	dialogRenderer.AttachContext(ctx);
	renderer.AttachContext(ctx);
}

var curGameData = null;
function load_game(game_data, startWithTitle) {
	curGameData = game_data; //remember the current game (used to reset the game)

	dialogBuffer.Reset();
	scriptInterpreter.ResetEnvironment(); // ensures variables are reset -- is this the best way?

	parseWorld(game_data);

	if (!isPlayerEmbeddedInEditor) {
		// hack to ensure default font is available
		fontManager.AddResource(defaultFontName + fontManager.GetExtension(), document.getElementById(defaultFontName).text.slice(1));
	}

	var font = fontManager.Get( fontName );
	dialogBuffer.SetFont(font);
	dialogRenderer.SetFont(font);

	setInitialVariables();

	// setInterval(updateLoadingScreen, 300); // hack test

	onready(startWithTitle);
}

function reset_cur_game() {
	if (curGameData == null) {
		return; //can't reset if we don't have the game data
	}

	stopGame();
	clearGameData();
	load_game(curGameData);

	if (isPlayerEmbeddedInEditor && onGameReset != null) {
		onGameReset();
	}
}

var update_interval = null;
function onready(startWithTitle) {
	if(startWithTitle === undefined || startWithTitle === null) startWithTitle = true;

	clearInterval(loading_interval);

	input = new InputManager();

	document.addEventListener('keydown', input.onkeydown);
	document.addEventListener('keyup', input.onkeyup);

	if (isPlayerEmbeddedInEditor) {
		canvas.addEventListener('touchstart', input.ontouchstart);
		canvas.addEventListener('touchmove', input.ontouchmove);
		canvas.addEventListener('touchend', input.ontouchend);
	}
	else {
		//borksy modification, fixing touch controls on itch.io mobile embeds

	  	let existingTouchTrigger = document.querySelector('#touchTrigger');
	  	if (existingTouchTrigger === null){
	  	  var touchTrigger = document.createElement("div");
	  	  touchTrigger.setAttribute("id","touchTrigger");
	  	  touchTrigger.setAttribute(
	  	    "style","position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; overflow: hidden;"
	  	  );
	  	  document.body.appendChild(touchTrigger);

	  	  touchTrigger.addEventListener('touchstart', input.ontouchstart);
	  	  touchTrigger.addEventListener('touchmove', input.ontouchmove);
	  	  touchTrigger.addEventListener('touchend', input.ontouchend);
	  	}
	}

	window.onblur = input.onblur;

	update_interval = setInterval(update,16);

	if(startWithTitle) { // used by editor 
		startNarrating(title);
	}
}

function setInitialVariables() {
	for(id in variable) {
		var value = variable[id]; // default to string
		if(value === "true") {
			value = true;
		}
		else if(value === "false") {
			value = false;
		}
		else if(!isNaN(parseFloat(value))) {
			value = parseFloat(value);
		}
		scriptInterpreter.SetVariable(id,value);
	}
	scriptInterpreter.SetOnVariableChangeHandler( onVariableChanged );
}

// TODO: this is likely broken
function breadthFirstSearch(map, from, to) {
	from.trail = [];
	var visited = [];
	var queue = [from];
	visited.push( posToString(from) );

	//console.log( "~ bfs ~");
	//console.log( posToString(from) + " to " + posToString(to) );

	while ( queue.length > 0 ) {

		//grab pos from queue and mark as visited
		var curPos = queue.shift();

		//console.log( posToString(curPos) );
		//console.log( ".. " + pathToString(curPos.trail) );
		//console.log( visited );

		if (curPos.x == to.x && curPos.y == to.y) {
			//found a path!
			var path = curPos.trail.splice(0);
			path.push( curPos );
			return path;
		}

		//look at neighbors
		neighbors(curPos).forEach( function(n) {
			var inBounds = (n.x >= 0 && n.x < 16 && n.y >= 0 && n.y < 16);
			if (inBounds) {
				var noCollision = map[n.y][n.x] <= 0;
				var notVisited = visited.indexOf( posToString(n) ) == -1;
				if (noCollision && notVisited) {
					n.trail = curPos.trail.slice();
					n.trail.push(curPos);
					queue.push( n );
					visited.push( posToString(n) );
				}
			}
		});

	}

	return []; // no path found
}

function posToString(pos) {
	return pos.x + "," + pos.y;
}

function pathToString(path) {
	var s = "";
	for (i in path) {
		s += posToString(path[i]) + " ";
	}
	return s;
}

function neighbors(pos) {
	var neighborList = [];
	neighborList.push( {x:pos.x+1, y:pos.y+0} );
	neighborList.push( {x:pos.x-1, y:pos.y+0} );
	neighborList.push( {x:pos.x+0, y:pos.y+1} );
	neighborList.push( {x:pos.x+0, y:pos.y-1} );
	return neighborList;
}

function collisionMap(roomId) {
	var map = [
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
	];

	for (r in room[roomId].tilemap) {
		var row = room[roomId].tilemap[r];
		for (var c = 0; c < row.length; c++) {
			if (room[roomId].walls.indexOf( row[x] ) != -1) {
				map[r][c] = 1;
			}
		}
	}

	for (id in sprite) {
		var spr = sprite[id];
		if (spr.room === roomId) {
			map[spr.y][spr.x] = 2;
		}
	}

	return map;
}

function getOffset(evt) {
	var offset = { x:0, y:0 };

	var el = evt.target;
	var rect = el.getBoundingClientRect();

	offset.x += rect.left + el.scrollLeft;
	offset.y += rect.top + el.scrollTop;

	offset.x = evt.clientX - offset.x;
	offset.y = evt.clientY - offset.y;

	return offset;
}

function stopGame() {
	console.log("stop GAME!");

	document.removeEventListener('keydown', input.onkeydown);
	document.removeEventListener('keyup', input.onkeyup);

	if (isPlayerEmbeddedInEditor) {
		canvas.removeEventListener('touchstart', input.ontouchstart);
		canvas.removeEventListener('touchmove', input.ontouchmove);
		canvas.removeEventListener('touchend', input.ontouchend);
	}
	else {
		//borksy modifications

    	let existingTouchTrigger = document.querySelector('#touchTrigger');
    	if (existingTouchTrigger !== null){
    		existingTouchTrigger.removeEventListener('touchstart', input.ontouchstart);
    		existingTouchTrigger.removeEventListener('touchmove', input.ontouchmove);
    		existingTouchTrigger.removeEventListener('touchend', input.ontouchend);

    		existingTouchTrigger.parentElement.removeChild(existingTouchTrigger);
    	}
	}

	window.onblur = null;

	clearInterval(update_interval);
}

/* loading animation */
var loading_anim_data = [
	[
		0,1,1,1,1,1,1,0,
		0,0,1,1,1,1,0,0,
		0,0,1,1,1,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,0,0,1,0,0,
		0,0,1,0,0,1,0,0,
		0,1,1,1,1,1,1,0,
	],
	[
		0,1,1,1,1,1,1,0,
		0,0,1,0,0,1,0,0,
		0,0,1,1,1,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,0,0,1,0,0,
		0,0,1,1,1,1,0,0,
		0,1,1,1,1,1,1,0,
	],
	[
		0,1,1,1,1,1,1,0,
		0,0,1,0,0,1,0,0,
		0,0,1,0,0,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,1,1,1,0,0,
		0,0,1,1,1,1,0,0,
		0,1,1,1,1,1,1,0,
	],
	[
		0,1,1,1,1,1,1,0,
		0,0,1,0,0,1,0,0,
		0,0,1,0,0,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,1,1,1,0,0,
		0,0,1,1,1,1,0,0,
		0,1,1,1,1,1,1,0,
	],
	[
		0,0,0,0,0,0,0,0,
		1,0,0,0,0,0,0,1,
		1,1,1,0,0,1,1,1,
		1,1,1,1,1,0,0,1,
		1,1,1,1,1,0,0,1,
		1,1,1,0,0,1,1,1,
		1,0,0,0,0,0,0,1,
		0,0,0,0,0,0,0,0,
	]
];
var loading_anim_frame = 0;
var loading_anim_speed = 500;
var loading_interval = null;

function loadingAnimation() {
	//create image
	var loadingAnimImg = ctx.createImageData(8*scale, 8*scale);
	//draw image
	for (var y = 0; y < 8; y++) {
		for (var x = 0; x < 8; x++) {
			var i = (y * 8) + x;
			if (loading_anim_data[loading_anim_frame][i] == 1) {
				//scaling nonsense
				for (var sy = 0; sy < scale; sy++) {
					for (var sx = 0; sx < scale; sx++) {
						var pxl = 4 * ( (((y*scale)+sy) * (8*scale)) + ((x*scale)+sx) );
						loadingAnimImg.data[pxl+0] = 255;
						loadingAnimImg.data[pxl+1] = 255;
						loadingAnimImg.data[pxl+2] = 255;
						loadingAnimImg.data[pxl+3] = 255;
					}
				}
			}
		}
	}
	//put image on canvas
	ctx.putImageData(loadingAnimImg,scale*(width/2 - 4),scale*(height/2 - 4));
	//update frame
	loading_anim_frame++;
	if (loading_anim_frame >= 5) loading_anim_frame = 0;
}

function updateLoadingScreen() {
	// TODO : in progress
	ctx.fillStyle = "rgb(0,0,0)";
	ctx.fillRect(0,0,canvas.width,canvas.height);

	loadingAnimation();
	drawSprite( getSpriteImage(sprite["a"],"0",0), 8, 8, ctx );
}

function update() {
	var curTime = Date.now();
	deltaTime = curTime - prevTime;

	if (curRoom == null) {
		// in the special case where there is no valid room, end the game
		startNarrating( "", true /*isEnding*/ );
	}

	if (!transition.IsTransitionActive()) {
		updateInput();
	}

	if (transition.IsTransitionActive()) {
		// transition animation takes over everything!
		transition.UpdateTransition(deltaTime);
	}
	else {
		if (!isNarrating && !isEnding) {
			updateAnimation();
			drawRoom( room[curRoom] ); // draw world if game has begun
		}
		else {
			//make sure to still clear screen
			ctx.fillStyle = "rgb(" + getPal(curPal())[0][0] + "," + getPal(curPal())[0][1] + "," + getPal(curPal())[0][2] + ")";
			ctx.fillRect(0,0,canvas.width,canvas.height);
		}

		// if (isDialogMode) { // dialog mode
		if(dialogBuffer.IsActive()) {
			dialogRenderer.Draw( dialogBuffer, deltaTime );
			dialogBuffer.Update( deltaTime );
		}
		else if (!isEnding) {
			moveSprites(); // TODO : I probably need to remove this..
		}

		// keep moving avatar if player holds down button
		if( !dialogBuffer.IsActive() && !isEnding )
		{
			if( curPlayerDirection != Direction.None ) {
				playerHoldToMoveTimer -= deltaTime;

				if( playerHoldToMoveTimer <= 0 )
				{
					movePlayer( curPlayerDirection );
					playerHoldToMoveTimer = 150;
				}
			}
		}
	}

	prevTime = curTime;

	//for gif recording
	if (didPlayerMoveThisFrame && onPlayerMoved != null) {
		onPlayerMoved();
	}
	didPlayerMoveThisFrame = false;

	/* hacky replacement */
	if (onDialogUpdate != null) {
		dialogRenderer.SetPageFinishHandler( onDialogUpdate );
	}

	input.resetKeyPressed();
	input.resetTapReleased();
}

function updateInput() {
	if( dialogBuffer.IsActive() ) {
		if (input.anyKeyPressed() || input.isTapReleased()) {
			/* CONTINUE DIALOG */
			if (dialogBuffer.CanContinue()) {
				var hasMoreDialog = dialogBuffer.Continue();
				if(!hasMoreDialog) {
					// ignore currently held keys UNTIL they are released (stops player from insta-moving)
					input.ignoreHeldKeys();
				}
			}
			else {
				dialogBuffer.Skip();
			}
		}
	}
	else if ( isEnding ) {
		if (input.anyKeyPressed() || input.isTapReleased()) {
			/* RESTART GAME */
			reset_cur_game();
		}
	}
	else {
		/* WALK */
		var prevPlayerDirection = curPlayerDirection;

		if ( input.isKeyDown( key.left ) || input.isKeyDown( key.a ) || input.swipeLeft() ) {
			curPlayerDirection = Direction.Left;
		}
		else if ( input.isKeyDown( key.right ) || input.isKeyDown( key.d ) || input.swipeRight() ) {
			curPlayerDirection = Direction.Right;
		}
		else if ( input.isKeyDown( key.up ) || input.isKeyDown( key.w ) || input.swipeUp() ) {
			curPlayerDirection = Direction.Up;
		}
		else if ( input.isKeyDown( key.down ) || input.isKeyDown( key.s ) || input.swipeDown() ) {
			curPlayerDirection = Direction.Down;
		}
		else {
			curPlayerDirection = Direction.None;
		}

		if (curPlayerDirection != Direction.None && curPlayerDirection != prevPlayerDirection) {
			movePlayer( curPlayerDirection );
			playerHoldToMoveTimer = 500;
		}
	}
}

var animationCounter = 0;
var animationTime = 400;
function updateAnimation() {
	animationCounter += deltaTime;

	if ( animationCounter >= animationTime ) {

		// animate sprites
		for (id in sprite) {
			var spr = sprite[id];
			if (spr.animation.isAnimated) {
				spr.animation.frameIndex = ( spr.animation.frameIndex + 1 ) % spr.animation.frameCount;
			}
		}

		// animate tiles
		for (id in tile) {
			var til = tile[id];
			if (til.animation.isAnimated) {
				til.animation.frameIndex = ( til.animation.frameIndex + 1 ) % til.animation.frameCount;
			}
		}

		// animate items
		for (id in item) {
			var itm = item[id];
			if (itm.animation.isAnimated) {
				itm.animation.frameIndex = ( itm.animation.frameIndex + 1 ) % itm.animation.frameCount;
			}
		}

		// reset counter
		animationCounter = 0;

	}
}

function resetAllAnimations() {
	for (id in sprite) {
		var spr = sprite[id];
		if (spr.animation.isAnimated) {
			spr.animation.frameIndex = 0;
		}
	}

	for (id in tile) {
		var til = tile[id];
		if (til.animation.isAnimated) {
			til.animation.frameIndex = 0;
		}
	}

	for (id in item) {
		var itm = item[id];
		if (itm.animation.isAnimated) {
			itm.animation.frameIndex = 0;
		}
	}
}

var moveCounter = 0;
var moveTime = 200;
function moveSprites() {
	moveCounter += deltaTime;

	if (moveCounter >= moveTime) {

		for (id in sprite) {
			var spr = sprite[id];
			if (spr.walkingPath.length > 0) {
				//move sprite
				var nextPos = spr.walkingPath.shift();
				spr.x = nextPos.x;
				spr.y = nextPos.y;


				var end = getEnding( spr.room, spr.x, spr.y );
				var ext = getExit( spr.room, spr.x, spr.y );
				var itmIndex = getItemIndex( spr.room, spr.x, spr.y );
				if (end) { //if the sprite hits an ending
					if (id === playerId) { // only the player can end the game
						startNarrating( ending[end.id], true /*isEnding*/ );
					}
				}
				else if (ext) { //if the sprite hits an exit
					//move it to another scene
					spr.room = ext.dest.room;
					spr.x = ext.dest.x;
					spr.y = ext.dest.y;
					if (id === playerId) {
						//if the player changes scenes, change the visible scene
						curRoom = ext.dest.room;
					}
				}
				else if(itmIndex > -1) {
					var itm = room[ spr.room ].items[ itmIndex ];
					room[ spr.room ].items.splice( itmIndex, 1 );
					if( spr.inventory[ itm.id ] ) {
						spr.inventory[ itm.id ] += 1;
					}
					else {
						spr.inventory[ itm.id ] = 1;
					}

					if (onInventoryChanged != null) {
						onInventoryChanged( itm.id );
					}

					if (id === playerId) {
						startItemDialog( itm.id  /*itemId*/ );
					}

					// stop moving : is this a good idea?
					spr.walkingPath = [];
				}

				if (id === playerId) didPlayerMoveThisFrame = true;
			}
		}

		moveCounter = 0;
	}

}

function getSpriteAt(x,y) {
	for (id in sprite) {
		var spr = sprite[id];
		if (spr.room === curRoom) {
			if (spr.x == x && spr.y == y) {
				return id;
			}
		}
	}
	return null;
}

var Direction = {
	None : -1,
	Up : 0,
	Down : 1,
	Left : 2,
	Right : 3
};

var curPlayerDirection = Direction.None;
var playerHoldToMoveTimer = 0;

var InputManager = function() {
	var self = this;

	var pressed;
	var ignored;
	var newKeyPress;
	var touchState;

	function resetAll() {
		pressed = {};
		ignored = {};
		newKeyPress = false;

		touchState = {
			isDown : false,
			startX : 0,
			startY : 0,
			curX : 0,
			curY : 0,
			swipeDistance : 30,
			swipeDirection : Direction.None,
			tapReleased : false
		};
	}
	resetAll();

	function stopWindowScrolling(e) {
		if(e.keyCode == key.left || e.keyCode == key.right || e.keyCode == key.up || e.keyCode == key.down || !isPlayerEmbeddedInEditor)
			e.preventDefault();
	}

	function tryRestartGame(e) {
		/* RESTART GAME */
		if ( e.keyCode === key.r && ( e.getModifierState("Control") || e.getModifierState("Meta") ) ) {
			if ( confirm("Restart the game?") ) {
				reset_cur_game();
			}
		}
	}

	function eventIsModifier(event) {
		return (event.keyCode == key.shift || event.keyCode == key.ctrl || event.keyCode == key.alt || event.keyCode == key.cmd);
	}

	function isModifierKeyDown() {
		return ( self.isKeyDown(key.shift) || self.isKeyDown(key.ctrl) || self.isKeyDown(key.alt) || self.isKeyDown(key.cmd) );
	}

	this.ignoreHeldKeys = function() {
		for (var key in pressed) {
			if (pressed[key]) { // only ignore keys that are actually held
				ignored[key] = true;
				// console.log("IGNORE -- " + key);
			}
		}
	}

	this.onkeydown = function(event) {
		// console.log("KEYDOWN -- " + event.keyCode);

		stopWindowScrolling(event);

		tryRestartGame(event);

		// Special keys being held down can interfere with keyup events and lock movement
		// so just don't collect input when they're held
		{
			if (isModifierKeyDown()) {
				return;
			}

			if (eventIsModifier(event)) {
				resetAll();
			}
		}

		if (ignored[event.keyCode]) {
			return;
		}

		if (!self.isKeyDown(event.keyCode)) {
			newKeyPress = true;
		}

		pressed[event.keyCode] = true;
		ignored[event.keyCode] = false;
	}

	this.onkeyup = function(event) {
		// console.log("KEYUP -- " + event.keyCode);
		pressed[event.keyCode] = false;
		ignored[event.keyCode] = false;
	}

	this.ontouchstart = function(event) {
		event.preventDefault();

		if( event.changedTouches.length > 0 ) {
			touchState.isDown = true;

			touchState.startX = touchState.curX = event.changedTouches[0].clientX;
			touchState.startY = touchState.curY = event.changedTouches[0].clientY;

			touchState.swipeDirection = Direction.None;
		}
	}

	this.ontouchmove = function(event) {
		event.preventDefault();

		if( touchState.isDown && event.changedTouches.length > 0 ) {
			touchState.curX = event.changedTouches[0].clientX;
			touchState.curY = event.changedTouches[0].clientY;

			var prevDirection = touchState.swipeDirection;

			if( touchState.curX - touchState.startX <= -touchState.swipeDistance ) {
				touchState.swipeDirection = Direction.Left;
			}
			else if( touchState.curX - touchState.startX >= touchState.swipeDistance ) {
				touchState.swipeDirection = Direction.Right;
			}
			else if( touchState.curY - touchState.startY <= -touchState.swipeDistance ) {
				touchState.swipeDirection = Direction.Up;
			}
			else if( touchState.curY - touchState.startY >= touchState.swipeDistance ) {
				touchState.swipeDirection = Direction.Down;
			}

			if( touchState.swipeDirection != prevDirection ) {
				// reset center so changing directions is easier
				touchState.startX = touchState.curX;
				touchState.startY = touchState.curY;
			}
		}
	}

	this.ontouchend = function(event) {
		event.preventDefault();

		touchState.isDown = false;

		if( touchState.swipeDirection == Direction.None ) {
			// tap!
			touchState.tapReleased = true;
		}

		touchState.swipeDirection = Direction.None;
	}

	this.isKeyDown = function(keyCode) {
		return pressed[keyCode] != null && pressed[keyCode] == true && (ignored[keyCode] == null || ignored[keyCode] == false);
	}

	this.anyKeyPressed = function() {
		return newKeyPress;
	}

	this.resetKeyPressed = function() {
		newKeyPress = false;
	}

	this.swipeLeft = function() {
		return touchState.swipeDirection == Direction.Left;
	}

	this.swipeRight = function() {
		return touchState.swipeDirection == Direction.Right;
	}

	this.swipeUp = function() {
		return touchState.swipeDirection == Direction.Up;
	}

	this.swipeDown = function() {
		return touchState.swipeDirection == Direction.Down;
	}

	this.isTapReleased = function() {
		return touchState.tapReleased;
	}

	this.resetTapReleased = function() {
		touchState.tapReleased = false;
	}

	this.onblur = function() {
		// console.log("~~~ BLUR ~~");
		resetAll();
	}
}
var input = null;

function movePlayer(direction) {
	if (player().room == null || !Object.keys(room).includes(player().room)) {
		return; // player room is missing or invalid.. can't move them!
	}

	var spr = null;

	if ( curPlayerDirection == Direction.Left && !(spr = getSpriteLeft()) && !isWallLeft()) {
		player().x -= 1;
		didPlayerMoveThisFrame = true;
	}
	else if ( curPlayerDirection == Direction.Right && !(spr = getSpriteRight()) && !isWallRight()) {
		player().x += 1;
		didPlayerMoveThisFrame = true;
	}
	else if ( curPlayerDirection == Direction.Up && !(spr = getSpriteUp()) && !isWallUp()) {
		player().y -= 1;
		didPlayerMoveThisFrame = true;
	}
	else if ( curPlayerDirection == Direction.Down && !(spr = getSpriteDown()) && !isWallDown()) {
		player().y += 1;
		didPlayerMoveThisFrame = true;
	}
	
	var ext = getExit( player().room, player().x, player().y );
	var end = getEnding( player().room, player().x, player().y );
	// TODO : vNext
	// var eff = getEffect( player().room, player().x, player().y );
	var itmIndex = getItemIndex( player().room, player().x, player().y );

	// do items first, because you can pick up an item AND go through a door
	if (itmIndex > -1) {
		// TODO pick up items (what about touch?)
		// console.log("HIT ITM ");
		// console.log( itmIndex );
		var itm = room[ player().room ].items[ itmIndex ];
		// console.log(itm);
		room[ player().room ].items.splice( itmIndex, 1 );
		if( player().inventory[ itm.id ] ) {
			player().inventory[ itm.id ] += 1;
		}
		else {
			player().inventory[ itm.id ] = 1;
		}

		if(onInventoryChanged != null) {
			onInventoryChanged( itm.id );
		}

		startItemDialog( itm.id  /*itemId*/ );

		// console.log( player().inventory );
	}

	if (end) {
		startNarrating( ending[end.id], true /*isEnding*/ );
	}
	else if (ext) {
		movePlayerThroughExit(ext);
	}
	// TODO : vNext
	// else if (eff) {
	// 	startDialog( script[eff.id].source, eff.id );
	// }
	else if (spr) {
		startSpriteDialog( spr /*spriteId*/ );
	}
}

var transition = new TransitionManager();

function movePlayerThroughExit(ext) {
	var GoToDest = function() {
		if (ext.transition_effect != null) {
			transition.BeginTransition(player().room, player().x, player().y, ext.dest.room, ext.dest.x, ext.dest.y, ext.transition_effect);
			transition.UpdateTransition(0);
		}

		player().room = ext.dest.room;
		player().x = ext.dest.x;
		player().y = ext.dest.y;
		curRoom = ext.dest.room;
	};

	// TODO : vNext
	// if(ext.script_id != null && script[ext.script_id]){
	// 	var scriptSourceStr = script[ext.script_id].source;
	// 	startDialog(scriptSourceStr, ext.script_id, function(isExitUnlocked) {
	// 		if (isExitUnlocked == true) {
	// 			GoToDest();
	// 		}
	// 	});
	// }
	// else {
	// 	GoToDest();
	// }

	GoToDest();
}

function getItemIndex( roomId, x, y ) {
	for( var i = 0; i < room[roomId].items.length; i++ ) {
		var itm = room[roomId].items[i];
		if ( itm.x == x && itm.y == y)
			return i;
	}
	return -1;
}

function getSpriteLeft() { //repetitive?
	return getSpriteAt( player().x - 1, player().y );
}

function getSpriteRight() {
	return getSpriteAt( player().x + 1, player().y );
}

function getSpriteUp() {
	return getSpriteAt( player().x, player().y - 1 );
}

function getSpriteDown() {
	return getSpriteAt( player().x, player().y + 1 );
}

function isWallLeft() {
	return (player().x - 1 < 0) || isWall( player().x - 1, player().y );
}

function isWallRight() {
	return (player().x + 1 >= 16) || isWall( player().x + 1, player().y );
}

function isWallUp() {
	return (player().y - 1 < 0) || isWall( player().x, player().y - 1 );
}

function isWallDown() {
	return (player().y + 1 >= 16) || isWall( player().x, player().y + 1 );
}

function isWall(x,y,roomId) {
	if(roomId == undefined || roomId == null)
		roomId = curRoom;

	var tileId = getTile( x, y );

	if( tileId === '0' )
		return false; // Blank spaces aren't walls, ya doofus

	if( tile[tileId].isWall === undefined || tile[tileId].isWall === null ) {
		// No wall-state defined: check room-specific walls
		var i = room[roomId].walls.indexOf( getTile(x,y) );
		return i > -1;
	}

	// Otherwise, use the tile's own wall-state
	return tile[tileId].isWall;
}

function getItem(roomId,x,y) {
	for (i in room[roomId].items) {
		var item = room[roomId].items[i];
		if (x == item.x && y == item.y) {
			return item;
		}
	}
	return null;
}

function getExit(roomId,x,y) {
	for (i in room[roomId].exits) {
		var e = room[roomId].exits[i];
		if (x == e.x && y == e.y) {
			return e;
		}
	}
	return null;
}

function getEnding(roomId,x,y) {
	for (i in room[roomId].endings) {
		var e = room[roomId].endings[i];
		if (x == e.x && y == e.y) {
			return e;
		}
	}
	return null;
}

// TODO : vNext
// function getEffect(roomId,x,y) {
// 	for (i in room[roomId].effects) {
// 		var e = room[roomId].effects[i];
// 		if (x == e.x && y == e.y) {
// 			return e;
// 		}
// 	}
// 	return null;
// }

function getTile(x,y) {
	// console.log(x + " " + y);
	var t = getRoom().tilemap[y][x];
	return t;
}

function player() {
	return sprite[playerId];
}

// Sort of a hack for legacy palette code (when it was just an array)
function getPal(id) {
	if (palette[id] === undefined) {
		id = "default";
	}

	return palette[ id ].colors;
}

function getRoom() {
	return room[curRoom];
}

function isSpriteOffstage(id) {
	return sprite[id].room == null;
}

function parseWorld(file) {
	// console.log("~~~ PARSE WORLD ~~~");
	// console.log(file);

	// var parseTimer = new Timer();

	spriteStartLocations = {};

	resetFlags();

	var versionNumber = 0;

	var lines = file.split("\n");
	var i = 0;
	while (i < lines.length) {
		var curLine = lines[i];

		// console.log(lines[i]);

		if (i == 0) {
			i = parseTitle(lines, i);
		}
		else if (curLine.length <= 0 || curLine.charAt(0) === "#") {
			// collect version number (from a comment.. hacky I know)
			if (curLine.indexOf("# BITSY VERSION ") != -1) {
				versionNumber = parseFloat(curLine.replace("# BITSY VERSION ", ""));
			}

			//skip blank lines & comments
			i++;
		}
		else if (getType(curLine) == "PAL") {
			i = parsePalette(lines, i);
		}
		else if (getType(curLine) === "ROOM" || getType(curLine) === "SET") { //SET for back compat
			i = parseRoom(lines, i);
		}
		else if (getType(curLine) === "TIL") {
			i = parseTile(lines, i);
		}
		else if (getType(curLine) === "SPR") {
			i = parseSprite(lines, i);
		}
		else if (getType(curLine) === "ITM") {
			i = parseItem(lines, i);
		}
		else if (getType(curLine) === "DRW") {
			i = parseDrawing(lines, i);
		}
		else if (getType(curLine) === "DLG") {
			i = parseDialog(lines, i);
		}
		else if (getType(curLine) === "END") {
			i = parseEnding(lines, i);
		}
		// TODO: vNext
		// else if (getType(curLine) === "PRG") {
		// 	i = parseScript(lines, i);
		// }
		else if (getType(curLine) === "VAR") {
			i = parseVariable(lines, i);
		}
		else if (getType(curLine) === "DEFAULT_FONT") {
			i = parseFontName(lines, i);
		}
		else if (getType(curLine) === "TEXT_DIRECTION") {
			i = parseTextDirection(lines, i);
		}
		else if (getType(curLine) === "FONT") {
			i = parseFontData(lines, i);
		}
		else if (getType(curLine) === "!") {
			i = parseFlag(lines, i);
		}
		else {
			i++;
		}
	}

	placeSprites();

	var roomIds = Object.keys(room);
	if (player() != undefined && player().room != null && roomIds.includes(player().room)) {
		// player has valid room
		curRoom = player().room;
	}
	else if (roomIds.length > 0) {
		// player not in any room! what the heck
		curRoom = roomIds[0];
	}
	else {
		// uh oh there are no rooms I guess???
		curRoom = null;
	}

	console.log("START ROOM " + curRoom);

	renderer.SetPalettes(palette);

	// console.log(names);

	// console.log("~~~~~ PARSE TIME " + parseTimer.Milliseconds());

	return versionNumber;
}

//TODO this is in progress and doesn't support all features
function serializeWorld(skipFonts) {
	if (skipFonts === undefined || skipFonts === null)
		skipFonts = false;

	var worldStr = "";
	/* TITLE */
	worldStr += title + "\n";
	worldStr += "\n";
	/* VERSION */
	worldStr += "# BITSY VERSION " + getEngineVersion() + "\n"; // add version as a comment for debugging purposes
	worldStr += "\n";
	/* FLAGS */
	for (f in flags) {
		worldStr += "! " + f + " " + flags[f] + "\n";
	}
	worldStr += "\n"
	/* FONT */
	if (fontName != defaultFontName) {
		worldStr += "DEFAULT_FONT " + fontName + "\n";
		worldStr += "\n"
	}
	if (textDirection != TextDirection.LeftToRight) {
		worldStr += "TEXT_DIRECTION " + textDirection + "\n";
		worldStr += "\n"
	}
	/* PALETTE */
	for (id in palette) {
		if (id != "default") {
			worldStr += "PAL " + id + "\n";
			if( palette[id].name != null )
				worldStr += "NAME " + palette[id].name + "\n";
			for (i in getPal(id)) {
				for (j in getPal(id)[i]) {
					worldStr += getPal(id)[i][j];
					if (j < 2) worldStr += ",";
				}
				worldStr += "\n";
			}
			worldStr += "\n";
		}
	}
	/* ROOM */
	for (id in room) {
		worldStr += "ROOM " + id + "\n";
		if ( flags.ROOM_FORMAT == 0 ) {
			// old non-comma separated format
			for (i in room[id].tilemap) {
				for (j in room[id].tilemap[i]) {
					worldStr += room[id].tilemap[i][j];	
				}
				worldStr += "\n";
			}
		}
		else if ( flags.ROOM_FORMAT == 1 ) {
			// new comma separated format
			for (i in room[id].tilemap) {
				for (j in room[id].tilemap[i]) {
					worldStr += room[id].tilemap[i][j];
					if (j < room[id].tilemap[i].length-1) worldStr += ","
				}
				worldStr += "\n";
			}
		}
		if (room[id].name != null) {
			/* NAME */
			worldStr += "NAME " + room[id].name + "\n";
		}
		if (room[id].walls.length > 0) {
			/* WALLS */
			worldStr += "WAL ";
			for (j in room[id].walls) {
				worldStr += room[id].walls[j];
				if (j < room[id].walls.length-1) {
					worldStr += ",";
				}
			}
			worldStr += "\n";
		}
		if (room[id].items.length > 0) {
			/* ITEMS */
			for (j in room[id].items) {
				var itm = room[id].items[j];
				worldStr += "ITM " + itm.id + " " + itm.x + "," + itm.y;
				worldStr += "\n";
			}
		}
		if (room[id].exits.length > 0) {
			/* EXITS */
			for (j in room[id].exits) {
				var e = room[id].exits[j];
				if ( isExitValid(e) ) {
					worldStr += "EXT " + e.x + "," + e.y + " " + e.dest.room + " " + e.dest.x + "," + e.dest.y;
					if (e.transition_effect != undefined && e.transition_effect != null) {
						worldStr += " FX " + e.transition_effect;
					}
					// TODO : vNext
					// if (e.script_id != undefined && e.script_id != null) {
					// 	worldStr += " PRG " + e.script_id;
					// }
					worldStr += "\n";
				}
			}
		}
		if (room[id].endings.length > 0) {
			/* ENDINGS */
			for (j in room[id].endings) {
				var e = room[id].endings[j];
				// todo isEndingValid
				worldStr += "END " + e.id + " " + e.x + "," + e.y;
				worldStr += "\n";
			}
		}
		// TODO : vNext
		// if (room[id].effects.length > 0) {
		// 	/* EFFECTS */
		// 	for (j in room[id].effects) {
		// 		var e = room[id].effects[j];
		// 		worldStr += "EFF " + e.id + " " + e.x + "," + e.y;
		// 		worldStr += "\n";
		// 	}
		// }
		if (room[id].pal != null && room[id].pal != "default") {
			/* PALETTE */
			worldStr += "PAL " + room[id].pal + "\n";
		}
		worldStr += "\n";
	}
	/* TILES */
	for (id in tile) {
		worldStr += "TIL " + id + "\n";
		worldStr += serializeDrawing( "TIL_" + id );
		if (tile[id].name != null && tile[id].name != undefined) {
			/* NAME */
			worldStr += "NAME " + tile[id].name + "\n";
		}
		if (tile[id].isWall != null && tile[id].isWall != undefined) {
			/* WALL */
			worldStr += "WAL " + tile[id].isWall + "\n";
		}
		if (tile[id].col != null && tile[id].col != undefined && tile[id].col != 1) {
			/* COLOR OVERRIDE */
			worldStr += "COL " + tile[id].col + "\n";
		}
		worldStr += "\n";
	}
	/* SPRITES */
	for (id in sprite) {
		worldStr += "SPR " + id + "\n";
		worldStr += serializeDrawing( "SPR_" + id );
		if (sprite[id].name != null && sprite[id].name != undefined) {
			/* NAME */
			worldStr += "NAME " + sprite[id].name + "\n";
		}
		if (sprite[id].dlg != null) {
			worldStr += "DLG " + sprite[id].dlg + "\n";
		}
		if (sprite[id].room != null) {
			/* SPRITE POSITION */
			worldStr += "POS " + sprite[id].room + " " + sprite[id].x + "," + sprite[id].y + "\n";
		}
		if (sprite[id].inventory != null) {
			for(itemId in sprite[id].inventory) {
				worldStr += "ITM " + itemId + " " + sprite[id].inventory[itemId] + "\n";
			}
		}
		if (sprite[id].col != null && sprite[id].col != undefined && sprite[id].col != 2) {
			/* COLOR OVERRIDE */
			worldStr += "COL " + sprite[id].col + "\n";
		}
		worldStr += "\n";
	}
	/* ITEMS */
	for (id in item) {
		worldStr += "ITM " + id + "\n";
		worldStr += serializeDrawing( "ITM_" + id );
		if (item[id].name != null && item[id].name != undefined) {
			/* NAME */
			worldStr += "NAME " + item[id].name + "\n";
		}
		if (item[id].dlg != null) {
			worldStr += "DLG " + item[id].dlg + "\n";
		}
		if (item[id].col != null && item[id].col != undefined && item[id].col != 2) {
			/* COLOR OVERRIDE */
			worldStr += "COL " + item[id].col + "\n";
		}
		worldStr += "\n";
	}
	/* DIALOG */
	for (id in dialog) {
		worldStr += "DLG " + id + "\n";
		worldStr += dialog[id] + "\n";
		worldStr += "\n";
	}
	/* ENDINGS */
	for (id in ending) {
		worldStr += "END " + id + "\n";
		worldStr += ending[id] + "\n";
		worldStr += "\n";
	}
	// TODO : vNext
	// /* SCRIPTS */
	// for (id in script) {
	// 	if (script[id].type == ScriptType.Dialogue) {
	// 		worldStr += "DLG " + id + "\n";
	// 	}
	// 	else if (script[id].type == ScriptType.Ending) {
	// 		worldStr += "END " + id + "\n";
	// 	}
	// 	else {
	// 		worldStr += "PRG " + id + "\n";
	// 	}
	// 	worldStr += script[id].source + "\n";
	// 	worldStr += "\n";
	// }
	/* VARIABLES */
	for (id in variable) {
		worldStr += "VAR " + id + "\n";
		worldStr += variable[id] + "\n";
		worldStr += "\n";
	}
	/* FONT */
	// TODO : support multiple fonts
	if (fontName != defaultFontName && !skipFonts) {
		worldStr += fontManager.GetData(fontName);
	}

	return worldStr;
}

function serializeDrawing(drwId) {
	var imageSource = renderer.GetImageSource(drwId);
	var drwStr = "";
	for (f in imageSource) {
		for (y in imageSource[f]) {
			var rowStr = "";
			for (x in imageSource[f][y]) {
				rowStr += imageSource[f][y][x];
			}
			drwStr += rowStr + "\n";
		}
		if (f < (imageSource.length-1)) drwStr += ">\n";
	}
	return drwStr;
}

function isExitValid(e) {
	var hasValidStartPos = e.x >= 0 && e.x < 16 && e.y >= 0 && e.y < 16;
	var hasDest = e.dest != null;
	var hasValidRoomDest = (e.dest.room != null && e.dest.x >= 0 && e.dest.x < 16 && e.dest.y >= 0 && e.dest.y < 16);
	return hasValidStartPos && hasDest && hasValidRoomDest;
}

function placeSprites() {
	for (id in spriteStartLocations) {
		//console.log(id);
		//console.log( spriteStartLocations[id] );
		//console.log(sprite[id]);
		sprite[id].room = spriteStartLocations[id].room;
		sprite[id].x = spriteStartLocations[id].x;
		sprite[id].y = spriteStartLocations[id].y;
		//console.log(sprite[id]);
	}
}

/* ARGUMENT GETTERS */
function getType(line) {
	return getArg(line,0);
}

function getId(line) {
	return getArg(line,1);
}

function getArg(line,arg) {
	return line.split(" ")[arg];
}

function getCoord(line,arg) {
	return getArg(line,arg).split(",");
}

function parseTitle(lines, i) {
	title = lines[i];
	i++;
	return i;
}

function parseRoom(lines, i) {
	var id = getId(lines[i]);
	room[id] = {
		id : id,
		tilemap : [],
		walls : [],
		exits : [],
		endings : [],
		// effects : [], // TODO vNext
		items : [],
		pal : null,
		name : null
	};
	i++;

	// create tile map
	if ( flags.ROOM_FORMAT == 0 ) {
		// old way: no commas, single char tile ids
		var end = i + mapsize;
		var y = 0;
		for (; i<end; i++) {
			room[id].tilemap.push( [] );
			for (x = 0; x<mapsize; x++) {
				room[id].tilemap[y].push( lines[i].charAt(x) );
			}
			y++;
		}
	}
	else if ( flags.ROOM_FORMAT == 1 ) {
		// new way: comma separated, multiple char tile ids
		var end = i + mapsize;
		var y = 0;
		for (; i<end; i++) {
			room[id].tilemap.push( [] );
			var lineSep = lines[i].split(",");
			for (x = 0; x<mapsize; x++) {
				room[id].tilemap[y].push( lineSep[x] );
			}
			y++;
		}
	}

	while (i < lines.length && lines[i].length > 0) { //look for empty line
		// console.log(getType(lines[i]));
		if (getType(lines[i]) === "SPR") {
			/* NOTE SPRITE START LOCATIONS */
			var sprId = getId(lines[i]);
			if (sprId.indexOf(",") == -1 && lines[i].split(" ").length >= 3) { //second conditional checks for coords
				/* PLACE A SINGLE SPRITE */
				var sprCoord = lines[i].split(" ")[2].split(",");
				spriteStartLocations[sprId] = {
					room : id,
					x : parseInt(sprCoord[0]),
					y : parseInt(sprCoord[1])
				};
			}
			else if ( flags.ROOM_FORMAT == 0 ) { // TODO: right now this shortcut only works w/ the old comma separate format
				/* PLACE MULTIPLE SPRITES*/ 
				//Does find and replace in the tilemap (may be hacky, but its convenient)
				var sprList = sprId.split(",");
				for (row in room[id].tilemap) {
					for (s in sprList) {
						var col = room[id].tilemap[row].indexOf( sprList[s] );
						//if the sprite is in this row, replace it with the "null tile" and set its starting position
						if (col != -1) {
							room[id].tilemap[row][col] = "0";
							spriteStartLocations[ sprList[s] ] = {
								room : id,
								x : parseInt(col),
								y : parseInt(row)
							};
						}
					}
				}
			}
		}
		else if (getType(lines[i]) === "ITM") {
			var itmId = getId(lines[i]);
			var itmCoord = lines[i].split(" ")[2].split(",");
			var itm = {
				id: itmId,
				x : parseInt(itmCoord[0]),
				y : parseInt(itmCoord[1])
			};
			room[id].items.push( itm );
		}
		else if (getType(lines[i]) === "WAL") {
			/* DEFINE COLLISIONS (WALLS) */
			room[id].walls = getId(lines[i]).split(",");
		}
		else if (getType(lines[i]) === "EXT") {
			/* ADD EXIT */
			var exitArgs = lines[i].split(" ");
			//arg format: EXT 10,5 M 3,2 [AVA:7 LCK:a,9] [AVA 7 LCK a 9]
			var exitCoords = exitArgs[1].split(",");
			var destName = exitArgs[2];
			var destCoords = exitArgs[3].split(",");
			var ext = {
				x : parseInt(exitCoords[0]),
				y : parseInt(exitCoords[1]),
				dest : {
					room : destName,
					x : parseInt(destCoords[0]),
					y : parseInt(destCoords[1])
				},
				transition_effect : null,
				// TODO : vNext
				// script_id : null,
			};

			// optional arguments
			var exitArgIndex = 4;
			while (exitArgIndex < exitArgs.length) {
				if (exitArgs[exitArgIndex] == "FX") {
					ext.transition_effect = exitArgs[exitArgIndex+1];
					exitArgIndex += 2;
				}
				// TODO : vNext
				// else if (exitArgs[exitArgIndex] == "PRG") {
				// 	ext.script_id = exitArgs[exitArgIndex+1];
				// 	exitArgIndex += 2;
				// }
				else {
					exitArgIndex += 1;
				}
			}

			room[id].exits.push(ext);
		}
		else if (getType(lines[i]) === "END") {
			/* ADD ENDING */
			var endId = getId( lines[i] );
			var endCoords = getCoord( lines[i], 2 );
			var end = {
				id : endId,
				x : parseInt( endCoords[0] ),
				y : parseInt( endCoords[1] )
			};
			room[id].endings.push(end);
		}
		// TODO : vNext
		// else if (getType(lines[i]) === "EFF") {
		// 	/* ADD EFFECT */
		// 	var effectId = getId( lines[i] );
		// 	var effectCoords = getCoord( lines[i], 2 );
		// 	var effect = {
		// 		id : effectId,
		// 		x : parseInt( effectCoords[0] ),
		// 		y : parseInt( effectCoords[1] ),
		// 	};
		// 	room[id].effects.push(effect);
		// }
		else if (getType(lines[i]) === "PAL") {
			/* CHOOSE PALETTE (that's not default) */
			room[id].pal = getId(lines[i]);
		}
		else if (getType(lines[i]) === "NAME") {
			var name = lines[i].split(/\s(.+)/)[1];
			room[id].name = name;
			names.room.set( name, id);
		}
		i++;
	}
	return i;
}

function parsePalette(lines,i) { //todo this has to go first right now :(
	var id = getId(lines[i]);
	i++;
	var colors = [];
	var name = null;
	while (i < lines.length && lines[i].length > 0) { //look for empty line
		var args = lines[i].split(" ");
		if(args[0] === "NAME") {
			name = lines[i].split(/\s(.+)/)[1];
		}
		else {
			var col = [];
			lines[i].split(",").forEach(function(i) {
				col.push(parseInt(i));
			});
			colors.push(col);
		}
		i++;
	}
	palette[id] = {
		id : id,
		name : name,
		colors : colors
	};
	return i;
}

function parseTile(lines, i) {
	var id = getId(lines[i]);
	var drwId = null;
	var name = null;

	i++;

	if (getType(lines[i]) === "DRW") { //load existing drawing
		drwId = getId(lines[i]);
		i++;
	}
	else {
		// store tile source
		drwId = "TIL_" + id;
		i = parseDrawingCore( lines, i, drwId );
	}

	//other properties
	var colorIndex = 1; // default palette color index is 1
	var isWall = null; // null indicates it can vary from room to room (original version)
	while (i < lines.length && lines[i].length > 0) { //look for empty line
		if (getType(lines[i]) === "COL") {
			colorIndex = parseInt( getId(lines[i]) );
		}
		else if (getType(lines[i]) === "NAME") {
			/* NAME */
			name = lines[i].split(/\s(.+)/)[1];
			names.tile.set( name, id );
		}
		else if (getType(lines[i]) === "WAL") {
			var wallArg = getArg( lines[i], 1 );
			if( wallArg === "true" ) {
				isWall = true;
			}
			else if( wallArg === "false" ) {
				isWall = false;
			}
		}
		i++;
	}

	//tile data
	tile[id] = {
		id : id,
		drw : drwId, //drawing id
		col : colorIndex,
		animation : {
			isAnimated : (renderer.GetFrameCount(drwId) > 1),
			frameIndex : 0,
			frameCount : renderer.GetFrameCount(drwId)
		},
		name : name,
		isWall : isWall
	};

	return i;
}

function parseSprite(lines, i) {
	var id = getId(lines[i]);
	var drwId = null;
	var name = null;

	i++;

	if (getType(lines[i]) === "DRW") { //load existing drawing
		drwId = getId(lines[i]);
		i++;
	}
	else {
		// store sprite source
		drwId = "SPR_" + id;
		i = parseDrawingCore( lines, i, drwId );
	}

	//other properties
	var colorIndex = 2; //default palette color index is 2
	var dialogId = null;
	var startingInventory = {};
	while (i < lines.length && lines[i].length > 0) { //look for empty line
		if (getType(lines[i]) === "COL") {
			/* COLOR OFFSET INDEX */
			colorIndex = parseInt( getId(lines[i]) );
		}
		else if (getType(lines[i]) === "POS") {
			/* STARTING POSITION */
			var posArgs = lines[i].split(" ");
			var roomId = posArgs[1];
			var coordArgs = posArgs[2].split(",");
			spriteStartLocations[id] = {
				room : roomId,
				x : parseInt(coordArgs[0]),
				y : parseInt(coordArgs[1])
			};
		}
		else if(getType(lines[i]) === "DLG") {
			dialogId = getId(lines[i]);
		}
		else if (getType(lines[i]) === "NAME") {
			/* NAME */
			name = lines[i].split(/\s(.+)/)[1];
			names.sprite.set( name, id );
		}
		else if (getType(lines[i]) === "ITM") {
			/* ITEM STARTING INVENTORY */
			var itemId = getId(lines[i]);
			var itemCount = parseFloat( getArg(lines[i], 2) );
			startingInventory[itemId] = itemCount;
		}
		i++;
	}

	//sprite data
	sprite[id] = {
		id : id,
		drw : drwId, //drawing id
		col : colorIndex,
		dlg : dialogId,
		room : null, //default location is "offstage"
		x : -1,
		y : -1,
		walkingPath : [], //tile by tile movement path (isn't saved)
		animation : {
			isAnimated : (renderer.GetFrameCount(drwId) > 1),
			frameIndex : 0,
			frameCount : renderer.GetFrameCount(drwId)
		},
		inventory : startingInventory,
		name : name
	};
	return i;
}

function parseItem(lines, i) {
	var id = getId(lines[i]);
	var drwId = null;
	var name = null;

	i++;

	if (getType(lines[i]) === "DRW") { //load existing drawing
		drwId = getId(lines[i]);
		i++;
	}
	else {
		// store item source
		drwId = "ITM_" + id; // these prefixes are maybe a terrible way to differentiate drawing tyepes :/
		i = parseDrawingCore( lines, i, drwId );
	}

	//other properties
	var colorIndex = 2; //default palette color index is 2
	var dialogId = null;
	while (i < lines.length && lines[i].length > 0) { //look for empty line
		if (getType(lines[i]) === "COL") {
			/* COLOR OFFSET INDEX */
			colorIndex = parseInt( getArg( lines[i], 1 ) );
		}
		// else if (getType(lines[i]) === "POS") {
		// 	/* STARTING POSITION */
		// 	var posArgs = lines[i].split(" ");
		// 	var roomId = posArgs[1];
		// 	var coordArgs = posArgs[2].split(",");
		// 	spriteStartLocations[id] = {
		// 		room : roomId,
		// 		x : parseInt(coordArgs[0]),
		// 		y : parseInt(coordArgs[1])
		// 	};
		// }
		else if(getType(lines[i]) === "DLG") {
			dialogId = getId(lines[i]);
		}
		else if (getType(lines[i]) === "NAME") {
			/* NAME */
			name = lines[i].split(/\s(.+)/)[1];
			names.item.set( name, id );
		}
		i++;
	}

	//item data
	item[id] = {
		id : id,
		drw : drwId, //drawing id
		col : colorIndex,
		dlg : dialogId,
		// room : null, //default location is "offstage"
		// x : -1,
		// y : -1,
		animation : {
			isAnimated : (renderer.GetFrameCount(drwId) > 1),
			frameIndex : 0,
			frameCount : renderer.GetFrameCount(drwId)
		},
		name : name
	};

	// console.log("ITM " + id);
	// console.log(item[id]);

	return i;
}

function parseDrawing(lines, i) {
	// store drawing source
	var drwId = getId( lines[i] );
	return parseDrawingCore( lines, i, drwId );
}

function parseDrawingCore(lines, i, drwId) {
	var frameList = []; //init list of frames
	frameList.push( [] ); //init first frame
	var frameIndex = 0;
	var y = 0;
	while ( y < tilesize ) {
		var l = lines[i+y];
		var row = [];
		for (x = 0; x < tilesize; x++) {
			row.push( parseInt( l.charAt(x) ) );
		}
		frameList[frameIndex].push( row );
		y++;

		if (y === tilesize) {
			i = i + y;
			if ( lines[i] != undefined && lines[i].charAt(0) === ">" ) {
				// start next frame!
				frameList.push( [] );
				frameIndex++;
				//start the count over again for the next frame
				i++;
				y = 0;
			}
		}
	}

	renderer.SetImageSource(drwId, frameList);

	return i;
}

// TODO : vNext
// var ScriptType = {
// 	Script : 0,
// 	Dialogue : 1, // TODO : move everything to this spelling?
// 	Ending : 2,
// };

function parseScript(lines, i, objectStore) {
	// TODO : vNext
	// if (scriptType === undefined || scriptType === null) {
	// 	scriptType = ScriptType.Script;
	// }

	var id = getId(lines[i]);
	i++;

	var results = scriptUtils.ReadDialogScript(lines,i);

	// TODO : vNext
	// script[id] = {
	// 	source: results.script,
	// 	type: scriptType,
	// };

	objectStore[id] = results.script;

	i = results.index;

	return i;
}

function parseDialog(lines, i) {
	return parseScript(lines, i, dialog);
}

function parseEnding(lines, i) {
	return parseScript(lines, i, ending);
}

function parseVariable(lines, i) {
	var id = getId(lines[i]);
	i++;
	var value = lines[i];
	i++;
	variable[id] = value;
	return i;
}

function parseFontName(lines, i) {
	fontName = getArg(lines[i], 1);
	i++;
	return i;
}

function parseTextDirection(lines, i) {
	textDirection = getArg(lines[i], 1);
	i++;
	return i;
}

function parseFontData(lines, i) {
	// NOTE : we're not doing the actual parsing here --
	// just grabbing the block of text that represents the font
	// and giving it to the font manager to use later

	var localFontName = getId(lines[i]);
	var localFontData = lines[i];
	i++;

	while (i < lines.length && lines[i] != "") {
		localFontData += "\n" + lines[i];
		i++;
	}

	var localFontFilename = localFontName + fontManager.GetExtension();
	fontManager.AddResource( localFontFilename, localFontData );

	return i;
}

function parseFlag(lines, i) {
	var id = getId(lines[i]);
	var valStr = lines[i].split(" ")[2];
	flags[id] = parseInt( valStr );
	i++;
	return i;
}

function drawTile(img,x,y,context) {
	if (!context) { //optional pass in context; otherwise, use default
		context = ctx;
	}
	// NOTE: images are now canvases, instead of raw image data (for chrome performance reasons)
	context.drawImage(img,x*tilesize*scale,y*tilesize*scale,tilesize*scale,tilesize*scale);
}

function drawSprite(img,x,y,context) { //this may differ later (or not haha)
	drawTile(img,x,y,context);
}

function drawItem(img,x,y,context) {
	drawTile(img,x,y,context); //TODO these methods are dumb and repetitive
}

// var debugLastRoomDrawn = "0";

function drawRoom(room,context,frameIndex) { // context & frameIndex are optional
	if (!context) { //optional pass in context; otherwise, use default (ok this is REAL hacky isn't it)
		context = ctx;
	}

	// if (room.id != debugLastRoomDrawn) {
	// 	debugLastRoomDrawn = room.id;
	// 	console.log("DRAW ROOM " + debugLastRoomDrawn);
	// }

	var paletteId = "default";

	if (room === undefined) {
		// protect against invalid rooms
		context.fillStyle = "rgb(" + getPal(paletteId)[0][0] + "," + getPal(paletteId)[0][1] + "," + getPal(paletteId)[0][2] + ")";
		context.fillRect(0,0,canvas.width,canvas.height);
		return;
	}

	//clear screen
	if (room.pal != null && palette[paletteId] != undefined) {
		paletteId = room.pal;
	}
	context.fillStyle = "rgb(" + getPal(paletteId)[0][0] + "," + getPal(paletteId)[0][1] + "," + getPal(paletteId)[0][2] + ")";
	context.fillRect(0,0,canvas.width,canvas.height);

	//draw tiles
	for (i in room.tilemap) {
		for (j in room.tilemap[i]) {
			var id = room.tilemap[i][j];
			if (id != "0") {
				//console.log(id);
				if (tile[id] == null) { // hack-around to avoid corrupting files (not a solution though!)
					id = "0";
					room.tilemap[i][j] = id;
				}
				else {
					// console.log(id);
					drawTile( getTileImage(tile[id],paletteId,frameIndex), j, i, context );
				}
			}
		}
	}

	//draw items
	for (var i = 0; i < room.items.length; i++) {
		var itm = room.items[i];
		drawItem( getItemImage(item[itm.id],paletteId,frameIndex), itm.x, itm.y, context );
	}

	//draw sprites
	for (id in sprite) {
		var spr = sprite[id];
		if (spr.room === room.id) {
			drawSprite( getSpriteImage(spr,paletteId,frameIndex), spr.x, spr.y, context );
		}
	}
}

// TODO : remove these get*Image methods
function getTileImage(t,palId,frameIndex) {
	return renderer.GetImage(t,palId,frameIndex);
}

function getSpriteImage(s,palId,frameIndex) {
	return renderer.GetImage(s,palId,frameIndex);
}

function getItemImage(itm,palId,frameIndex) {
	return renderer.GetImage(itm,palId,frameIndex);
}

function curPal() {
	return getRoomPal(curRoom);
}

function getRoomPal(roomId) {
	var defaultId = "default";

	if (roomId == null) {
		return defaultId;
	}
	else if (room[roomId].pal != null) {
		//a specific palette was chosen
		return room[roomId].pal;
	}
	else {
		if (roomId in palette) {
			//there is a palette matching the name of the room
			return roomId;
		}
		else {
			//use the default palette
			return defaultId;
		}
	}
	return defaultId;
}

var isDialogMode = false;
var isNarrating = false;
var isEnding = false;
var dialogModule = new Dialog();
var dialogRenderer = dialogModule.CreateRenderer();
var dialogBuffer = dialogModule.CreateBuffer();
var fontManager = new FontManager();

function onExitDialog(scriptResult, dialogCallback) {
	isDialogMode = false;
	if (isNarrating) isNarrating = false;
	if (isDialogPreview) {
		isDialogPreview = false;
		if (onDialogPreviewEnd != null)
			onDialogPreviewEnd();
	}

	if (dialogCallback != undefined && dialogCallback != null) {
		dialogCallback(scriptResult);
	}
}

/*
TODO
- titles and endings should also take advantage of the script pre-compilation if possible??
- could there be a namespace collision?
- what about dialog NAMEs vs IDs?
- what about a special script block separate from DLG?
*/
function startNarrating(dialogStr,end) {
	console.log("NARRATE " + dialogStr);

	if(end === undefined) end = false;

	isNarrating = true;
	isEnding = end;
	startDialog(dialogStr);
}

function startItemDialog(itemId) {
	var dialogId = item[itemId].dlg;
	// console.log("START ITEM DIALOG " + dialogId);
	if(dialog[dialogId]){
		var dialogStr = dialog[dialogId];
		startDialog(dialogStr,dialogId);
	}
}

function startSpriteDialog(spriteId) {
	var spr = sprite[spriteId];
	var dialogId = spr.dlg ? spr.dlg : spriteId;
	// console.log("START SPRITE DIALOG " + dialogId);
	if(dialog[dialogId]){
		var dialogStr = dialog[dialogId];
		startDialog(dialogStr,dialogId);
	}
}

function startDialog(dialogStr,scriptId,dialogCallback) {
	// console.log("START DIALOG ");
	if(dialogStr.length <= 0) {
		// console.log("ON EXIT DIALOG -- startDialog 1");
		onExitDialog(dialogCallback);
		return;
	}

	isDialogMode = true;

	dialogRenderer.Reset();
	dialogRenderer.SetCentered( isNarrating /*centered*/ );
	dialogBuffer.Reset();
	scriptInterpreter.SetDialogBuffer( dialogBuffer );

	var onScriptEnd = function(scriptResult) {
		dialogBuffer.OnDialogEnd(function() {
			onExitDialog(scriptResult, dialogCallback);
		});
	};

	if(scriptId === undefined) {
		scriptInterpreter.Interpret( dialogStr, onScriptEnd );
	}
	else {
		if( !scriptInterpreter.HasScript(scriptId) ) {
			scriptInterpreter.Compile( scriptId, dialogStr );
		}
		scriptInterpreter.DebugVisualizeScriptTree(scriptId);
		scriptInterpreter.Run( scriptId, onScriptEnd );
	}

}

var isDialogPreview = false;
function startPreviewDialog(script, onScriptEnd) {
	isNarrating = true;

	isDialogMode = true;

	isDialogPreview = true;

	dialogRenderer.Reset();
	dialogRenderer.SetCentered( true );
	dialogBuffer.Reset();
	scriptInterpreter.SetDialogBuffer( dialogBuffer );

	onDialogPreviewEnd = onScriptEnd;

	scriptInterpreter.Eval( script, null );
}

/* NEW SCRIPT STUFF */
var scriptModule = new Script();
var scriptInterpreter = scriptModule.CreateInterpreter();
var scriptUtils = scriptModule.CreateUtils(); // TODO: move to editor.js?
// scriptInterpreter.SetDialogBuffer( dialogBuffer );
</script>

<!-- Borksy modification: uses better encoded default font. -->
<script type="bitsyFontData" id="ascii_small">
FONT ascii_small
SIZE 6 8
CHAR 0
000000
000000
000000
000000
000000
000000
000000
000000
CHAR 32
000000
000000
000000
000000
000000
000000
000000
000000
CHAR 33
000100
001110
001110
000100
000100
000000
000100
000000
CHAR 34
011011
011011
010010
000000
000000
000000
000000
000000
CHAR 35
000000
001010
011111
001010
001010
011111
001010
000000
CHAR 36
001000
001110
010000
001100
000010
011100
000100
000000
CHAR 37
011001
011001
000010
000100
001000
010011
010011
000000
CHAR 38
001000
010100
010100
001000
010101
010010
001101
000000
CHAR 39
001100
001100
001000
000000
000000
000000
000000
000000
CHAR 40
000100
001000
001000
001000
001000
001000
000100
000000
CHAR 41
001000
000100
000100
000100
000100
000100
001000
000000
CHAR 42
000000
001010
001110
011111
001110
001010
000000
000000
CHAR 43
000000
000100
000100
011111
000100
000100
000000
000000
CHAR 44
000000
000000
000000
000000
000000
001100
001100
001000
CHAR 45
000000
000000
000000
011111
000000
000000
000000
000000
CHAR 46
000000
000000
000000
000000
000000
001100
001100
000000
CHAR 47
000000
000001
000010
000100
001000
010000
000000
000000
CHAR 48
001110
010001
010011
010101
011001
010001
001110
000000
CHAR 49
000100
001100
000100
000100
000100
000100
001110
000000
CHAR 50
001110
010001
000001
000110
001000
010000
011111
000000
CHAR 51
001110
010001
000001
001110
000001
010001
001110
000000
CHAR 52
000010
000110
001010
010010
011111
000010
000010
000000
CHAR 53
011111
010000
010000
011110
000001
010001
001110
000000
CHAR 54
000110
001000
010000
011110
010001
010001
001110
000000
CHAR 55
011111
000001
000010
000100
001000
001000
001000
000000
CHAR 56
001110
010001
010001
001110
010001
010001
001110
000000
CHAR 57
001110
010001
010001
001111
000001
000010
001100
000000
CHAR 58
000000
000000
001100
001100
000000
001100
001100
000000
CHAR 59
000000
000000
001100
001100
000000
001100
001100
001000
CHAR 60
000010
000100
001000
010000
001000
000100
000010
000000
CHAR 61
000000
000000
011111
000000
000000
011111
000000
000000
CHAR 62
001000
000100
000010
000001
000010
000100
001000
000000
CHAR 63
001110
010001
000001
000110
000100
000000
000100
000000
CHAR 64
001110
010001
010111
010101
010111
010000
001110
000000
CHAR 65
001110
010001
010001
010001
011111
010001
010001
000000
CHAR 66
011110
010001
010001
011110
010001
010001
011110
000000
CHAR 67
001110
010001
010000
010000
010000
010001
001110
000000
CHAR 68
011110
010001
010001
010001
010001
010001
011110
000000
CHAR 69
011111
010000
010000
011110
010000
010000
011111
000000
CHAR 70
011111
010000
010000
011110
010000
010000
010000
000000
CHAR 71
001110
010001
010000
010111
010001
010001
001111
000000
CHAR 72
010001
010001
010001
011111
010001
010001
010001
000000
CHAR 73
001110
000100
000100
000100
000100
000100
001110
000000
CHAR 74
000001
000001
000001
000001
010001
010001
001110
000000
CHAR 75
010001
010010
010100
011000
010100
010010
010001
000000
CHAR 76
010000
010000
010000
010000
010000
010000
011111
000000
CHAR 77
010001
011011
010101
010001
010001
010001
010001
000000
CHAR 78
010001
011001
010101
010011
010001
010001
010001
000000
CHAR 79
001110
010001
010001
010001
010001
010001
001110
000000
CHAR 80
011110
010001
010001
011110
010000
010000
010000
000000
CHAR 81
001110
010001
010001
010001
010101
010010
001101
000000
CHAR 82
011110
010001
010001
011110
010010
010001
010001
000000
CHAR 83
001110
010001
010000
001110
000001
010001
001110
000000
CHAR 84
011111
000100
000100
000100
000100
000100
000100
000000
CHAR 85
010001
010001
010001
010001
010001
010001
001110
000000
CHAR 86
010001
010001
010001
010001
010001
001010
000100
000000
CHAR 87
010001
010001
010101
010101
010101
010101
001010
000000
CHAR 88
010001
010001
001010
000100
001010
010001
010001
000000
CHAR 89
010001
010001
010001
001010
000100
000100
000100
000000
CHAR 90
011110
000010
000100
001000
010000
010000
011110
000000
CHAR 91
001110
001000
001000
001000
001000
001000
001110
000000
CHAR 92
000000
010000
001000
000100
000010
000001
000000
000000
CHAR 93
001110
000010
000010
000010
000010
000010
001110
000000
CHAR 94
000100
001010
010001
000000
000000
000000
000000
000000
CHAR 95
000000
000000
000000
000000
000000
000000
000000
111111
CHAR 96
001100
001100
000100
000000
000000
000000
000000
000000
CHAR 97
000000
000000
001110
000001
001111
010001
001111
000000
CHAR 98
010000
010000
011110
010001
010001
010001
011110
000000
CHAR 99
000000
000000
001110
010001
010000
010001
001110
000000
CHAR 100
000001
000001
001111
010001
010001
010001
001111
000000
CHAR 101
000000
000000
001110
010001
011110
010000
001110
000000
CHAR 102
000110
001000
001000
011110
001000
001000
001000
000000
CHAR 103
000000
000000
001111
010001
010001
001111
000001
001110
CHAR 104
010000
010000
011100
010010
010010
010010
010010
000000
CHAR 105
000100
000000
000100
000100
000100
000100
000110
000000
CHAR 106
000010
000000
000110
000010
000010
000010
010010
001100
CHAR 107
010000
010000
010010
010100
011000
010100
010010
000000
CHAR 108
000100
000100
000100
000100
000100
000100
000110
000000
CHAR 109
000000
000000
011010
010101
010101
010001
010001
000000
CHAR 110
000000
000000
011100
010010
010010
010010
010010
000000
CHAR 111
000000
000000
001110
010001
010001
010001
001110
000000
CHAR 112
000000
000000
011110
010001
010001
010001
011110
010000
CHAR 113
000000
000000
001111
010001
010001
010001
001111
000001
CHAR 114
000000
000000
010110
001001
001000
001000
011100
000000
CHAR 115
000000
000000
001110
010000
001110
000001
001110
000000
CHAR 116
000000
001000
011110
001000
001000
001010
000100
000000
CHAR 117
000000
000000
010010
010010
010010
010110
001010
000000
CHAR 118
000000
000000
010001
010001
010001
001010
000100
000000
CHAR 119
000000
000000
010001
010001
010101
011111
001010
000000
CHAR 120
000000
000000
010010
010010
001100
010010
010010
000000
CHAR 121
000000
000000
010010
010010
010010
001110
000100
011000
CHAR 122
000000
000000
011110
000010
001100
010000
011110
000000
CHAR 123
000110
001000
001000
011000
001000
001000
000110
000000
CHAR 124
000100
000100
000100
000100
000100
000100
000100
000100
CHAR 125
001100
000010
000010
000011
000010
000010
001100
000000
CHAR 126
000000
000000
000000
001010
010100
000000
000000
000000
CHAR 160
000000
000000
000000
000000
000000
000000
000000
000000
CHAR 161
000100
000000
000100
000100
001110
001110
000100
000000
CHAR 162
000000
000100
001110
010000
010000
001110
000100
000000
CHAR 163
000110
001001
001000
011110
001000
001001
010111
000000
CHAR 165
010001
001010
000100
011111
000100
011111
000100
000000
CHAR 167
001110
010001
001100
001010
000110
010001
001110
000000
CHAR 171
000000
000000
001001
010010
001001
000000
000000
000000
CHAR 172
000000
000000
111111
000001
000001
000000
000000
000000
CHAR 177
000000
000100
001110
000100
000000
001110
000000
000000
CHAR 178
011000
000100
001000
011100
000000
000000
000000
000000
CHAR 181
000000
000000
010010
010010
010010
011100
010000
010000
CHAR 182
001111
010101
010101
001101
000101
000101
000101
000000
CHAR 187
000000
000000
010010
001001
010010
000000
000000
000000
CHAR 188
010000
010010
010100
001011
010101
000111
000001
000000
CHAR 189
010000
010010
010100
001110
010001
000010
000111
000000
CHAR 191
000100
000000
000100
001100
010000
010001
001110
000000
CHAR 196
001010
000000
000100
001010
010001
011111
010001
000000
CHAR 197
001110
001010
001110
011011
010001
011111
010001
000000
CHAR 198
001111
010100
010100
011111
010100
010100
010111
000000
CHAR 199
001110
010001
010000
010000
010001
001110
000100
001100
CHAR 201
000011
000000
011111
010000
011110
010000
011111
000000
CHAR 209
001010
010100
000000
010010
011010
010110
010010
000000
CHAR 214
010010
001100
010010
010010
010010
010010
001100
000000
CHAR 220
001010
000000
010010
010010
010010
010010
001100
000000
CHAR 223
000000
011100
010010
011100
010010
010010
011100
010000
CHAR 224
001100
000000
001110
000001
001111
010001
001111
000000
CHAR 225
000110
000000
001110
000001
001111
010001
001111
000000
CHAR 226
001110
000000
001110
000001
001111
010001
001111
000000
CHAR 228
001010
000000
001110
000001
001111
010001
001111
000000
CHAR 229
001110
001010
001110
000001
001111
010001
001111
000000
CHAR 230
000000
000000
011110
000101
011111
010100
001111
000000
CHAR 231
000000
001110
010001
010000
010001
001110
000100
001100
CHAR 232
001100
000000
001110
010001
011110
010000
001110
000000
CHAR 233
000011
000000
001110
010001
011110
010000
001110
000000
CHAR 234
001110
000000
001110
010001
011110
010000
001110
000000
CHAR 235
001010
000000
001110
010001
011110
010000
001110
000000
CHAR 236
001000
000000
000100
000100
000100
000100
000110
000000
CHAR 237
000110
000000
000100
000100
000100
000100
000110
000000
CHAR 238
000100
001010
000000
000100
000100
000100
000110
000000
CHAR 239
001010
000000
000100
000100
000100
000100
000110
000000
CHAR 241
001010
010100
000000
011100
010010
010010
010010
000000
CHAR 242
011000
000000
001100
010010
010010
010010
001100
000000
CHAR 243
000110
000000
001100
010010
010010
010010
001100
000000
CHAR 244
001110
000000
001100
010010
010010
010010
001100
000000
CHAR 246
001010
000000
001100
010010
010010
010010
001100
000000
CHAR 247
001010
000000
001110
010001
010001
010001
001110
000000
CHAR 249
011000
000000
010010
010010
010010
010110
001010
000000
CHAR 250
000110
000000
010010
010010
010010
010110
001010
000000
CHAR 251
001110
000000
010010
010010
010010
010110
001010
000000
CHAR 252
010010
000000
010010
010010
010010
010110
001010
000000
CHAR 255
001010
000000
010010
010010
010010
001110
000100
011000
CHAR 402
000010
000101
000100
001110
000100
000100
010100
001000
CHAR 915
011110
010010
010000
010000
010000
010000
010000
000000
CHAR 920
001100
010010
010010
011110
010010
010010
001100
000000
CHAR 931
011111
010000
001000
000100
001000
010000
011111
000000
CHAR 934
001110
000100
001110
010001
001110
000100
001110
000000
CHAR 937
000000
001110
010001
010001
001010
001010
011011
000000
CHAR 948
001100
010000
001000
000100
001110
010010
001100
000000
CHAR 949
000000
001110
010000
011110
010000
001110
000000
000000
CHAR 960
000000
011111
001010
001010
001010
001010
001010
000000
CHAR 963
000000
000000
001111
010010
010010
001100
000000
000000
CHAR 964
000000
000000
001010
010100
000100
000100
000100
000000
CHAR 966
000000
000100
001110
010101
010101
001110
000100
000000
CHAR 8226
000000
000000
000000
001100
001100
000000
000000
000000
CHAR 8252
001010
001010
001010
001010
001010
000000
001010
000000
CHAR 8592
000000
000100
001100
011111
001100
000100
000000
000000
CHAR 8593
000100
001110
011111
000100
000100
000100
000100
000000
CHAR 8594
000000
000100
000110
011111
000110
000100
000000
000000
CHAR 8595
000100
000100
000100
000100
011111
001110
000100
000000
CHAR 8734
000000
000000
001010
010101
010101
001010
000000
000000
CHAR 8735
000000
000000
000000
010000
010000
010000
011111
000000
CHAR 8801
000000
011110
000000
011110
000000
011110
000000
000000
CHAR 8804
000010
001100
010000
001100
000010
000000
011110
000000
CHAR 8805
010000
001100
000010
001100
010000
000000
011110
000000
CHAR 8962
000100
001110
011011
010001
010001
011111
000000
000000
CHAR 8976
000000
000000
011111
010000
010000
010000
000000
000000
CHAR 9472
000000
000000
000000
111111
000000
000000
000000
000000
CHAR 9474
000100
000100
000100
000100
000100
000100
000100
000100
CHAR 9488
000000
000000
000000
111100
000100
000100
000100
000100
CHAR 9492
000100
000100
000100
000111
000000
000000
000000
000000
CHAR 9500
000100
000100
000100
000111
000100
000100
000100
000100
CHAR 9508
000100
000100
000100
111100
000100
000100
000100
000100
CHAR 9516
000000
000000
000000
111111
000100
000100
000100
000100
CHAR 9524
000100
000100
000100
111111
000000
000000
000000
000000
CHAR 9532
000100
000100
000100
111111
000100
000100
000100
000100
CHAR 9552
000000
111111
000000
111111
000000
000000
000000
000000
CHAR 9553
010100
010100
010100
010100
010100
010100
010100
010100
CHAR 9556
000000
011111
010000
010111
010100
010100
010100
010100
CHAR 9557
000000
111100
000100
111100
000100
000100
000100
000100
CHAR 9558
000000
000000
000000
111100
010100
010100
010100
010100
CHAR 9559
000000
111100
000100
110100
010100
010100
010100
010100
CHAR 9561
010100
010100
010100
011111
000000
000000
000000
000000
CHAR 9562
010100
010111
010000
011111
000000
000000
000000
000000
CHAR 9563
000100
111100
000100
111100
000000
000000
000000
000000
CHAR 9564
010100
010100
010100
111100
000000
000000
000000
000000
CHAR 9565
010100
110100
000100
111100
000000
000000
000000
000000
CHAR 9566
000100
000111
000100
000111
000100
000100
000100
000100
CHAR 9567
010100
010100
010100
010111
010100
010100
010100
010100
CHAR 9568
010100
010111
010000
010111
010100
010100
010100
010100
CHAR 9569
000000
000000
010010
010010
010010
011100
010000
010000
CHAR 9570
010100
010100
010100
110100
010100
010100
010100
010100
CHAR 9571
010100
110100
000100
110100
010100
010100
010100
010100
CHAR 9572
000000
111111
000000
111111
000100
000100
000100
000100
CHAR 9573
000000
000000
000000
111111
010100
010100
010100
010100
CHAR 9574
000000
111111
000000
110111
010100
010100
010100
010100
CHAR 9575
000100
111111
000000
111111
000000
000000
000000
000000
CHAR 9576
010100
010100
010100
111111
000000
000000
000000
000000
CHAR 9577
010100
110111
000000
111111
000000
000000
000000
000000
CHAR 9580
010100
110111
000000
110111
010100
010100
010100
010100
CHAR 9601
000000
000000
000000
000000
000000
000000
000000
111111
CHAR 9602
000000
000000
000000
000000
000000
000000
111111
111111
CHAR 9603
000000
000000
000000
000000
000000
111111
111111
111111
CHAR 9604
000000
000000
000000
000000
111111
111111
111111
111111
CHAR 9605
000000
000000
000000
111111
111111
111111
111111
111111
CHAR 9606
000000
000000
111111
111111
111111
111111
111111
111111
CHAR 9607
000000
111111
111111
111111
111111
111111
111111
111111
CHAR 9608
111111
111111
111111
111111
111111
111111
111111
111111
CHAR 9609
111100
111100
111100
111100
111100
111100
111100
111100
CHAR 9610
111100
111100
111100
111100
111100
111100
111100
111100
CHAR 9611
111000
111000
111000
111000
111000
111000
111000
111000
CHAR 9613
110000
110000
110000
110000
110000
110000
110000
110000
CHAR 9615
100000
100000
100000
100000
100000
100000
100000
100000
CHAR 9617
010101
000000
101010
000000
010101
000000
101010
000000
CHAR 9618
010101
101010
010101
101010
010101
101010
010101
101010
CHAR 9619
101010
111111
010101
111111
101010
111111
010101
111111
CHAR 9644
000000
000000
000000
000000
000000
011110
011110
000000
CHAR 9650
000100
000100
001110
001110
011111
011111
000000
000000
CHAR 9658
001000
001100
001110
001111
001110
001100
001000
000000
CHAR 9660
011111
011111
001110
001110
000100
000100
000000
000000
CHAR 9668
000010
000110
001110
011110
001110
000110
000010
000000
CHAR 9675
000000
000000
011110
010010
010010
011110
000000
000000
CHAR 9688
111111
111111
111111
110011
110011
111111
111111
111111
CHAR 9689
111111
111111
100001
101101
101101
100001
111111
111111
CHAR 9786
001110
010001
011011
010001
010101
010001
001110
000000
CHAR 9787
001110
011111
010101
011111
010001
011111
001110
000000
CHAR 9788
000000
010101
001110
011011
001110
010101
000000
000000
CHAR 9792
001110
010001
010001
001110
000100
001110
000100
000000
CHAR 9794
000000
000111
000011
001101
010010
010010
001100
000000
CHAR 9824
000000
000100
001110
011111
011111
000100
001110
000000
CHAR 9827
000100
001110
001110
000100
011111
011111
000100
000000
CHAR 9829
000000
001010
011111
011111
011111
001110
000100
000000
CHAR 9830
000000
000100
001110
011111
011111
001110
000100
000000
CHAR 9834
000100
000110
000101
000100
001100
011100
011000
000000
CHAR 9835
000011
001101
001011
001101
001011
011011
011000
000000
</script>

<!-- BORKSY HACKS -->
<script type="text/javascript" id="borksyHacks">
//borksy uses dist versions of hacks from the bitsy hacks repo now

/**
📜
@file long dialog
@summary put more words onscreen
@license MIT
@version 1.1.3
@requires Bitsy Version: 6.1
@author Sean S. LeBlanc

@description
Makes the dialog box variable in height, allowing it to expand as needed.

Minimum and maximum size are configurable.
Cheat sheet:
	2: bitsy default
	8: reaches just below the halfway mark
	16: roughly the max of the original bitsy margins
	19: max before cutting off text

Note: this hack also includes the paragraph break hack
A common pattern in bitsy is using intentional whitespace to force new dialog pages,
but the long dialog hack makes that look awkward since the text box expands.
The paragraph break hack lets you get around this by using a (p) tag to immediately end the current page.

HOW TO USE:
	1. Copy-paste this script into a new script tag after the Bitsy source code.
	2. edit hackOptions below as needed
*/
this.hacks = this.hacks || {};
(function (exports, bitsy) {
'use strict';
var hackOptions = {
minRows: 2,
maxRows: 4,
};

bitsy = bitsy && bitsy.hasOwnProperty('default') ? bitsy['default'] : bitsy;

/**
@file utils
@summary miscellaneous bitsy utilities
@author Sean S. LeBlanc
*/

/*
Helper used to replace code in a script tag based on a search regex
To inject code without erasing original string, using capturing groups; e.g.
	inject(/(some string)/,'injected before $1 injected after')
*/
function inject(searchRegex, replaceString) {
	// find the relevant script tag
	var scriptTags = document.getElementsByTagName('script');
	var scriptTag;
	var code;
	for (var i = 0; i < scriptTags.length; ++i) {
		scriptTag = scriptTags[i];
		var matchesSearch = scriptTag.textContent.search(searchRegex) !== -1;
		var isCurrentScript = scriptTag === document.currentScript;
		if (matchesSearch && !isCurrentScript) {
			code = scriptTag.textContent;
			break;
		}
	}

	// error-handling
	if (!code) {
		throw 'Couldn\'t find "' + searchRegex + '" in script tags';
	}

	// modify the content
	code = code.replace(searchRegex, replaceString);

	// replace the old script tag with a new one using our modified code
	var newScriptTag = document.createElement('script');
	newScriptTag.textContent = code;
	scriptTag.insertAdjacentElement('afterend', newScriptTag);
	scriptTag.remove();
}

/**
 * Helper for getting an array with unique elements 
 * @param  {Array} array Original array
 * @return {Array}       Copy of array, excluding duplicates
 */
function unique(array) {
	return array.filter(function (item, idx) {
		return array.indexOf(item) === idx;
	});
}

/**

@file kitsy-script-toolkit
@summary makes it easier and cleaner to run code before and after Bitsy functions or to inject new code into Bitsy script tags
@license WTFPL (do WTF you want)
@version 4.0.1
@requires Bitsy Version: 4.5, 4.6
@author @mildmojo

@description
HOW TO USE:
  import {before, after, inject, addDialogTag, addDeferredDialogTag} from "./helpers/kitsy-script-toolkit";

  before(targetFuncName, beforeFn);
  after(targetFuncName, afterFn);
  inject(searchRegex, replaceString);
  addDialogTag(tagName, dialogFn);
  addDeferredDialogTag(tagName, dialogFn);

  For more info, see the documentation at:
  https://github.com/seleb/bitsy-hacks/wiki/Coding-with-kitsy
*/


// Ex: inject(/(names.sprite.set\( name, id \);)/, '$1console.dir(names)');
function inject$1(searchRegex, replaceString) {
	var kitsy = kitsyInit();
	kitsy.queuedInjectScripts.push({
		searchRegex: searchRegex,
		replaceString: replaceString
	});
}

// Ex: before('load_game', function run() { alert('Loading!'); });
//     before('show_text', function run(text) { return text.toUpperCase(); });
//     before('show_text', function run(text, done) { done(text.toUpperCase()); });
function before(targetFuncName, beforeFn) {
	var kitsy = kitsyInit();
	kitsy.queuedBeforeScripts[targetFuncName] = kitsy.queuedBeforeScripts[targetFuncName] || [];
	kitsy.queuedBeforeScripts[targetFuncName].push(beforeFn);
}

function kitsyInit() {
	// return already-initialized kitsy
	if (bitsy.kitsy) {
		return bitsy.kitsy;
	}

	// Initialize kitsy
	bitsy.kitsy = {
		queuedInjectScripts: [],
		queuedBeforeScripts: {},
		queuedAfterScripts: {}
	};

	var oldStartFunc = bitsy.startExportedGame;
	bitsy.startExportedGame = function doAllInjections() {
		// Only do this once.
		bitsy.startExportedGame = oldStartFunc;

		// Rewrite scripts and hook everything up.
		doInjects();
		applyAllHooks();

		// Start the game
		bitsy.startExportedGame.apply(this, arguments);
	};

	return bitsy.kitsy;
}


function doInjects() {
	bitsy.kitsy.queuedInjectScripts.forEach(function (injectScript) {
		inject(injectScript.searchRegex, injectScript.replaceString);
	});
	_reinitEngine();
}

function applyAllHooks() {
	var allHooks = unique(Object.keys(bitsy.kitsy.queuedBeforeScripts).concat(Object.keys(bitsy.kitsy.queuedAfterScripts)));
	allHooks.forEach(applyHook);
}

function applyHook(functionName) {
	var functionNameSegments = functionName.split('.');
	var obj = bitsy;
	while (functionNameSegments.length > 1) {
		obj = obj[functionNameSegments.shift()];
	}
	var lastSegment = functionNameSegments[0];
	var superFn = obj[lastSegment];
	var superFnLength = superFn ? superFn.length : 0;
	var functions = [];
	// start with befores
	functions = functions.concat(bitsy.kitsy.queuedBeforeScripts[functionName] || []);
	// then original
	if (superFn) {
		functions.push(superFn);
	}
	// then afters
	functions = functions.concat(bitsy.kitsy.queuedAfterScripts[functionName] || []);

	// overwrite original with one which will call each in order
	obj[lastSegment] = function () {
		var returnVal;
		var args = [].slice.call(arguments);
		var i = 0;

		function runBefore() {
			// All outta functions? Finish
			if (i === functions.length) {
				return returnVal;
			}

			// Update args if provided.
			if (arguments.length > 0) {
				args = [].slice.call(arguments);
			}

			if (functions[i].length > superFnLength) {
				// Assume funcs that accept more args than the original are
				// async and accept a callback as an additional argument.
				return functions[i++].apply(this, args.concat(runBefore.bind(this)));
			} else {
				// run synchronously
				returnVal = functions[i++].apply(this, args);
				if (returnVal && returnVal.length) {
					args = returnVal;
				}
				return runBefore.apply(this, args);
			}
		}

		return runBefore.apply(this, arguments);
	};
}

function _reinitEngine() {
	// recreate the script and dialog objects so that they'll be
	// referencing the code with injections instead of the original
	bitsy.scriptModule = new bitsy.Script();
	bitsy.scriptInterpreter = bitsy.scriptModule.CreateInterpreter();

	bitsy.dialogModule = new bitsy.Dialog();
	bitsy.dialogRenderer = bitsy.dialogModule.CreateRenderer();
	bitsy.dialogBuffer = bitsy.dialogModule.CreateBuffer();
}

// Rewrite custom functions' parentheses to curly braces for Bitsy's
// interpreter. Unescape escaped parentheticals, too.
function convertDialogTags(input, tag) {
	return input
		.replace(new RegExp('\\\\?\\((' + tag + '(\\s+(".+?"|.+?))?)\\\\?\\)', 'g'), function (match, group) {
			if (match.substr(0, 1) === '\\') {
				return '(' + group + ')'; // Rewrite \(tag "..."|...\) to (tag "..."|...)
			}
			return '{' + group + '}'; // Rewrite (tag "..."|...) to {tag "..."|...}
		});
}


function addDialogFunction(tag, fn) {
	var kitsy = kitsyInit();
	kitsy.dialogFunctions = kitsy.dialogFunctions || {};
	if (kitsy.dialogFunctions[tag]) {
		throw new Error('The dialog function "' + tag + '" already exists.');
	}

	// Hook into game load and rewrite custom functions in game data to Bitsy format.
	before('parseWorld', function (game_data) {
		return [convertDialogTags(game_data, tag)];
	});

	kitsy.dialogFunctions[tag] = fn;
}

/**
 * Adds a custom dialog tag which executes the provided function.
 * For ease-of-use with the bitsy editor, tags can be written as
 * (tagname "parameters") in addition to the standard {tagname "parameters"}
 * 
 * Function is executed immediately when the tag is reached.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters, onReturn){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 *                       onReturn: function to call with return value (just call `onReturn(null);` at the end of your function if your tag doesn't interact with the logic system)
 */
function addDialogTag(tag, fn) {
	addDialogFunction(tag, fn);
	inject$1(
		/(var functionMap = new Map\(\);)/,
		'$1functionMap.set("' + tag + '", kitsy.dialogFunctions.' + tag + ');'
	);
}

/**
 * Helper for printing a paragraph break inside of a dialog function.
 * Adds the function `AddParagraphBreak` to `DialogBuffer`
 */

inject$1(/(this\.AddLinebreak = )/, 'this.AddParagraphBreak = function() { buffer.push( [[]] ); isActive = true; };\n$1');

/**
📃
@file paragraph-break
@summary Adds paragraph breaks to the dialogue parser
@license WTFPL (do WTF you want)
@version 1.1.5
@requires Bitsy Version: 5.0, 5.1
@author Sean S. LeBlanc, David Mowatt

@description
Adds a (p) tag to the dialogue parser that forces the following text to
start on a fresh dialogue screen, eliminating the need to spend hours testing
line lengths or adding multiple line breaks that then have to be reviewed
when you make edits or change the font size.

Usage: (p)

Example: I am a cat(p)and my dialogue contains multitudes

HOW TO USE:
  1. Copy-paste this script into a new script tag after the Bitsy source code.
     It should appear *before* any other mods that handle loading your game
     data so it executes *after* them (last-in first-out).

NOTE: This uses parentheses "()" instead of curly braces "{}" around function
      calls because the Bitsy editor's fancy dialog window strips unrecognized
      curly-brace functions from dialog text. To keep from losing data, write
      these function calls with parentheses like the examples above.

      For full editor integration, you'd *probably* also need to paste this
      code at the end of the editor's `bitsy.js` file. Untested.
*/

// Adds the actual dialogue tag. No deferred version is required.
addDialogTag('p', function (environment, parameters, onReturn) {
	environment.GetDialogBuffer().AddParagraphBreak();
	onReturn(null);
});
// End of (p) paragraph break mod





// override textbox height
inject$1(/textboxInfo\.height = .+;/,
	`Object.defineProperty(textboxInfo, 'height', {
	get() { return textboxInfo.padding_vert + (textboxInfo.padding_vert + relativeFontHeight()) * Math.max(${hackOptions.minRows}, dialogBuffer.CurPage().indexOf(dialogBuffer.CurRow())+Math.sign(dialogBuffer.CurCharCount())) + textboxInfo.arrow_height; }
})`);
// prevent textbox from caching
inject$1(/(if\(textboxInfo\.img == null\))/, '// $1');
// rewrite hard-coded row limit
inject$1(/(else if \(curRowIndex )== 0/g, '$1< ' + hackOptions.maxRows + ' - 1');
inject$1(/(if\( lastPage\.length) <= 1( \) {)/, '$1 < ' + hackOptions.maxRows + ' $2');

exports.hackOptions = hackOptions;

}(this.hacks.long_dialog = this.hacks.long_dialog || {}, window));

/**
🚪
@file exit-from-dialog
@summary exit to another room from dialog, including conditionals
@license WTFPL (do WTF you want)
@version 7.0.3
@requires Bitsy Version: 6.0
@author @mildmojo

@description
Lets you exit to another room from dialog (including inside conditionals).
Use it to make an invisible sprite that acts as a conditional exit, use it to warp
somewhere after a conversation, use it to put a guard at your gate who only
lets you in once you're disguised, use it to require payment before the
ferryman will take you across the river.

Using the (exit) function in any part of a series of dialog will make the
game exit to the new room after the dialog is finished. Using (exitNow) will
immediately warp to the new room, but the current dialog will continue.

Usage:
	(exit "<room name>,<x>,<y>,<transition_effect>")
	(exitNow "<room name>,<x>,<y>,<transition_effect>")

Parameter notes:
	- Every paramater is optional
	- If you omit the room, it will use the current room
	- If you omit the x or y, it will use the current position
	- x and y can be written as relative coordinates (e.g. +3, -4, +0)
	- available transitions at time of writing: fade_w, fade_b, wave, tunnel, slide_u, slide_d, slide_l, slide_r

Examples:
	(exit "FinalRoom,8,4")
	(exit "FinalRoom,8,4,tunnel")
	(exit "FinalRoom")
	(exit "FinalRoom,+0,+0,tunnel")
	(exit ",+1,+1")

HOW TO USE:
1. Copy-paste this script into a new script tag after the Bitsy source code.
   It should appear *before* any other mods that handle loading your game
   data so it executes *after* them (last-in first-out).

NOTE:
This uses parentheses "()" instead of curly braces "{}" around function
calls because the Bitsy editor's fancy dialog window strips unrecognized
curly-brace functions from dialog text. To keep from losing data, write
these function calls with parentheses like the examples above.
*/
(function (bitsy) {
'use strict';

bitsy = bitsy && bitsy.hasOwnProperty('default') ? bitsy['default'] : bitsy;

/**
@file utils
@summary miscellaneous bitsy utilities
@author Sean S. LeBlanc
*/

/*
Helper used to replace code in a script tag based on a search regex
To inject code without erasing original string, using capturing groups; e.g.
	inject(/(some string)/,'injected before $1 injected after')
*/
function inject(searchRegex, replaceString) {
	// find the relevant script tag
	var scriptTags = document.getElementsByTagName('script');
	var scriptTag;
	var code;
	for (var i = 0; i < scriptTags.length; ++i) {
		scriptTag = scriptTags[i];
		var matchesSearch = scriptTag.textContent.search(searchRegex) !== -1;
		var isCurrentScript = scriptTag === document.currentScript;
		if (matchesSearch && !isCurrentScript) {
			code = scriptTag.textContent;
			break;
		}
	}

	// error-handling
	if (!code) {
		throw 'Couldn\'t find "' + searchRegex + '" in script tags';
	}

	// modify the content
	code = code.replace(searchRegex, replaceString);

	// replace the old script tag with a new one using our modified code
	var newScriptTag = document.createElement('script');
	newScriptTag.textContent = code;
	scriptTag.insertAdjacentElement('afterend', newScriptTag);
	scriptTag.remove();
}

/**
 * Helper for getting room by name or id
 * @param {string} name id or name of room to return
 * @return {string} room, or undefined if it doesn't exist
 */
function getRoom(name) {
	var id = Object.prototype.hasOwnProperty.call(bitsy.room, name) ? name : bitsy.names.room.get(name);
	return bitsy.room[id];
}

/**
 * Helper for getting an array with unique elements 
 * @param  {Array} array Original array
 * @return {Array}       Copy of array, excluding duplicates
 */
function unique(array) {
	return array.filter(function (item, idx) {
		return array.indexOf(item) === idx;
	});
}

/**

@file kitsy-script-toolkit
@summary makes it easier and cleaner to run code before and after Bitsy functions or to inject new code into Bitsy script tags
@license WTFPL (do WTF you want)
@version 4.0.1
@requires Bitsy Version: 4.5, 4.6
@author @mildmojo

@description
HOW TO USE:
  import {before, after, inject, addDialogTag, addDeferredDialogTag} from "./helpers/kitsy-script-toolkit";

  before(targetFuncName, beforeFn);
  after(targetFuncName, afterFn);
  inject(searchRegex, replaceString);
  addDialogTag(tagName, dialogFn);
  addDeferredDialogTag(tagName, dialogFn);

  For more info, see the documentation at:
  https://github.com/seleb/bitsy-hacks/wiki/Coding-with-kitsy
*/


// Ex: inject(/(names.sprite.set\( name, id \);)/, '$1console.dir(names)');
function inject$1(searchRegex, replaceString) {
	var kitsy = kitsyInit();
	kitsy.queuedInjectScripts.push({
		searchRegex: searchRegex,
		replaceString: replaceString
	});
}

// Ex: before('load_game', function run() { alert('Loading!'); });
//     before('show_text', function run(text) { return text.toUpperCase(); });
//     before('show_text', function run(text, done) { done(text.toUpperCase()); });
function before(targetFuncName, beforeFn) {
	var kitsy = kitsyInit();
	kitsy.queuedBeforeScripts[targetFuncName] = kitsy.queuedBeforeScripts[targetFuncName] || [];
	kitsy.queuedBeforeScripts[targetFuncName].push(beforeFn);
}

// Ex: after('load_game', function run() { alert('Loaded!'); });
function after(targetFuncName, afterFn) {
	var kitsy = kitsyInit();
	kitsy.queuedAfterScripts[targetFuncName] = kitsy.queuedAfterScripts[targetFuncName] || [];
	kitsy.queuedAfterScripts[targetFuncName].push(afterFn);
}

function kitsyInit() {
	// return already-initialized kitsy
	if (bitsy.kitsy) {
		return bitsy.kitsy;
	}

	// Initialize kitsy
	bitsy.kitsy = {
		queuedInjectScripts: [],
		queuedBeforeScripts: {},
		queuedAfterScripts: {}
	};

	var oldStartFunc = bitsy.startExportedGame;
	bitsy.startExportedGame = function doAllInjections() {
		// Only do this once.
		bitsy.startExportedGame = oldStartFunc;

		// Rewrite scripts and hook everything up.
		doInjects();
		applyAllHooks();

		// Start the game
		bitsy.startExportedGame.apply(this, arguments);
	};

	return bitsy.kitsy;
}


function doInjects() {
	bitsy.kitsy.queuedInjectScripts.forEach(function (injectScript) {
		inject(injectScript.searchRegex, injectScript.replaceString);
	});
	_reinitEngine();
}

function applyAllHooks() {
	var allHooks = unique(Object.keys(bitsy.kitsy.queuedBeforeScripts).concat(Object.keys(bitsy.kitsy.queuedAfterScripts)));
	allHooks.forEach(applyHook);
}

function applyHook(functionName) {
	var functionNameSegments = functionName.split('.');
	var obj = bitsy;
	while (functionNameSegments.length > 1) {
		obj = obj[functionNameSegments.shift()];
	}
	var lastSegment = functionNameSegments[0];
	var superFn = obj[lastSegment];
	var superFnLength = superFn ? superFn.length : 0;
	var functions = [];
	// start with befores
	functions = functions.concat(bitsy.kitsy.queuedBeforeScripts[functionName] || []);
	// then original
	if (superFn) {
		functions.push(superFn);
	}
	// then afters
	functions = functions.concat(bitsy.kitsy.queuedAfterScripts[functionName] || []);

	// overwrite original with one which will call each in order
	obj[lastSegment] = function () {
		var returnVal;
		var args = [].slice.call(arguments);
		var i = 0;

		function runBefore() {
			// All outta functions? Finish
			if (i === functions.length) {
				return returnVal;
			}

			// Update args if provided.
			if (arguments.length > 0) {
				args = [].slice.call(arguments);
			}

			if (functions[i].length > superFnLength) {
				// Assume funcs that accept more args than the original are
				// async and accept a callback as an additional argument.
				return functions[i++].apply(this, args.concat(runBefore.bind(this)));
			} else {
				// run synchronously
				returnVal = functions[i++].apply(this, args);
				if (returnVal && returnVal.length) {
					args = returnVal;
				}
				return runBefore.apply(this, args);
			}
		}

		return runBefore.apply(this, arguments);
	};
}

function _reinitEngine() {
	// recreate the script and dialog objects so that they'll be
	// referencing the code with injections instead of the original
	bitsy.scriptModule = new bitsy.Script();
	bitsy.scriptInterpreter = bitsy.scriptModule.CreateInterpreter();

	bitsy.dialogModule = new bitsy.Dialog();
	bitsy.dialogRenderer = bitsy.dialogModule.CreateRenderer();
	bitsy.dialogBuffer = bitsy.dialogModule.CreateBuffer();
}

// Rewrite custom functions' parentheses to curly braces for Bitsy's
// interpreter. Unescape escaped parentheticals, too.
function convertDialogTags(input, tag) {
	return input
		.replace(new RegExp('\\\\?\\((' + tag + '(\\s+(".+?"|.+?))?)\\\\?\\)', 'g'), function (match, group) {
			if (match.substr(0, 1) === '\\') {
				return '(' + group + ')'; // Rewrite \(tag "..."|...\) to (tag "..."|...)
			}
			return '{' + group + '}'; // Rewrite (tag "..."|...) to {tag "..."|...}
		});
}


function addDialogFunction(tag, fn) {
	var kitsy = kitsyInit();
	kitsy.dialogFunctions = kitsy.dialogFunctions || {};
	if (kitsy.dialogFunctions[tag]) {
		throw new Error('The dialog function "' + tag + '" already exists.');
	}

	// Hook into game load and rewrite custom functions in game data to Bitsy format.
	before('parseWorld', function (game_data) {
		return [convertDialogTags(game_data, tag)];
	});

	kitsy.dialogFunctions[tag] = fn;
}

/**
 * Adds a custom dialog tag which executes the provided function.
 * For ease-of-use with the bitsy editor, tags can be written as
 * (tagname "parameters") in addition to the standard {tagname "parameters"}
 * 
 * Function is executed immediately when the tag is reached.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters, onReturn){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 *                       onReturn: function to call with return value (just call `onReturn(null);` at the end of your function if your tag doesn't interact with the logic system)
 */
function addDialogTag(tag, fn) {
	addDialogFunction(tag, fn);
	inject$1(
		/(var functionMap = new Map\(\);)/,
		'$1functionMap.set("' + tag + '", kitsy.dialogFunctions.' + tag + ');'
	);
}

/**
 * Adds a custom dialog tag which executes the provided function.
 * For ease-of-use with the bitsy editor, tags can be written as
 * (tagname "parameters") in addition to the standard {tagname "parameters"}
 * 
 * Function is executed after the dialog box.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 */
function addDeferredDialogTag(tag, fn) {
	addDialogFunction(tag, fn);
	bitsy.kitsy.deferredDialogFunctions = bitsy.kitsy.deferredDialogFunctions || {};
	var deferred = bitsy.kitsy.deferredDialogFunctions[tag] = [];
	inject$1(
		/(var functionMap = new Map\(\);)/,
		'$1functionMap.set("' + tag + '", function(e, p, o){ kitsy.deferredDialogFunctions.' + tag + '.push({e:e,p:p}); o(null); });'
	);
	// Hook into the dialog finish event and execute the actual function
	after('onExitDialog', function () {
		while (deferred.length) {
			var args = deferred.shift();
			bitsy.kitsy.dialogFunctions[tag](args.e, args.p, args.o);
		}
	});
	// Hook into the game reset and make sure data gets cleared
	after('clearGameData', function () {
		deferred.length = 0;
	});
}

/**
 * Adds two custom dialog tags which execute the provided function,
 * one with the provided tagname executed after the dialog box,
 * and one suffixed with 'Now' executed immediately when the tag is reached.
 *
 * i.e. helper for the (exit)/(exitNow) pattern.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 */
function addDualDialogTag(tag, fn) {
	addDialogTag(tag + 'Now', function (environment, parameters, onReturn) {
		fn(environment, parameters);
		onReturn(null);
	});
	addDeferredDialogTag(tag, fn);
}



// Implement the dialog functions
addDualDialogTag('exit', function (environment, parameters) {
	var exit = getExitParams(parameters);
	if (!exit) {
		return;
	}
	bitsy.movePlayerThroughExit(exit);
});

function getExitParams(parameters) {
	var p = bitsy.player();
	var params = parameters[0].split(',');
	var roomName = params[0];
	var x = params[1];
	var y = params[2];
	var transitionEffect = params[3];
	var room = getRoom(roomName);

	if (!room) {
		room = bitsy.room[p.room];
	}

	if (!x) {
		x = p.x;
	} else if (x.startsWith('+') || x.startsWith('-')) {
		x = p.x + Number(x);
	} else {
		x = Number(x);
	}

	if (!y) {
		y = p.y;
	} else if (y.startsWith('+') || y.startsWith('-')) {
		y = p.y + Number(y);
	} else {
		y = Number(y);
	}

	return {
		dest: {
			room: room.id,
			x,
			y,
		},
		transition_effect: transitionEffect,
	};
}
// End of (exit) dialog function mod

}(window));



</script>

<script type="text/javascript" id="borksyAdditionalJS">

</script>

</head>


<!-- DOCUMENT BODY -->
<body onload='startExportedGame()'>
  <div id="sidebar"></div>
  <!-- GAME CANVAS -->
  <div id="main">
      <canvas id='game'></canvas>
  </div>

<script src="../../script/sidebar.js"></script>

<audio id="Perlon -  Ricardo Villalobos - Frank Mueller Melodram-192.mp3" src="Perlon -  Ricardo Villalobos - Frank Mueller Melodram-192.mp3" autoplay loop></audio>

<script>
function unmute() {
    document.getElementById("Perlon -  Ricardo Villalobos - Frank Mueller Melodram-192.mp3").play();
    document.removeEventListener('pointerup', unmute);
    document.removeEventListener('keydown', unmute);
}
document.addEventListener('pointerup', unmute);
document.addEventListener('keydown', unmute);
</script>
</body>

<link rel="stylesheet" href="../../styles/otherseas.css">

</html>